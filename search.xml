<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>GCC15 LTO实现详解</title>
      <link href="/GCC15-LTO-Analysis/"/>
      <url>/GCC15-LTO-Analysis/</url>
      
        <content type="html"><![CDATA[<h2 id="开启LTO编译后的完整过程-命令执行过程分析"><a href="#开启LTO编译后的完整过程-命令执行过程分析" class="headerlink" title="开启LTO编译后的完整过程 - 命令执行过程分析"></a>开启LTO编译后的完整过程 - 命令执行过程分析</h2>]]></content>
      
      
      
        <tags>
            
            <tag> GCC </tag>
            
            <tag> LTO </tag>
            
            <tag> Livepatch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dynamic-Loader设计中需要关注的部分</title>
      <link href="/loader/"/>
      <url>/loader/</url>
      
        <content type="html"><![CDATA[<h2 id="load-objects-to-form-image"><a href="#load-objects-to-form-image" class="headerlink" title="load objects to form image"></a>load objects to form image</h2><p>此处的image，指的是ELF文件在被加载到process memory之后，形成的memory layout。在ELF文件中，最基本的unit是section。section按照不同的权限级别，进行划分后，形成segment。</p><p>可以说，section是编译的直接产物，而segment用于指导kernel如何通过ELF生成image。</p><p>在process加载ELF的过程中，process的一部分信息会放入auxiliary vector。这部分实现可以参考<a href="https://elixir.bootlin.com/linux/v5.10.71/source/fs/binfmt_elf.c#L172">此处</a></p><p>参考<a href="https://refspecs.linuxbase.org/elf/x86_64-abi-0.99.pdf">x86_64-abi-0.99</a>，其中比较有意思的几个参数是：</p><ol><li>AT_EXECFD &#x2F; AT_PHDR<br>如果kernel设置了AT_EXECFD，表明进程涉及的object文件需要dynamic loader通过fd去读取。</li></ol><p>具体到linux内核中，仅有binfmt-misc支持设置AT_EXECFD。</p><ol start="2"><li>AT_ENTRY</li></ol><p>记录了process的程序执行入口地址。</p><h2 id="calcuate-load-bias-ASLR"><a href="#calcuate-load-bias-ASLR" class="headerlink" title="calcuate load_bias (ASLR)"></a>calcuate load_bias (ASLR)</h2><p>dynamic loader在开始运行后，需要计算自身的load_bias，即计算segment header中的地址和实际加载地址之间的偏差。</p><p>对于一个binary&#x2F;libary来说，segment之间的偏移是固定的，因此load_bias都是针对一整个binary&#x2F;library来说的。</p><p>load_bias的计算，只需要任意选取内部的一个锚点，计算理论值和实际值的偏差即可。对于dynamic loader来说，直接计算program header table本身的偏差即可。</p><p>理论值：program header table本身的地址记录在type为PT_PHDR的segment中。</p><p>实际值：记录在auxiliary vector中，对应的type为AT_PHDR。</p><p>核心的代码实现参考如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const Elf64Phdr* phdr = (const Elf64Phdr*)sysv-&gt;auxv[AT_PHDR];</span><br><span class="line">for (unsigned phdrnum = sysv-&gt;auxv[AT_PHNUM]; --phdrnum; ++phdr) &#123;</span><br><span class="line">    if (phdr-&gt;type == PT_PHDR) &#123;</span><br><span class="line">        prog.base = (uint8_t*)(sysv-&gt;auxv[AT_PHDR] - phdr-&gt;vaddr);</span><br><span class="line">    &#125; else if (phdr-&gt;type == PT_DYNAMIC) &#123;</span><br><span class="line">        dynoff = phdr-&gt;vaddr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="resolve-relocations"><a href="#resolve-relocations" class="headerlink" title="resolve relocations"></a>resolve relocations</h2><p>relocation是为了解决未知引用的问题。所谓未知引用，即引用的地方和被引用的地方，彼此之间的偏移无法确定。无法确定最主要的原因在于，使用了外部符号，细分下来的类型很多。</p><p>relocation涉及三部分的信息：</p><ol><li>引用的地址</li><li>被引用的符号</li><li>计算被引用地址的过程</li></ol><h2 id="prelink"><a href="#prelink" class="headerlink" title="prelink"></a>prelink</h2><p>prelink是为了解决relocation过多，引起的加载耗时问题。在ELF加载到process memory变成image的过程中。直到运行前，这部分逻辑是可以提前进行的。提前进行的代价就是，不同binary或者library之间的offset必须得确定下来，从而可以提前进行relocation过程。这在一定程度上牺牲了安全性，获取了运行性能。在主流的发行版中，当前已看不到prelink的使用，合理猜测，性能收益已经抵不上安全性的损失。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li><a href="https://github.com/johannst/dynld">dynld</a></li><li><a href="https://netwinder.osuosl.org/users/p/patb/public_html/elf_relocs.html">relocs</a></li><li><a href="https://sourceware.org/gnu-gabi/prelink.txt">prelink</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> ELF </tag>
            
            <tag> Compiler </tag>
            
            <tag> Loader </tag>
            
            <tag> Process </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>context_switch and restart_syscall</title>
      <link href="/context-switch-and-restart-syscall/"/>
      <url>/context-switch-and-restart-syscall/</url>
      
        <content type="html"><![CDATA[<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>考虑以下程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int ret;</span><br><span class="line">    printf(&quot;%d starts to work \n&quot;, getpid());</span><br><span class="line">    ret = sleep(200);</span><br><span class="line">    printf(&quot;sleep return with %d \n&quot;, ret);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尝试使用gdb单步该程序，在该程序进入sleep syscall之后，通过以下命令唤醒该程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -SIGCONT &lt;pid&gt;</span><br></pre></td></tr></table></figure><p>发现程序在响应signal之后，接着继续执行之前的sleep syscall。更令人费解的地方在于，在响应signal的时候，通过检查寄存器，发现当前程序的pc寄存器是指向sleep syscall指令之后的。</p><p>因此，可以确定的是，kernel里存在某种机制，可以重启被signal中断的syscall，且这个机制会修改context的pc寄存器。通过检索源码，发现这种机制叫做restart block。</p><p>在理解这个机制的过程中，顺着一起整理了sleep过程中会遇到的所有情况。</p><h2 id="sleep的核心实现"><a href="#sleep的核心实现" class="headerlink" title="sleep的核心实现"></a>sleep的核心实现</h2><p>sleep在内核中，最核心的实现是以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">static int __sched do_nanosleep(struct hrtimer_sleeper *t, enum hrtimer_mode mode)</span><br><span class="line">&#123;</span><br><span class="line">struct restart_block *restart;</span><br><span class="line"></span><br><span class="line">do &#123;</span><br><span class="line">set_current_state(TASK_INTERRUPTIBLE|TASK_FREEZABLE);</span><br><span class="line">hrtimer_sleeper_start_expires(t, mode);</span><br><span class="line"></span><br><span class="line">if (likely(t-&gt;task))</span><br><span class="line">schedule();</span><br><span class="line"></span><br><span class="line">hrtimer_cancel(&amp;t-&gt;timer);</span><br><span class="line">mode = HRTIMER_MODE_ABS;</span><br><span class="line"></span><br><span class="line">&#125; while (t-&gt;task &amp;&amp; !signal_pending(current));</span><br><span class="line"></span><br><span class="line">__set_current_state(TASK_RUNNING);</span><br><span class="line"></span><br><span class="line">if (!t-&gt;task)</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">restart = &amp;current-&gt;restart_block;</span><br><span class="line">if (restart-&gt;nanosleep.type != TT_NONE) &#123;</span><br><span class="line">ktime_t rem = hrtimer_expires_remaining(&amp;t-&gt;timer);</span><br><span class="line">struct timespec64 rmt;</span><br><span class="line"></span><br><span class="line">if (rem &lt;= 0)</span><br><span class="line">return 0;</span><br><span class="line">rmt = ktime_to_timespec64(rem);</span><br><span class="line"></span><br><span class="line">return nanosleep_copyout(restart, &amp;rmt);</span><br><span class="line">&#125;</span><br><span class="line">return -ERESTART_RESTARTBLOCK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有两个细节值得关注：</p><ol><li>计时器的外面套了一个do-while循环，用于持续检查是否有signal到来</li><li>假设在计时器结束之前，有signal被触发了，后续的逻辑会计算剩余时间，更新restart block结构体。</li></ol><p>这两个细节都触及到了我的知识盲区，一个个来讨论。</p><h2 id="schedule和context-switch"><a href="#schedule和context-switch" class="headerlink" title="schedule和context switch"></a>schedule和context switch</h2><p>一开始我以为schedule在选中用户态的线程之后，会直接切入用户态继续执行。现在看来，这个想法是片面的。对于因为sleep未结束而block在kernel的用户态线程，在schedule之后，应该是继续在内核中。sleep此处的do-while就是用来做这种处理。</p><p>为了更好的解答以上的困惑，我重新整理了对相关知识的理解。</p><h3 id="syscall-instruction的本质是什么"><a href="#syscall-instruction的本质是什么" class="headerlink" title="syscall instruction的本质是什么"></a>syscall instruction的本质是什么</h3><p>interrupt是cpu在正常执行过程中，需要相应的一些事件。interrupt可以分为同步和异步。也可以分为软件和硬件。</p><p><em>可以认为</em>(取决于具体的实现方式)，syscall的本质是一种同步的software interrput。</p><h3 id="schedule和context-switch的过程"><a href="#schedule和context-switch的过程" class="headerlink" title="schedule和context switch的过程"></a>schedule和context switch的过程</h3><p>这里不会讨论太详细的细节，在context switch的过程中，内核会对比current和next线程的状态，来决定是否要更新mm table。存在四种可能的切换：</p><blockquote><p>&#x2F;*<br>    * kernel -&gt; kernel   lazy + transfer active<br>    *   user -&gt; kernel   lazy + mmgrab() active<br>    *<br>    * kernel -&gt;   user   switch + mmdrop() active<br>    *   user -&gt;   user   switch<br>*&#x2F;</p></blockquote><p>这里就是造成我误解的地方，此处的user并不是指直接切入用户态执行，而是指该线程是用户态的。在context swicth结束之后，假设切入到了user线程的上下文，此时仍然是内核态的，因为从内核态切换到用户态，并不是简单的jmp指令就可以完成的。</p><h2 id="restart-block的实现"><a href="#restart-block的实现" class="headerlink" title="restart block的实现"></a>restart block的实现</h2><p>上面提到，所有restart相关的信息，会被记录到restart block中。在sleep被interrupt之后，剩余的时间会被更新到这部分结构体之中。</p><p>剩下的一个问题在于，虽然记录了剩余的时间，是如何重新触发了syscall本身。阅读代码发现，在kernel的handle_signal实现中，存在以下逻辑：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">if (syscall_get_nr(current, regs) != -1) &#123;</span><br><span class="line">/* If so, check system call restarting.. */</span><br><span class="line">switch (syscall_get_error(current, regs)) &#123;</span><br><span class="line">case -ERESTART_RESTARTBLOCK:</span><br><span class="line">case -ERESTARTNOHAND:</span><br><span class="line">regs-&gt;ax = -EINTR;</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case -ERESTARTSYS:</span><br><span class="line">if (!(ksig-&gt;ka.sa.sa_flags &amp; SA_RESTART)) &#123;</span><br><span class="line">regs-&gt;ax = -EINTR;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">fallthrough;</span><br><span class="line">case -ERESTARTNOINTR:</span><br><span class="line">regs-&gt;ax = regs-&gt;orig_ax;</span><br><span class="line">regs-&gt;ip -= 2;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这也就解答了上面遇到的问题，是signal本身，检查到需要restart syscall之后，会去修改pc寄存器，这样在返回用户态之后，会重新执行syscall。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li><a href="https://prathamsahu52.github.io/post/linux_scheduler/">linux schedule and context switch</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Syscall </tag>
            
            <tag> Schedule </tag>
            
            <tag> Signal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Linux内核unexported symbol的办法</title>
      <link href="/unexported-symbol-reference/"/>
      <url>/unexported-symbol-reference/</url>
      
        <content type="html"><![CDATA[<p>在编写内核驱动时，如果使用到了未被export的函数，kbuild在modpost这一步会报如下错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ERROR: modpost: &quot;kernel_clone&quot; [/data/simple.ko] undefined!</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>想要调用一个函数，需要两个东西，一个是函数原型，另一个则是函数地址。原型的获取没有难度，解决问题的关键在于如何获取对应unexported函数的地址。</p><h2 id="读取符号表"><a href="#读取符号表" class="headerlink" title="读取符号表"></a>读取符号表</h2><p>最直接的思路，就是读取&#x2F;proc&#x2F;kallsyms，获取对应函数的地址后，把地址作为参数赋给内核驱动。整个过程可以封装成一个脚本。</p><h2 id="通过kprobe"><a href="#通过kprobe" class="headerlink" title="通过kprobe"></a>通过kprobe</h2><p>kprobe在register过程，也可以获取相应符号的地址，通过kprobe获取到地址后，再把相应的kprobe remove掉。</p><h2 id="通过klp机制"><a href="#通过klp机制" class="headerlink" title="通过klp机制"></a>通过klp机制</h2><p>在制作内核热补丁的过程中，大量引用了kernel的symbol，这些symbol既有global，也有local的，自然也包含各种unported的情况。</p><p>klp(kernel livepatch)对符号的处理，分成两大部分。</p><h3 id="引用vmlinux的符号"><a href="#引用vmlinux的符号" class="headerlink" title="引用vmlinux的符号"></a>引用vmlinux的符号</h3><p>处理过程的函数调用链为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">load_module</span><br><span class="line"></span><br><span class="line">    -&gt; apply_relocations</span><br><span class="line"></span><br><span class="line">        -&gt; klp_apply_section_relocs</span><br><span class="line"></span><br><span class="line">            -&gt; klp_write_section_relocs</span><br><span class="line"></span><br><span class="line">                -&gt; klp_resolve_symbols</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>处理过程，存在以下约定：</p><ol><li>rela section的flag设置了SHF_RELA_LIVEPATCH</li></ol><p>对应以下代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">info-&gt;sechdrs[i].sh_flags &amp; SHF_RELA_LIVEPATCH</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>rela section的命名格式为：.klp.rela.sec_objname.section_name</li></ol><p>这其中最关键的时sec_objname，这里仅有检查到时vmlinux才会进一步处理。</p><ol start="3"><li>relocation中对应的undefined symbol的st_shndx为SHN_LIVEPATCH</li></ol><p>对应以下代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sym-&gt;st_shndx != SHN_LIVEPATCH</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li>symbol的name格式为.klp.sym.sym_objname.sym_name,sympos</li></ol><p>其中，sym_objname&#x2F;sym_name&#x2F;symops都是find_symbol使用的参数，决定了这个symbol会被resolve到什么地址</p><h3 id="引用非vmlinux的符号"><a href="#引用非vmlinux的符号" class="headerlink" title="引用非vmlinux的符号"></a>引用非vmlinux的符号</h3><p>这里分为loaded的模块和unloaded的模块。</p><p>对于loaded的模块，符号的解析路径为(由当前的klp ko触发)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">klp_enable_patch</span><br><span class="line"></span><br><span class="line">    -&gt; klp_init_patch</span><br><span class="line"></span><br><span class="line">        -&gt; klp_init_object</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于unloade的模块，符号的解析路径为(由该ko被loaded时触发)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">klp_module_coming</span><br><span class="line"></span><br><span class="line">    -&gt; klp_init_object_loaded</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要明确的是，这两者处理过程，都是遍历已经加载的klp ko。</p><p>因此这一过程无法被一般的内核驱动利用，去引用unexported的symbol。</p><h3 id="利用klp机制来引用vmlinux中的unexported-symbol"><a href="#利用klp机制来引用vmlinux中的unexported-symbol" class="headerlink" title="利用klp机制来引用vmlinux中的unexported symbol"></a>利用klp机制来引用vmlinux中的unexported symbol</h3><p>kernel module在生成过程中，相关的多个object文件通过链接器会生成一个大的object文件，记为<ko_name>.o，对应的修改都针对该<ko_name>.o。</p><p>分为四个过程：</p><ol><li>找到undefined symbol中属于unexported symbol的部分</li></ol><p>这部分的寻找过程参考modpost实现即可</p><ol start="2"><li>修改符号表</li></ol><p>将这些symbol作如下处理：</p><p>a. sym-&gt;st_shndx &#x3D; SHN_LIVEPATCH</p><p>b. name -&gt; klp.sym.sym_objname.sym_name,sympos</p><ol start="3"><li>修改rela section</li></ol><p>将对所有unported symbol存在引用的relocation entry单独聚集成一个section，该section符合以下约定：</p><p>a. sh_flags &amp; SHF_RELA_LIVEPATCH</p><p>b. section name的命名格式为.klp.rela.sec_objname.section_name</p><ol start="4"><li>修改kbuild，在modpost运行之前进行以上处理即可</li></ol><p>以上都是理论分析过程，待有时间写一个程序，验证以上过程。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> ELF </tag>
            
            <tag> Kernel Module </tag>
            
            <tag> Livepatch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入了解GCC的LTO机制</title>
      <link href="/lto-livepatch/"/>
      <url>/lto-livepatch/</url>
      
        <content type="html"><![CDATA[<h2 id="经典的编译链接模型"><a href="#经典的编译链接模型" class="headerlink" title="经典的编译链接模型"></a>经典的编译链接模型</h2><p><img src="/./images/compiler-no-lto.png" title="经典的编译链接过程(见参考2)"></p><p>经典的编译模型，有以下的几个特点：</p><ol><li>每一个源码文件通过汇编器(cc1)生成一个object文件</li><li>所有的object文件经过linker生成binary</li></ol><p>这个模型有两个比较明显的缺点：</p><ol><li>主要的优化都在生成objects这个阶段完成，无法进行全局的优化</li><li>在处理大规模的编译时，linker这一步耗时较长</li></ol><h2 id="LTO是什么"><a href="#LTO是什么" class="headerlink" title="LTO是什么"></a>LTO是什么</h2><p>通常来说，优化时掌握的信息越多，最终的效果就越好。由小及大，编译的优化思路大致可以分为语句级优化，函数级优化，程序级优化等等。</p><p>在上面讨论经典的编译链接模型时，object内部的优化只需要修改汇编器(cc1)的实现即可。比较有难度的是进行objects之间的优化，比如去inline一个在其他源码文件中定义的全局函数。</p><p>在computer programming中讨论这种跨越objects的优化时，常用的概念叫Interprocedural optimization(IPO)。</p><p>与IPO相接近的一个概念，叫Whole Program Optimization(WPO)。</p><p>从上面的经典模型可以知道，有能力看到全部objects信息的，是linker。因此，具体到GCC的实现时，这种优化思路最主要的体现就是Link Time Optimization(LTO)。</p><h2 id="LTO的发展历史"><a href="#LTO的发展历史" class="headerlink" title="LTO的发展历史"></a>LTO的发展历史</h2><p>以下对LTO的发展历史整理，所用的资料都来自Honza Hubička的个人博客(见参考3)。</p><h3 id="open64-2002-和LLVM-2003"><a href="#open64-2002-和LLVM-2003" class="headerlink" title="open64(2002)和LLVM(2003)"></a>open64(2002)和LLVM(2003)</h3><p>在2003年的GCC Summit上，Chris Lattner提出希望用LLVM取代当时正在开发中的Tree SSA，作为GCC的新middle-end，从而使GCC能够支持LTO。</p><p>鲜为人知的一个事情，2002年的时候，open64已经开源，并且作为一个能够支持全部LTO机制的GCC可选后端。</p><h3 id="GCC3-4-引入–combine参数-2004"><a href="#GCC3-4-引入–combine参数-2004" class="headerlink" title="GCC3.4 引入–combine参数(2004)"></a>GCC3.4 引入–combine参数(2004)</h3><p>2004年的时候，GCC3.4发布了。该版本开始，GCC通过实现LTO，开始支持了inter-module optimization(IMP)。</p><p>一般来说，LTO的实现通过把中间语言(intermediate language, IL)加入了objects文件中实现(本质是集中相关的程序逻辑后一起处理)。</p><p>当时的自由基金会担心这种IL的加入会让在不违反GPL2协议的情况下实现hook GCC成为可能。</p><p>Apple的工程师Geoff Keating是最早在GCC中引入IMP的人，这种机制允许GCC的front-end同时处理多个源码文件，并将处理好的多个源码文件作为一个整体传递给back-end。这种机制算是早期的WPO实现。</p><h3 id="GCC4-0-接受了新的IL-Tree-SSA-2005"><a href="#GCC4-0-接受了新的IL-Tree-SSA-2005" class="headerlink" title="GCC4.0 接受了新的IL - Tree SSA(2005)"></a>GCC4.0 接受了新的IL - Tree SSA(2005)</h3><h3 id="LTO在GCC中的早期实现-2005"><a href="#LTO在GCC中的早期实现-2005" class="headerlink" title="LTO在GCC中的早期实现(2005)"></a>LTO在GCC中的早期实现(2005)</h3><p>2005年的时候，来自Google、IBM和Codesoucery的工程师们在GCC的email list中发布了一个正式的proposal - “<a href="http://gcc.gnu.org/projects/lto/lto.pdf">Link-Time Optimization in GCC: Requirements and High-Level design</a>“。这份文件列出了如果要支持LTO实现，现有的GCC需要做的一系列改变。</p><h3 id="WHOPR-Whole-program-optization-2007"><a href="#WHOPR-Whole-program-optization-2007" class="headerlink" title="WHOPR: Whole program optization(2007)"></a>WHOPR: Whole program optization(2007)</h3><p>由于LTO的实现需要庞大的工作量，在此期间，Google的工程师考虑一个另外的问题 - 如何使LTO支持大规模程序的编译。于是，一个新的proposal被提出 - “<a href="https://gcc.gnu.org/projects/lto/whopr.pdf">WHOPR - Fast and Scalable Whole Program Optimizations in GCC</a>“</p><p>按照proposal中的提议，加入WHOPR之后，程序的编译链接模型变成了如下的形式：<br><img src="/./images/gcc-whopr.png"></p><p>整个优化过程主要分为三个步骤：</p><ol><li><p>Local generation(LGEN)<br>这一步每个源码文件被单独编译成IL、local call-graph以及summary information。</p></li><li><p>Whole program analysis(WPA)<br>这一阶段会汇总上一步产生的信息，并进行必要的优化决策，产生global call-graph。最终的global call-graph可能会被划分成几块关系密切的部分，分别单独进行处理。</p></li><li><p>Local transformations(LTRANS)<br>这一步会单独处理上一步产生的几块关系密切的global call-graph子块，应用上一步做出的优化策略，产生最终的object文件。</p></li></ol><h3 id="LIPO-Profile-Feedback-Based-Lightweight-IPO"><a href="#LIPO-Profile-Feedback-Based-Lightweight-IPO" class="headerlink" title="LIPO(Profile Feedback Based Lightweight IPO)"></a>LIPO(Profile Feedback Based Lightweight IPO)</h3><p>相比于编译时做优化的思路，LIPO利用运行时的结果去指导优化策略的选择。</p><h3 id="GCC4-5正式发布了LTO机制-2010"><a href="#GCC4-5正式发布了LTO机制-2010" class="headerlink" title="GCC4.5正式发布了LTO机制(2010)"></a>GCC4.5正式发布了LTO机制(2010)</h3><p>在GCC4.5支持LTO之后，GCC4.6加入了对WHOPR的支持，同时移除了-fwhopr选项。该选项将作为-flto的默认子选项，用户仍让可以通过设置-flto-partition&#x3D;none来关闭fwhopr选项。</p><h3 id="GCC4-7-的版本开始支持kernel使用LTO机制-2012"><a href="#GCC4-7-的版本开始支持kernel使用LTO机制-2012" class="headerlink" title="GCC4.7+的版本开始支持kernel使用LTO机制(2012)"></a>GCC4.7+的版本开始支持kernel使用LTO机制(2012)</h3><h3 id="GCC4-9-2014"><a href="#GCC4-9-2014" class="headerlink" title="GCC4.9(2014)"></a>GCC4.9(2014)</h3><p>GCC4.9对LTO机制做出了一系列的改进，用户感知最明显的是，LTO开启后，默认产生的是slim LTO文件，而不是fat LTO文件。所谓的fat LTO文件，是指同时产生原有的object源码以及LTO需要的IL文件。fat LTO文件的优点在于兼容性，对于那些不支持LTO的工具，依然可以继续按照object文件的原有流程去处理。缺点就是，fat LTO文件会带来双倍的编译耗时。随着工具链的发展完善，这种兼容性的设计就可以移除掉了。</p><h3 id="GCC5-2015"><a href="#GCC5-2015" class="headerlink" title="GCC5(2015)"></a>GCC5(2015)</h3><p>GCC5.0支持了Feedback Directed optimization(FDO)</p><p>按照<a href="https://gcc.gnu.org/wiki/LightweightIpo">GCC wiki</a>的说法，GCC的实现叫做LIPO，LIPO综合了IPO和FDO的优点，换句话说，利用FDO来改进IPO导致的编译时间长和耗费磁盘空间的问题。通过FDO，必要的优化分析可以从link time转移到run time进行。</p><p>完整的过程描述如图所示：</p><p><img src="/./images/gcc-lipo.png"></p><p>图片里的例子，build由4个source组成，经过run time的build analysis，source1需要cross module inline source2里的某些函数，source1在profile-use build时会把source2作为auxiliary一起编译。</p><h3 id="GCC8-2018"><a href="#GCC8-2018" class="headerlink" title="GCC8(2018)"></a><a href="https://hubicka.blogspot.com/2018/06/gcc-8-link-time-and-interprocedural.html">GCC8</a>(2018)</h3><p>从GCC8.1开始，linux发行版开始在构建中开启LTO机制。</p><p>LTO机制长期存在的一个问题，就是编译输出和debug信息(主要是dwarf info)无法准确对应上。这一问题最终通过专门的项目<a href="https://gcc.gnu.org/wiki/early-debug">early-debug</a>解决。</p><p>完整的过程如图所示:<br><img src="/./images/gcc-early-debug.png"></p><p>在Link阶段，会对early debug阶段产生的debug信息进行选择，只选择必要的部分。</p><h3 id="GCC9-2019"><a href="#GCC9-2019" class="headerlink" title="GCC9(2019)"></a><a href="https://hubicka.blogspot.com/2019/05/gcc-9-link-time-and-inter-procedural.html">GCC9</a>(2019)</h3><p>使用GCC9之后，针对测试使用的发行版版本，安装包的总量大小减少了5%，debug包减少了17%。</p><p>GCC9支持设置LTO使用时的并行度(flto&#x3D;n)，这个并行度会影响WPA阶段之后，划分成的子objects的数量。</p><p>可以认为，从GCC9开始，LTO机制逐渐稳定。</p><h2 id="LTO相关的参数及编译产生的sections-GCC12"><a href="#LTO相关的参数及编译产生的sections-GCC12" class="headerlink" title="LTO相关的参数及编译产生的sections(GCC12)"></a>LTO相关的参数及编译产生的sections(GCC12)</h2><h3 id="LTO编译相关的参数"><a href="#LTO编译相关的参数" class="headerlink" title="LTO编译相关的参数"></a>LTO编译相关的参数</h3><ol><li><p>开启LTO编译 - (-flto)</p></li><li><p>控制是否产生fat objects (-ffat-lto-objects)</p></li></ol><p>所谓的fat object，是指产生的object中既包含了正常object code，还有LTO所需的IR。fat object的优点主要是兼容性，对于不支持LTO的工具链依然可以使用，在link阶段依然可以进行normal链接。缺点是编译耗时严重，产生的object过大。</p><p>LTO发展早期，GCC使能LTO机制之后，默认产生的为fat object。后期随着GNU工作链发展成熟，默认产生的object为slim object，即object只包含LTO需要的IR。</p><ol start="3"><li>LTO的编译模式</li></ol><ul><li><p>LTO mode<br>整个程序作为一个源码文件进行优化，优点是进行最大程度的优化，缺点是编译并行度差。</p></li><li><p>WHOPR&#x2F;partition mode (-flto&#x3D;jobserver)<br>这种模式下，整个程序会被划分为几个object，这些object分别进行相应的优化。在这个模式下，整个编译分为三个阶段：<br>a. Local generation(LGEN)<br>b. Whole Program Analysis(WPA)<br>c. Local transformations(LTRANS)</p></li></ul><ol start="4"><li><a href="https://gcc.gnu.org/onlinedocs/gccint/Internal-flags.html">lto1的参数</a></li></ol><ul><li>-fwpa</li><li>-fltrans</li><li>-fltrans-output-list&#x3D;file</li><li>-fresolution&#x3D;file</li></ul><h3 id="LTO开启后，objects包含的相关section"><a href="#LTO开启后，objects包含的相关section" class="headerlink" title="LTO开启后，objects包含的相关section"></a><a href="https://gcc.gnu.org/onlinedocs/gccint/LTO-object-file-layout.html">LTO开启后，objects包含的相关section</a></h3><ol><li><p>.gnu.lto_.opts(Command line options)</p></li><li><p>.gnu.lto_.symtab(Symbol table)</p></li><li><p>.gnu.lto_.decls(Global declarations and types)</p></li><li><p>.gnu.lto_.cgraph(The callgraph)</p></li><li><p>.gnu.lto_.refs(IPA references)</p></li><li><p>.gnu.lto_.function_body.<name>(Function bodies)</p></li><li><p>.gnu.lto_.vars(Static variable initializers)</p></li><li><p>.gnu.lto_.&lt;jmpfuncs&#x2F;pureconst&#x2F;reference&gt;(Summaries and optimization summaries used by IPA passes)</p></li></ol><h2 id="LTO开启后的编译过程"><a href="#LTO开启后的编译过程" class="headerlink" title="LTO开启后的编译过程"></a>LTO开启后的编译过程</h2><p>在不开启的LTO的情况下，C语言编译涉及到的组件有cc1，collect2，其中cc1生成objects文件，collect2被ld(linker)调用，生成最终的binary。</p><p>在加入LTO之后，C语言编译的组件有cc1，collect2，lto1和lto-wrapper，其中lto1和lto-wrapper是针对LTO机制所增加的组件。</p><p>在环境上打开execsnoop，运行以下命令，观察gcc命令的调用过程：</p><blockquote><p>gcc -o server a.c b.c c.c -v -flto&#x3D;auto -ffat-lto-objects  -fdata-sections -ffunction-sections -save-temps</p></blockquote><p>获得的exec调用结果输出为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">gcc              398299  398005    0 /usr/lib64/ccache/gcc -o server a.c b.c c.c -v -flto=auto -ffat-lto-objects -fdata-sections -ffunction-sections -save-temps</span><br><span class="line">gcc              398299  398005    0 /usr/bin/gcc -o server a.c b.c c.c -v -flto=auto -ffat-lto-objects -fdata-sections -ffunction-sections -save-temps</span><br><span class="line">cc1              398300  398299    0 /usr/libexec/gcc/x86_64-redhat-linux/13/cc1 -E -quiet -v a.c -mtune=generic -march=x86-64 -flto=auto -ffat-lto-objects -fdata-sections -ffunction-sections -fpch-preprocess -o server-a.i</span><br><span class="line">cc1              398301  398299    0 /usr/libexec/gcc/x86_64-redhat-linux/13/cc1 -fpreprocessed server-a.i -quiet -dumpdir server- -dumpbase a.c -dumpbase-ext .c -mtune=generic -march=x86-64 -version -flto=auto -ffat-lto-objects -fdata-sections -ffunction-sections -o server-a.s</span><br><span class="line">as               398302  398299    0 /usr/bin/as -v --64 -o server-a.o server-a.s</span><br><span class="line">cc1              398303  398299    0 /usr/libexec/gcc/x86_64-redhat-linux/13/cc1 -E -quiet -v b.c -mtune=generic -march=x86-64 -flto=auto -ffat-lto-objects -fdata-sections -ffunction-sections -fpch-preprocess -o server-b.i</span><br><span class="line">cc1              398304  398299    0 /usr/libexec/gcc/x86_64-redhat-linux/13/cc1 -fpreprocessed server-b.i -quiet -dumpdir server- -dumpbase b.c -dumpbase-ext .c -mtune=generic -march=x86-64 -version -flto=auto -ffat-lto-objects -fdata-sections -ffunction-sections -o server-b.s</span><br><span class="line">as               398305  398299    0 /usr/bin/as -v --64 -o server-b.o server-b.s</span><br><span class="line">cc1              398306  398299    0 /usr/libexec/gcc/x86_64-redhat-linux/13/cc1 -E -quiet -v c.c -mtune=generic -march=x86-64 -flto=auto -ffat-lto-objects -fdata-sections -ffunction-sections -fpch-preprocess -o server-c.i</span><br><span class="line">cc1              398307  398299    0 /usr/libexec/gcc/x86_64-redhat-linux/13/cc1 -fpreprocessed server-c.i -quiet -dumpdir server- -dumpbase c.c -dumpbase-ext .c -mtune=generic -march=x86-64 -version -flto=auto -ffat-lto-objects -fdata-sections -ffunction-sections -o server-c.s</span><br><span class="line">as               398308  398299    0 /usr/bin/as -v --64 -o server-c.o server-c.s</span><br><span class="line">collect2         398309  398299    0 /usr/libexec/gcc/x86_64-redhat-linux/13/collect2 -plugin /usr/libexec/gcc/x86_64-redhat-linux/13/liblto_plugin.so -plugin-opt=/usr/libexec/gcc/x86_64-redhat-linux/13/lto-wrapper -plugin-opt=-fresolution=server.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s -flto=auto --build-id --no-add-needed --eh-frame-hdr --hash-style=gnu -m elf_x86_64 -dynamic-linker /lib64/ld-linux-x86-64.so.2 -o </span><br><span class="line">ld               398310  398309    0 /usr/bin/ld -plugin /usr/libexec/gcc/x86_64-redhat-linux/13/liblto_plugin.so -plugin-opt=/usr/libexec/gcc/x86_64-redhat-linux/13/lto-wrapper -plugin-opt=-fresolution=server.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s --build-id --no-add-needed --eh-frame-hdr --hash-style=gnu -m elf_x86_64 -dynamic-linker /lib64/ld-linux-x86-64.so.2 -o server </span><br><span class="line">lto-wrapper      398311  398310    0 /usr/libexec/gcc/x86_64-redhat-linux/13/lto-wrapper @server.lto_wrapper_args</span><br><span class="line">make             398312  398311    0 /usr/bin/make --version</span><br><span class="line">gcc              398313  398311    0 /usr/bin/gcc @./server.ltrans_args</span><br><span class="line">lto1             398314  398313    0 /usr/libexec/gcc/x86_64-redhat-linux/13/lto1 -quiet -dumpbase ./server.wpa -mtune=generic -march=x86-64 -version -fno-openmp -fno-openacc -fno-pie -fcf-protection=none -ffat-lto-objects -fdata-sections -ffunction-sections -fltrans-output-list=./server.ltrans.out -fwpa=8 -fresolution=server.res -flinker-output=exec @./server.wpa.args.0</span><br><span class="line">make             398315  398311    0 /usr/bin/make -f /tmp/ccSoHZVP.mk -j8 all</span><br><span class="line">gcc              398316  398315    0 /usr/bin/gcc -xlto -c -fno-openmp -fno-openacc -fno-pie -fcf-protection=none -mtune=generic -march=x86-64 -v -ffat-lto-objects -fdata-sections -ffunction-sections -save-temps -mtune=generic -march=x86-64 -dumpdir server. -dumpbase ./server.ltrans0.ltrans </span><br><span class="line">lto1             398317  398316    0 /usr/libexec/gcc/x86_64-redhat-linux/13/lto1 -quiet -dumpbase ./server.ltrans0.ltrans -mtune=generic -march=x86-64 -version -fno-openmp -fno-openacc -fno-pie -fcf-protection=none -ffat-lto-objects -fdata-sections -ffunction-sections -fltrans ./server.ltrans0.o -o ./server.ltrans0.ltrans.s</span><br><span class="line">as               398318  398316    0 /usr/bin/as -v --64 -o ./server.ltrans0.ltrans.o ./server.ltrans0.ltrans.s</span><br></pre></td></tr></table></figure><p>分析pid以及ppid，可以得到以下的调用结构：</p><p><img src="/./images/gcc-compile-lto.png"></p><p>树的不同层次之间的箭头代表是父子进程，同一层次之间的箭头代表前者的输出是后者的输入。</p><p>在这个样例里，由于源码数量较少，所有的源码都被编译到了一个object内。在处理更大的项目构建时，会观察到原有的objects被划分到若干个子object内。</p><p>以openssh的sshd为例，产生的子objects的命名如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/tmp/ccW5uCAJ.ltrans0.ltrans.o</span><br><span class="line">/tmp/ccW5uCAJ.ltrans7.ltrans.o</span><br><span class="line">/tmp/ccW5uCAJ.ltrans10.ltrans.o</span><br></pre></td></tr></table></figure><p>该命令具有如下特点：</p><ol><li>具备统一的前缀 - ccW5uCAJ</li><li>具备连续的编号，这些编号也是链接顺序，决定了在符号表中的排列次序</li></ol><p>这一过程的具体描述可以参考<a href="https://gcc.gnu.org/wiki/whopr/driver">GCC-WHOPR</a>的描述，里面描述了LGEN,WPA,LTRANS阶段的详细行为以及LTO插件的具体实现。</p><h2 id="发行版使用的LTO参数"><a href="#发行版使用的LTO参数" class="headerlink" title="发行版使用的LTO参数"></a>发行版使用的LTO参数</h2><p>fedora使用的编译参数通过rpm包redhat-rpm-config引入，解开这个包，可以发现以下LTO相关的编译参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%_gcc_lto_cflags        -flto=auto -ffat-lto-objects</span><br><span class="line">%_clang_lto_cflags      -flto=thin -ffat-lto-objects</span><br><span class="line">%_lto_cflags            %&#123;expand:%%&#123;_%&#123;toolchain&#125;_lto_cflags&#125;&#125;</span><br></pre></td></tr></table></figure><p>其他发行版的使用情况可以参考以下wiki:</p><ul><li><a href="https://wiki.gentoo.org/wiki/LTO">gentoo</a></li></ul><h2 id="LTO的源码实现"><a href="#LTO的源码实现" class="headerlink" title="LTO的源码实现"></a>LTO的源码实现</h2><p>这部分实现比较复杂，参考<a href="../GCC15-LTO-Analysis">GCC15-LTO实现</a>。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://en.wikipedia.org/wiki/Interprocedural_optimization">Interprocedural_optimization</a></li><li><a href="https://courses.grainger.illinois.edu/cs232/sp2009/lectures/Examples/lecture6/lecture6.html">CS232</a></li><li><a href="https://hubicka.blogspot.com/2014/04/linktime-optimization-in-gcc-1-brief.html">Honza Hubička’s Blog</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> GCC </tag>
            
            <tag> LTO </tag>
            
            <tag> Livepatch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fedora下kvm的bridge网络设置</title>
      <link href="/fedora-kvm-bridge/"/>
      <url>/fedora-kvm-bridge/</url>
      
        <content type="html"><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>本文总结了，在fedora中使用kvm+libvirt的情况下，如何给host添加bridge设备，并且给guest配置网络。</p><p>本文使用的实验环境为fedora 38，该方法要求系统中安装了NetWorkManager。</p><h2 id="host配置"><a href="#host配置" class="headerlink" title="host配置"></a>host配置</h2><h3 id="添加bridge设备"><a href="#添加bridge设备" class="headerlink" title="添加bridge设备"></a>添加bridge设备</h3><p>运行以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">yum -y install bridge-utils</span><br><span class="line">yum -y groupinstall &quot;Virtualization Tools&quot;</span><br><span class="line">export MAIN_CONN=enp8s0</span><br><span class="line">bash -x &lt;&lt;EOS</span><br><span class="line">systemctl stop libvirtd</span><br><span class="line">nmcli c delete &quot;$MAIN_CONN&quot;</span><br><span class="line">nmcli c delete &quot;Wired connection 1&quot;</span><br><span class="line">nmcli c add type bridge ifname br0 autoconnect yes con-name br0 stp off</span><br><span class="line">#nmcli c modify br0 ipv4.addresses 192.168.1.99/24 ipv4.method manual</span><br><span class="line">#nmcli c modify br0 ipv4.gateway 192.168.1.1</span><br><span class="line">#nmcli c modify br0 ipv4.dns 192.168.1.1</span><br><span class="line">nmcli c add type bridge-slave autoconnect yes con-name &quot;$MAIN_CONN&quot; ifname &quot;$MAIN_CONN&quot; master br0</span><br><span class="line">systemctl restart NetworkManager</span><br><span class="line">systemctl start libvirtd</span><br><span class="line">systemctl enable libvirtd</span><br><span class="line">echo &quot;net.ipv4.ip_forward = 1&quot; | sudo tee /etc/sysctl.d/99-ipforward.conf</span><br><span class="line">sysctl -p /etc/sysctl.d/99-ipforward.conf</span><br><span class="line">EOS</span><br></pre></td></tr></table></figure><p>其中，enp8s0替换成自己环境中的网卡名称。如果是通过网络连接，写成脚本，一次性执行完，否则过程会提示断开链接。</p><p>必要的情况下，按照注释代码的写法，给br0配置ip和路由。</p><h3 id="设置防火墙规则"><a href="#设置防火墙规则" class="headerlink" title="设置防火墙规则"></a>设置防火墙规则</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -I FORWARD -i br0 -j ACCEPT</span><br><span class="line">iptables -I FORWARD -o br0 -j ACCEPT</span><br></pre></td></tr></table></figure><p>其中，br0为bridge设备名称。</p><h2 id="Guest配置"><a href="#Guest配置" class="headerlink" title="Guest配置"></a>Guest配置</h2><p>网卡类型配置为bridge，如果开机后，dhcp没有运行，通过ip命令静态配置ip地址:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip link set &lt;device name&gt; up</span><br><span class="line">ip addr add &lt;ip addr&gt;/&lt;length&gt; dev &lt;device name&gt;</span><br><span class="line">ip route add default via &lt;ip addr&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Fedora </tag>
            
            <tag> KVM </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Binary.hacks技巧整理</title>
      <link href="/binary-hacks/"/>
      <url>/binary-hacks/</url>
      
        <content type="html"><![CDATA[<p><a href="pdf/Binary-Hacks.pdf">Binary.Hacks 黑客秘笈100选</a> 是一本比较老的书，里面记录了一些有意思的技巧，本篇blog是对该书的一些总结和补充。</p><h2 id="Hack-14-demangle-C-的symbol"><a href="#Hack-14-demangle-C-的symbol" class="headerlink" title="[Hack 14] demangle C++的symbol"></a>[Hack 14] demangle C++的symbol</h2><blockquote><p>nm –demangle foo.o</p></blockquote><blockquote><p>nm foo.o | c++filt</p></blockquote><h2 id="Hack-20-PIC共享库的性能意义"><a href="#Hack-20-PIC共享库的性能意义" class="headerlink" title="[Hack 20] PIC共享库的性能意义"></a>[Hack 20] PIC共享库的性能意义</h2><p>这一章的本意是强调通过PLT跳转，可以有效减少Relocation的数量。但是，对于较新的编译器版本来说，书中举的例子已经不正确了。</p><p>PIC共享库的优点如下:</p><ul><li>对于相同的外部函数调用，通过PLT表格，只需要执行一次Relocate。</li><li>由于通过PLT进行跳转，text段本身可以在不同的上下文之间进行共享。</li></ul><p>缺点如下:</p><ul><li>函数调用需要多跳转一次，有性能损耗。</li></ul><h2 id="Hack-21-使用statifier对动态链接的可执行文件进行模拟静态链接"><a href="#Hack-21-使用statifier对动态链接的可执行文件进行模拟静态链接" class="headerlink" title="[Hack 21] 使用statifier对动态链接的可执行文件进行模拟静态链接"></a>[Hack 21] 使用<a href="https://github.com/greenpau/statifier">statifier</a>对动态链接的可执行文件进行模拟静态链接</h2><p>这个工具的原理有点像criu的dump过程，把运行过程的memory直接dump下来，再直接恢复运行。statifier的特别之处在于，它把checkpoint的时机选在ELF的entry point前，从而保证每次都是全新的状态运行。</p><h2 id="Hack-22-GNU-GCC的拓展"><a href="#Hack-22-GNU-GCC的拓展" class="headerlink" title="[Hack 22] GNU&#x2F;GCC的拓展"></a>[Hack 22] GNU&#x2F;GCC的拓展</h2><p>书里面介绍了一些abi，还有built-in函数的内容，GNU&#x2F;GCC的拓展内容要比介绍的多得多。</p><h2 id="Hack-24-活用在GCC的built-in函数上的最优化"><a href="#Hack-24-活用在GCC的built-in函数上的最优化" class="headerlink" title="[Hack 24] 活用在GCC的built in函数上的最优化"></a>[Hack 24] 活用在GCC的built in函数上的最优化</h2><p>通过最准确的语义，最大化编译器的优化效果。比如，const的使用决定了编译器对strlen的优化。</p><h3 id="第一种情况，字符串指针被const修饰"><a href="#第一种情况，字符串指针被const修饰" class="headerlink" title="第一种情况，字符串指针被const修饰"></a>第一种情况，字符串指针被const修饰</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">const char *secret = &quot;secret&quot;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a = strlen(secret);</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的反汇编代码为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0000000000401126 &lt;main&gt;:</span><br><span class="line">  401126:55                   push   %rbp</span><br><span class="line">  401127:48 89 e5             mov    %rsp,%rbp</span><br><span class="line">  40112a:48 83 ec 10          sub    $0x10,%rsp</span><br><span class="line">  40112e:48 8b 05 db 2e 00 00 mov    0x2edb(%rip),%rax        # 404010 &lt;secret&gt;</span><br><span class="line">  401135:48 89 c7             mov    %rax,%rdi</span><br><span class="line">  401138:e8 f3 fe ff ff       call   401030 &lt;strlen@plt&gt;</span><br><span class="line">  40113d:89 45 fc             mov    %eax,-0x4(%rbp)</span><br><span class="line">  401140:8b 45 fc             mov    -0x4(%rbp),%eax</span><br><span class="line">  401143:c9                   leave</span><br><span class="line">  401144:c3                   ret</span><br></pre></td></tr></table></figure><p>可以看到产生了一次strlen函数调用。</p><h3 id="第二种情况，字符串指针和字符串同时被const修饰"><a href="#第二种情况，字符串指针和字符串同时被const修饰" class="headerlink" title="第二种情况，字符串指针和字符串同时被const修饰"></a>第二种情况，字符串指针和字符串同时被const修饰</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">const char * const secret = &quot;secret&quot;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a = strlen(secret);</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的反汇编为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0000000000401106 &lt;main&gt;:</span><br><span class="line">  401106:55                   push   %rbp</span><br><span class="line">  401107:48 89 e5             mov    %rsp,%rbp</span><br><span class="line">  40110a:c7 45 fc 06 00 00 00 movl   $0x6,-0x4(%rbp)</span><br><span class="line">  401111:8b 45 fc             mov    -0x4(%rbp),%eax</span><br><span class="line">  401114:5d                   pop    %rbp</span><br><span class="line">  401115:c3                   ret</span><br></pre></td></tr></table></figure><p>可以看到，此时strlen的结果被直接计算出来了，减少了一次调用。</p><p>如果string在使用过程中确实不会变化，应该考虑将其变成literal字符串。</p><h2 id="Hack-27-根据系统不同用glibc来更换加载库"><a href="#Hack-27-根据系统不同用glibc来更换加载库" class="headerlink" title="[Hack 27] 根据系统不同用glibc来更换加载库"></a>[Hack 27] 根据系统不同用glibc来更换加载库</h2><p>通过设定LD_HWCAP_MASK变量，改变加载动态库的查找顺序。</p><h2 id="Hack-32-GCC在栈中生成运行时代码，进行跳转"><a href="#Hack-32-GCC在栈中生成运行时代码，进行跳转" class="headerlink" title="[Hack 32] GCC在栈中生成运行时代码，进行跳转"></a>[Hack 32] GCC在栈中生成运行时代码，进行跳转</h2><p>参考<a href="https://anatasluo.github.io/66174d84bdc2/">GCC编译器通过stack执行代码</a></p><h2 id="HACK-35-PIE-and-PIC"><a href="#HACK-35-PIE-and-PIC" class="headerlink" title="[HACK 35] PIE and PIC"></a>[HACK 35] PIE and PIC</h2><p><a href="https://www.mjr19.org.uk/IT/pic_pie.html">PIE和PIC的使用前提不一样</a>:</p><blockquote><p>neither: code cannot be used in a shared library, nor be included in a PIE executable.<br>PIE: code cannot be used in a shared library, but can be included in both a PIE and non-PIE executable.<br>PIC: code can be used anywhere.</p></blockquote><p>使用前提的不一样，导致优化程度不一样。</p><h2 id="Hack-49-注意64位环境0和NULL的不同"><a href="#Hack-49-注意64位环境0和NULL的不同" class="headerlink" title="[Hack 49] 注意64位环境0和NULL的不同"></a>[Hack 49] 注意64位环境0和NULL的不同</h2><p>在一些特殊构造的例子下，32位的0被cast成了64位的NULL指针。没遇到过这样的情况，对书中的例子没有深究。</p><h2 id="Hack-64-检测运行中进程的路径名"><a href="#Hack-64-检测运行中进程的路径名" class="headerlink" title="[Hack 64] 检测运行中进程的路径名"></a>[Hack 64] 检测运行中进程的路径名</h2><ol><li>从argv[0]获取</li></ol><p>这种办法获取的路径不一定是absolute。</p><ol start="2"><li>从&#x2F;proc&#x2F;self&#x2F;exe</li></ol><p>这种办法读出来的路径是absolute path，但是该路径也是realpath。如果想获取soft link本身的路径，这种办法则不可行。</p><ol start="3"><li>从&#x2F;proc&#x2F;self&#x2F;maps中解析相关路径</li></ol><p>限制同2，解析过程则显得繁琐的多。</p><h2 id="Hack-65-检测正在加载的共享库"><a href="#Hack-65-检测正在加载的共享库" class="headerlink" title="[Hack 65] 检测正在加载的共享库"></a>[Hack 65] 检测正在加载的共享库</h2><ol><li><p>从&#x2F;proc&#x2F;self&#x2F;maps中解析相关路径</p></li><li><p>在Linux上使用dl_iterate_phdr</p></li></ol><h2 id="Hack-67-使用libbf处理ELF文件"><a href="#Hack-67-使用libbf处理ELF文件" class="headerlink" title="[Hack 67] 使用libbf处理ELF文件"></a>[Hack 67] 使用libbf处理ELF文件</h2><p><a href="pdf/bfd.pdf">相关文档</a></p><h2 id="Hack-69-通过ffcall-libffi动态调用函数"><a href="#Hack-69-通过ffcall-libffi动态调用函数" class="headerlink" title="[Hack 69] 通过ffcall&#x2F;libffi动态调用函数"></a>[Hack 69] 通过ffcall&#x2F;libffi动态调用函数</h2><p>动态检测函数的签名，并且发起调用，本质就是按照abi规范，动态生成调用代码。</p><h2 id="Hack-70-通过libdwarf读取调试信息"><a href="#Hack-70-通过libdwarf读取调试信息" class="headerlink" title="[Hack 70] 通过libdwarf读取调试信息"></a>[Hack 70] 通过libdwarf读取调试信息</h2><p><a href="pdf/DWARF5.pdf">相关文档</a></p><h2 id="Hack-71-dumper显示结构体内容"><a href="#Hack-71-dumper显示结构体内容" class="headerlink" title="[Hack 71] dumper显示结构体内容"></a>[Hack 71] <a href="https://shinh.skr.jp/binary/dumper.tgz">dumper</a>显示结构体内容</h2><p>dumper的工作原理是读取进程空间的内存，然后根据debug信息对内存进行解释。</p><h2 id="Hack-72-如何加载并运行object文件"><a href="#Hack-72-如何加载并运行object文件" class="headerlink" title="[Hack 72] 如何加载并运行object文件"></a>[Hack 72] 如何加载并运行object文件</h2><p>参考这篇<a href="https://blog.cloudflare.com/how-to-execute-an-object-file-part-1/">blog</a>，要比书里讲的清楚的多。</p><h2 id="Hack-73-通过libunwind控制call-chain"><a href="#Hack-73-通过libunwind控制call-chain" class="headerlink" title="[Hack 73] 通过libunwind控制call chain"></a>[Hack 73] 通过libunwind控制call chain</h2><p>结合解析栈和操作上下文的能力，libunwind可以改变程序的执行流程。</p><h2 id="Hack-74-用GNU-lightning-Portable生成运行编码"><a href="#Hack-74-用GNU-lightning-Portable生成运行编码" class="headerlink" title="[Hack 74] 用GNU lightning Portable生成运行编码"></a>[Hack 74] 用GNU lightning Portable生成运行编码</h2><p><a href="https://www.gnu.org/software/lightning/">GNU lightning</a>用来生成不依赖处理器抽象特性的汇编程序。</p><h2 id="Hack-76-用signal-stack处理stack-overflow"><a href="#Hack-76-用signal-stack处理stack-overflow" class="headerlink" title="[Hack 76] 用signal stack处理stack overflow"></a>[Hack 76] 用signal stack处理stack overflow</h2><p>通过设置SIGSEGV的处理函数，恢复程序的执行。在这其中，涉及到对栈空间的解释和使用，又引出了red zone和yellow zone的概念。</p><h2 id="Hack-77-Hook面向函数的enter-exit"><a href="#Hack-77-Hook面向函数的enter-exit" class="headerlink" title="[Hack 77] Hook面向函数的enter&#x2F;exit"></a>[Hack 77] Hook面向函数的enter&#x2F;exit</h2><p>通过GCC的-finstrument-functions选项，可以在function的enter&#x2F;exit位置执行hook代码，从而进行一些profile动作。</p><h2 id="Hack-79-取得程序计数器的值"><a href="#Hack-79-取得程序计数器的值" class="headerlink" title="[Hack 79] 取得程序计数器的值"></a>[Hack 79] 取得程序计数器的值</h2><p>通过调用函数时，PC被压栈的特性，获取当前的PC值。</p><h2 id="Hack-81-使用SIGSEGV来确认地址的有效性"><a href="#Hack-81-使用SIGSEGV来确认地址的有效性" class="headerlink" title="[Hack 81] 使用SIGSEGV来确认地址的有效性"></a>[Hack 81] 使用SIGSEGV来确认地址的有效性</h2><p>通过检测数据访问是否会触发SIGSEGV handler来确认当前地址的有效性。</p><h2 id="Hack-83-使用ltrace来跟踪共享库函数的调用"><a href="#Hack-83-使用ltrace来跟踪共享库函数的调用" class="headerlink" title="[Hack 83] 使用ltrace来跟踪共享库函数的调用"></a>[Hack 83] 使用ltrace来跟踪共享库函数的调用</h2><p>原理是改写了PLT表格，但是这种改写不能用于替换运行进程的动态库，因为可能有函数地址或者变量地址被使用在地址空间中。</p><h2 id="Hack-84-使用Jockey记录，再生Linux的程序运行"><a href="#Hack-84-使用Jockey记录，再生Linux的程序运行" class="headerlink" title="[Hack 84] 使用Jockey记录，再生Linux的程序运行"></a>[Hack 84] <a href="pdf/Jockey.pdf">使用Jockey记录，再生Linux的程序运行</a></h2><p>原理是记录了外部调用的结果，并对结果进行重放。论文还没有仔细看过，看原理有点打桩的意思。</p><h2 id="Hack-85-使用prelink加速程序启动"><a href="#Hack-85-使用prelink加速程序启动" class="headerlink" title="[Hack 85] 使用prelink加速程序启动"></a>[Hack 85] <a href="pdf/prelink.pdf">使用prelink加速程序启动</a></h2><p>程序的重定向在确定地址随机化的load_bias后，是可以提前进行的。</p><p><a href="https://elinux.org/Pre_Linking">prelink</a>的问题在于，需要在性能和安全之间取得一个平衡。</p><h2 id="Hack-86-livepatch的原理"><a href="#Hack-86-livepatch的原理" class="headerlink" title="[Hack 86] livepatch的原理"></a>[Hack 86] livepatch的原理</h2><p>livepatch，简单的定义就是，在程序运行时，通过加载新的代码，改变其运行状态。</p><p>大体上可以分为三步:</p><ol><li>在进程空间里映射内存，存放新的代码。</li><li>对新的代码进行符号解析，重定向工作。</li><li>确保安全的情况下，对原有的上下文进行修改。</li></ol><p>这种修改的原理是通过加入类似jmp instruction的代码，将原有的text引导至新的text。</p><h2 id="Hack-91-使用硬件调试的功能"><a href="#Hack-91-使用硬件调试的功能" class="headerlink" title="[Hack 91] 使用硬件调试的功能"></a>[Hack 91] 使用硬件调试的功能</h2><p>硬件提供的debugging能力，更多的需要去阅读官方的文档。</p><h2 id="Hack-93-Boehm-GC的使用"><a href="#Hack-93-Boehm-GC的使用" class="headerlink" title="[Hack 93] Boehm GC的使用"></a>[Hack 93] <a href="https://en.wikipedia.org/wiki/Boehm_garbage_collector">Boehm GC</a>的使用</h2><p>通过一套特制的接口，为C语言加入GC机制。</p><h2 id="Hack-94-存储器的访问顺序"><a href="#Hack-94-存储器的访问顺序" class="headerlink" title="[Hack 94] 存储器的访问顺序"></a>[Hack 94] 存储器的访问顺序</h2><p>这部分涉及访存的时序，以及编程语言的内存模型。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Binary </tag>
            
            <tag> ELF </tag>
            
            <tag> Hack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux修改进程使用资源限制办法</title>
      <link href="/lnux-modify-limit/"/>
      <url>/lnux-modify-limit/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>ebpf运行显示没有权限，查阅log后发现是因为lock memory大小的限制。因此，准备通过ulimit -l的方式来修改大小。使用普通用户时，显示没有权限。加入sudo运行后，则修改没有生效。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>需要明确的是，按照man page的说法:</p><blockquote><p>Resource  limits are per-process attributes that are shared by all of the threads in a process.</p></blockquote><p>也就是说，这个限制是进程为单位的，我个人理解，这个limit conf是进程拉起时，从session继承过来的。因此sudo无法生效的原因在于sudo会拉起一个新的shell，不会改变当前shell的配置。</p><p>遇到这种情况，有两种办法:</p><p>第一种办法，就是在程序内部，通过syscall自己修改自己的limit。</p><p>代码如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static int setup_env()</span><br><span class="line">&#123;</span><br><span class="line">    struct rlimit lck_mem = &#123;&#125;;</span><br><span class="line">    lck_mem.rlim_cur = RLIM_INFINITY;</span><br><span class="line">    lck_mem.rlim_max = RLIM_INFINITY;</span><br><span class="line">    if (setrlimit(RLIMIT_MEMLOCK, &amp;lck_mem) == -1)</span><br><span class="line">        return -errno;</span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种办法，就是直接修改整个系统的limit配置，修改&#x2F;etc&#x2F;security&#x2F;limits.conf即可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> ulimit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GCC编译器通过stack执行代码</title>
      <link href="/gcc-execute-stack/"/>
      <url>/gcc-execute-stack/</url>
      
        <content type="html"><![CDATA[<p>考虑以下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void other(void (*funcp)()) &#123;</span><br><span class="line">    funcp();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void outer(void) &#123;</span><br><span class="line">    int a = 0x0;</span><br><span class="line">    a += 0x22;</span><br><span class="line"></span><br><span class="line">    void inner(void) &#123;</span><br><span class="line">        a += 0x33;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    other(inner);</span><br><span class="line">    printf(&quot;a is 0x%x \n&quot;, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    outer();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的特别之处在于，inner函数定义在outer函数内部，且inner函数访问了outer函数的局部变量。</p><p>局部变量处于outer函数的栈上，而inner函数的调用时机并不确定，因此inner函数自身的栈与该局部变量的距离并不固定，需要通过某种办法将该局部变量的地址传递给inner函数。GCC解决这个问题的办法，就是在栈上生成了代码。</p><p>编译该代码，出现了以下warning</p><blockquote><p>&#x2F;usr&#x2F;bin&#x2F;ld: warning: &#x2F;tmp&#x2F;ccRfPclj.o: requires executable stack (because the .note.GNU-stack section is executable)</p></blockquote><p>关于该warning，详情见Referfence-1。</p><p>编译之后，通过反汇编查看outer函数和inner函数的实现，可以发现outer函数有很长的一段逻辑，是往栈中写入了特定的内容，相关实现截取如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">40115d:       48 8d 45 10             lea    0x10(%rbp),%rax</span><br><span class="line">401161:       48 89 45 f0             mov    %rax,-0x10(%rbp)</span><br><span class="line">401165:       48 8d 45 d0             lea    -0x30(%rbp),%rax</span><br><span class="line">401169:       48 83 c0 04             add    $0x4,%rax</span><br><span class="line">40116d:       48 8d 55 d0             lea    -0x30(%rbp),%rdx</span><br><span class="line">401171:       b9 40 11 40 00          mov    $0x401140,%ecx</span><br><span class="line">401176:       66 c7 00 41 bb          movw   $0xbb41,(%rax)</span><br><span class="line">40117b:       89 48 02                mov    %ecx,0x2(%rax)</span><br><span class="line">40117e:       66 c7 40 06 49 ba       movw   $0xba49,0x6(%rax)</span><br><span class="line">401184:       48 89 50 08             mov    %rdx,0x8(%rax)</span><br><span class="line">401188:       c7 40 10 49 ff e3 90    movl   $0x90e3ff49,0x10(%rax)</span><br><span class="line">40118f:       b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">401194:       89 45 d0                mov    %eax,-0x30(%rbp)</span><br><span class="line">401197:       8b 45 d0                mov    -0x30(%rbp),%eax</span><br><span class="line">40119a:       83 c0 22                add    $0x22,%eax</span><br><span class="line">40119d:       89 45 d0                mov    %eax,-0x30(%rbp)</span><br><span class="line">4011a0:       48 8d 45 d0             lea    -0x30(%rbp),%rax</span><br><span class="line">4011a4:       48 83 c0 04             add    $0x4,%rax</span><br><span class="line">4011a8:       48 89 c7                mov    %rax,%rdi</span><br><span class="line">4011ab:       e8 76 ff ff ff          call   401126 &lt;other&gt;</span><br></pre></td></tr></table></figure><p>这一段的实现比较晦涩，通过GDB追踪outer函数的执行，当执行到other函数时，并没有直接调用inner函数，而是跳入了栈上的某一个地址，对该地址进行反汇编，出现了以下代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x7fffffffe034:mov    $0x401140,%r11d</span><br><span class="line">0x7fffffffe03a:movabs $0x7fffffffe030,%r10</span><br><span class="line">0x7fffffffe044:rex.WB jmp *%r11</span><br></pre></td></tr></table></figure><p>这段栈上的代码做了两件事情，传递了inner函数以及局部变量的真实地址，接着跳入inner函数执行，outer函数那一堆操作栈的代码就是在栈上生成该代码。</p><p>而inner函数的实现特别之处如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">401144:       4c 89 d0                mov    %r10,%rax</span><br><span class="line">401147:       4c 89 55 f8             mov    %r10,-0x8(%rbp)</span><br><span class="line">40114b:       8b 10                   mov    (%rax),%edx</span><br><span class="line">40114d:       83 c2 33                add    $0x33,%edx</span><br><span class="line">401150:       89 10                   mov    %edx,(%rax)</span><br></pre></td></tr></table></figure><p>inner函数从r10寄存器读取了局部变量的值，并完成了修改，这种读取行为跟生成的栈上代码是强相关的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>GCC为了支持这种在函数中定义函数的用法，在栈上生成了代码，这种行为是极度不安全的。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li><a href="https://www.redhat.com/en/blog/linkers-warnings-about-executable-stacks-and-segments">Linker’s warnings</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> GNU </tag>
            
            <tag> GCC </tag>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>syscall的执行过程简析以及如何在内核模块中发起调用</title>
      <link href="/linux-syscall/"/>
      <url>/linux-syscall/</url>
      
        <content type="html"><![CDATA[<p>以下分析过程用的kernel版本为6.2，架构为X86，请注意不同内核版本以及不同架构之间的差异。</p><h2 id="syscall的执行过程"><a href="#syscall的执行过程" class="headerlink" title="syscall的执行过程"></a>syscall的执行过程</h2><p>syscall的执行过程大体上可以分为三步：</p><ol><li>用户态发起调用</li><li>glibc设置参数，发起中断进入内核态</li><li>内核态设置堆栈，进行处理</li></ol><p>前两步无需赘述，直接从内核中断处理开始分析。这一过程中，最重要的过程为堆栈的切换。</p><p>如果是X86的架构，堆栈的切换实现在.&#x2F;arch&#x2F;x86&#x2F;entry&#x2F;entry_64.S下，对应函数为entry_SYSCALL_64。</p><p>此处实现的要点为，用户态的寄存器上下文被存储到了栈中，而后，栈中的某一处地址被处理成struct pt_regs，作为调用参数，传给了syscall的处理函数，因此，以mprotect为例，可以看到如下实现:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(mprotect, unsigned long, start, size_t, len,</span><br><span class="line">unsigned long, prot)</span><br><span class="line">&#123;</span><br><span class="line">return do_mprotect_pkey(start, len, prot, -1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>展开的结果为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static long __se_sys_mprotect(__typeof(__builtin_choose_expr((__builtin_types_compatible_p(typeof((unsigned long)0), typeof(0LL)) || __builtin_types_compatible_p(typeof((unsigned long)0), typeof(0ULL))), 0LL, 0L)) start, __typeof(__builtin_choose_expr((__builtin_types_compatible_p(typeof((size_t)0), typeof(0LL)) || __builtin_types_compatible_p(typeof((size_t)0), typeof(0ULL))), 0LL, 0L)) len, __typeof(__builtin_choose_expr((__builtin_types_compatible_p(typeof((unsigned long)0), typeof(0LL)) || __builtin_types_compatible_p(typeof((unsigned long)0), typeof(0ULL))), 0LL, 0L)) prot);</span><br><span class="line">static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((no_instrument_function)) long __do_sys_mprotect(unsigned long start, size_t len, unsigned long prot);</span><br><span class="line">long __x64_sys_mprotect(const struct pt_regs *regs);</span><br><span class="line">;</span><br><span class="line">long __x64_sys_mprotect(const struct pt_regs *regs) &#123; return __se_sys_mprotect(regs-&gt;di, regs-&gt;si, regs-&gt;dx); &#125;</span><br><span class="line">long __ia32_sys_mprotect(const struct pt_regs *regs);</span><br><span class="line">;</span><br><span class="line">long __ia32_sys_mprotect(const struct pt_regs *regs) &#123; return __se_sys_mprotect((unsigned int)regs-&gt;bx, (unsigned int)regs-&gt;cx, (unsigned int)regs-&gt;dx); &#125;</span><br><span class="line">static long __se_sys_mprotect(__typeof(__builtin_choose_expr((__builtin_types_compatible_p(typeof((unsigned long)0), typeof(0LL)) || __builtin_types_compatible_p(typeof((unsigned long)0), typeof(0ULL))), 0LL, 0L)) start, __typeof(__builtin_choose_expr((__builtin_types_compatible_p(typeof((size_t)0), typeof(0LL)) || __builtin_types_compatible_p(typeof((size_t)0), typeof(0ULL))), 0LL, 0L)) len, __typeof(__builtin_choose_expr((__builtin_types_compatible_p(typeof((unsigned long)0), typeof(0LL)) || __builtin_types_compatible_p(typeof((unsigned long)0), typeof(0ULL))), 0LL, 0L)) prot)</span><br><span class="line">&#123;</span><br><span class="line">long ret = __do_sys_mprotect((unsigned long)start, (size_t)len, (unsigned long)prot);</span><br><span class="line">(void)((int)(sizeof(struct &#123; int : (-!!(!(__builtin_types_compatible_p(typeof((unsigned long)0), typeof(0LL)) || __builtin_types_compatible_p(typeof((unsigned long)0), typeof(0ULL))) &amp;&amp; sizeof(unsigned long) &gt; sizeof(long))); &#125;))), (void)((int)(sizeof(struct &#123; int : (-!!(!(__builtin_types_compatible_p(typeof((size_t)0), typeof(0LL)) || __builtin_types_compatible_p(typeof((size_t)0), typeof(0ULL))) &amp;&amp; sizeof(size_t) &gt; sizeof(long))); &#125;))), (void)((int)(sizeof(struct &#123; int : (-!!(!(__builtin_types_compatible_p(typeof((unsigned long)0), typeof(0LL)) || __builtin_types_compatible_p(typeof((unsigned long)0), typeof(0ULL))) &amp;&amp; sizeof(unsigned long) &gt; sizeof(long))); &#125;)));</span><br><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line">&#125; while (0);</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line">static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((no_instrument_function)) long __do_sys_mprotect(unsigned long start, size_t len, unsigned long prot)</span><br><span class="line">&#123;</span><br><span class="line">return do_mprotect_pkey(start, len, prot, -1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>展开后，主要实现为定义了若干函数，并且进行了调用封装。其中，需要注意的是long __x64_sys_mprotect(const struct pt_regs *regs)。<br>这个符号的地址就是最后填入sys_call_table的地址。</p><p>尽管这个符号被asmlinkage修饰了，但是实际传参仍然是通过寄存器进行的，这与大多数资料里对syscall的描述有出入。在x86-64的架构下，asmlinkage的定义是空。</p><p>上面的实现调用顺序为:__x64_sys_mprotect -&gt; __se_sys_mprotect -&gt; __do_sys_mprotect -&gt; do_mprotect_pkey</p><p>对vmlinux进行汇编，可以得到如下的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;__x64_sys_mprotect&gt;:</span><br><span class="line">f3 0f 1e fa             endbr64 </span><br><span class="line">48 8b 57 60             mov    0x60(%rdi),%rdx</span><br><span class="line">48 8b 77 68             mov    0x68(%rdi),%rsi</span><br><span class="line">b9 ff ff ff ff          mov    $0xffffffff,%ecx</span><br><span class="line">48 8b 7f 70             mov    0x70(%rdi),%rdi</span><br><span class="line">e8 a6 fb ff ff          call   ffffffff81218e80 &lt;do_mprotect_pkey&gt;</span><br><span class="line">48 98                   cltq   </span><br><span class="line">e9 a3 a3 c0 00          jmp    ffffffff81e23684 &lt;__x86_return_thunk&gt;</span><br><span class="line">66 66 2e 0f 1f 84 00    data16 cs nopw 0x0(%rax,%rax,1)</span><br><span class="line">00 00 00 00 </span><br><span class="line">0f 1f 40 00             nopl   0x0(%rax)</span><br></pre></td></tr></table></figure><p>此处rdi寄存器的内容就是唯一的参数struct pt_regs*，而这个参数本身存储了用户态的上下文，按照用户态的abi规则读取参数，再传递给对应的内核态函数。</p><p>偏移0x70是rdi寄存器再struct pt_regs中的偏移。</p><h3 id="如何在linux-kernel-module中调用syscall"><a href="#如何在linux-kernel-module中调用syscall" class="headerlink" title="如何在linux kernel module中调用syscall"></a>如何在linux kernel module中调用syscall</h3><p>按照上面所说，调用的办法如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static long (*orig_mprotect) (const struct pt_regs *regs);</span><br><span class="line"></span><br><span class="line">static long krun_mprotect(unsigned long start, size_t len, unsigned long prot)</span><br><span class="line">&#123;</span><br><span class="line">    do_mprotect_pkey((unsigned long)layout-&gt;base, layout-&gt;text_size, PROT_READ | PROT_EXEC, -1);</span><br><span class="line">    struct pt_regs regs;</span><br><span class="line">    setup_parameters(&amp;regs, start, len, prot);</span><br><span class="line">    return orig_mprotect(&amp;regs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过krun_mprotect就能从内核中发起syscall调用，至于如何读到sys_call_table，以及从sys_call_table中读到syscall handler的地址，就不再本文的讨论范畴了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Syscall </tag>
            
            <tag> Kernel Module </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BPF usage in malicious software</title>
      <link href="/ebpf-usage-in-malicious-soft/"/>
      <url>/ebpf-usage-in-malicious-soft/</url>
      
        <content type="html"><![CDATA[<p><a href="https://raw.githubusercontent.com/h3xduck/TripleCross/master/docs/ebpf_offensive_rootkit_tfg.pdf">An analysis of offensive capabilities of eBPF and implementation of a rootkit</a>的阅读笔记。</p><p>这篇paper主要讲述了如何利用eBPF模块进行系统入侵，记录了一些阅读过程中，我比较感兴趣的部分。</p><h2 id="eBPF当前具备的能力"><a href="#eBPF当前具备的能力" class="headerlink" title="eBPF当前具备的能力"></a>eBPF当前具备的能力</h2><p>通过bpf_probe_read_user&#x2F;bpf_probe_write_user可以实现对用户态内存的修改，但是这种修改与一般的内存读写相比，限制在于，这种修改过程中，是不能发生page fault的，猜测与eBPF执行的上下文限制有关。</p><p>在固定的hook点使用eBPF进行内存读写时，可以根据abi等规范，对栈或者内存进行解析。</p><p>在注入代码的末尾，可以再次进行注入，这一设计可以用来清理现场。</p><p>用户态调用syscall的过程: source code -&gt; GOT (lazy binding) -&gt; glibc library -&gt; syscall instruction<br>对于同一个syscall，可能存在多个glibc入口，因此LD_PRELOAD对于syscall的劫持效果要差于ptrace和eBPF</p><p>eBPF借助ringbuf可以在内核态和用户态之间进行通信</p><p>eBPF可以修改hook点的返回值，对sudo这类程序的行为研究，可以做到提权的效果。</p><h2 id="主流的编译器安全特性"><a href="#主流的编译器安全特性" class="headerlink" title="主流的编译器安全特性"></a>主流的编译器安全特性</h2><ul><li>Stack canaries -&gt; 注入代码执行前后，对上下文进行恢复</li><li>DEP&#x2F;NX(W&#x2F;X两种权限不会同时出现) -&gt; 寻找executable memory，通过&#x2F;proc&#x2F;xxx&#x2F;mem跳过write检查，找到可以使用的code caves &lt;- 由于page bound的对齐，代码可执行区域存在很多被zero填充的空洞</li><li>ASLR&#x2F;PIE -&gt; 计算出load_bias，将bias load到symbol table上，就可以使用了</li><li>RELRO</li></ul><h2 id="一些注入思路"><a href="#一些注入思路" class="headerlink" title="一些注入思路"></a>一些注入思路</h2><p>在一个地址空间里，拉起一个新的线程，该线程的执行还必须做到不影响原来线程的执行状态。</p><p>不同的shell注入思路:</p><ol><li>A reverse shell</li></ol><ul><li>victim connect to the attacker TCP</li><li>use TCP fd for stdin&#x2F;stdout&#x2F;stderr</li></ul><ol start="2"><li>Plaintext pseudo-shell</li></ol><ul><li>attacker is the master</li><li>在TCP payload的基础上在进行新的协议封装</li></ul><ol start="3"><li>Encrypted pseudo-shell (2 + TLS)</li><li>Phantom shell (利用了TCP的超时重发)</li></ol><p>shell code in APPENDIX C: 保存上下文后执行注入代码</p>]]></content>
      
      
      
        <tags>
            
            <tag> Ebpf </tag>
            
            <tag> Security </tag>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>X86_64 ELF abi阅读笔记</title>
      <link href="/x86-84-elf-abi/"/>
      <url>/x86-84-elf-abi/</url>
      
        <content type="html"><![CDATA[<p>参考的文档查看<a href="https://refspecs.linuxbase.org/elf/x86_64-abi-0.99.pdf">此处</a></p><h3 id="Code-Models"><a href="#Code-Models" class="headerlink" title="Code Models"></a>Code Models</h3><p>因为不同的寻址模式所要求的限制不一样，而不同的限制所要求的性能损耗不一样。因此，为了最大程度上优化性能，在不同的场景下会使用不同的模式。当前AMD64定义了以下几种code models:</p><ol><li>Small code model<br>Virtual address在链接阶段就已经确认下来，并且所有符号的地址从0到（$2^{31}$- $2^{24}$ - 1），即从0x00000000到0x7effffff。具体寻址范围，取决于使用偏移的方式。</li></ol><p>这是效率最高的寻址模式，适用于绝大多数情况。</p><ol start="2"><li><p>Kernel code model<br>Kernel通常很小，并且一般在地址空间的高半部分运行。因此，我们定义所有的符号地址范围为（$2^{64}$- $2^{31}$）- （$2^{64}$- $2^{24}$），即从0xffffffff80000000到0xffffffffff000000。<br>该模式拥有与smal model类似的优点，只是具体作用的偏移不一样。</p></li><li><p>Large code model<br>Large code model对于address和section size都不做限制，这个模式对性能的损耗很大，只有在其他模式无法满足情况下，才会采用。</p></li><li><p>Medium code model<br>在该模式下，data section会被分为两部分，分别使用small code model和large code model。程序的内存布局必须采用一种方式，使得large data sections（.ldata .lrodata .lbss）在text和data section之后出现。</p></li><li><p>Small position independent code model (PIC)<br>PIC的特性要求符号的virtual virtual到dynamic link time才能确定，允许的最大寻址offset为（$2^{31}$- $2^{24}$ - 1），即0x7effffff。</p></li><li><p>Large position independent code model (PIC)<br>参照3和5</p></li><li><p>Medium position independent code model (PIC)<br>参照3和4</p></li></ol><hr><p>使用large model的ELF file可能会对目标section设置SHF_X86_64_LARGE。</p><p>为了解决偏移过大时的数据存取和函数调用问题，出现了GOT和PLT机制。</p><h3 id="符号表和栈解析"><a href="#符号表和栈解析" class="headerlink" title="符号表和栈解析"></a>符号表和栈解析</h3><p>STT_GNU_IFUNC： ifunc相关的符号类型</p><p>.eh_frame section记录了用于unwinding stack的信息。<br>.eh_frame可能由多个section组成，大致可以分为CIE(Common Information Entry)和FDEs(Frame Descriptor Entry)</p><p>与栈解析有关的section flag： SHT_X86_64_UNWIND<br>与栈解析有关的segment flag:  PT_GNU_EH_FRAME &#x2F; PT_SUNW_EH_FRAME &#x2F; PT_SUNW_UNWIND</p><p>在汇编语言层面，提供一些指令用于支持栈解析和debug information:<br>.cfi_startproc<br>.cfi_endproc<br>.cfi_def_cfa REGISTER, OFFSET<br>.cfi_def_cfa_register REGISTER<br>.cfi_def_cfa_offset OFFSET<br>.cfi_adjust_cfa_offset OFFSET<br>.cfi_offset REGISTER, OFFSET<br>.cfi_rel_offset REGISTER, OFFSET<br>.cfi_escape EXPRESSION[, …]</p><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>_GLOBAL_OFFSET_TABLE_有可能位于.got section的中间部分，从而同时允许对于偏移数组的正向和负向寻址。</p><p>一般来说，GOT机制用于处理数据(地址)访问，PLT机制用于处理函数跳转。</p><p>动态链接器处理GOT和PLT表格的过程：</p><ol><li>当第一次创建程序的内存空间时，动态链接器会将GOT表格的第二项和第三项设置为特别的值。</li><li>在内存空间里的每个shared object文件都有自己的PLT表格，控制权只会从同一个object文件中跳转到PLT表格。</li><li>为了方便举例，假设程序调用了name1，将控制权转给了label .PLT1。</li><li>程序开始从.PLT1开始执行(jmp xxx)，第一次时.PLT1从GOT表格读取的地址是下一条pushq指令，而不是真正的name1地址，因此程序直接跳转到下一条指令。</li><li>现在程序把一个relocation index压入栈中，这个relocation index是一个32-bit，非负的index。这个index与relocation table里的一个entry关联，这个关联的entry类型为R_X86_64_JUMP_SLOT，这个entry的offset就是之前jmp xxx里的xxx所在的地址，这个entry关联的符号就是name1。</li><li>压入relocation index之后，程序就会跳转到.PLT0，也就是PLT表格的第一项，这里的pushq指令会把GOT+8的value放入栈中，从而给动态链接器一种标记信息。接着，程序会跳转到GOT+16，将控制权交给动态链接器。</li><li>当动态链接器获取控制权之后，它会解开栈，根据栈里的信息，将name1的地址放到GOT里正确的位置。</li><li>接下来的程序执行到.PLT1时，会直接跳转到目标函数执行。</li></ol><p>环境变量LD_BIND_NOW可以立即开始这一绑定过程(处理类型为R_X86_64_JUMP_SLOT的重定向)，带来的代价就是启动时间的增加。</p><p>在small和medium model里，当PLT和GOT同时引用同一个function symbol时，一般情况下，linker会在PLT里创建一个GOTPLT slot，在GOT里创建一个GOT slot。一个runtime JUMP_SLOT重定向会被创建，用来更新对应的GOTPLT slot。一个runtime GLOB_DAT重定向会被创建去更新GOT slot。在runtime时，JUMP_SLOT和GLOB_DAT重定向都会使用同样的symbol value去更新GOTPLT和GOT slot。<br>作为一个优化，linker可能会把GOTPLT slot和GOT slot合并成一个GOT slot，并且移除JUMP_SLOT重定向。这种优化会把以下常规的PLT entry:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.PLT: jmp [GOTPLT slot]</span><br><span class="line">pushq relocation index</span><br><span class="line">jmp .PLT0</span><br></pre></td></tr></table></figure><p>借助GOT slot通过间接跳转替换成一个GOT PLT enrty：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.PLT: jmp [GOT slot]</span><br><span class="line">nop</span><br></pre></td></tr></table></figure><p>然后，把PLT的引用解析到GOT PLT entry。间接跳转指令是5个字节，剩余的部分用nop指令填充。在这种优化中，指针比较是必须要避免的。否则，有可能会导致binary在运行时进入死循环。</p>]]></content>
      
      
      
        <tags>
            
            <tag> ELF </tag>
            
            <tag> X86_64 </tag>
            
            <tag> ABI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中断上下文调用filp_open</title>
      <link href="/filp_open-interrupt/"/>
      <url>/filp_open-interrupt/</url>
      
        <content type="html"><![CDATA[<p>问题的背景是在一段驱动代码中，调用了filp_open。<br>发现在某些场景下返回了-EACCES。</p><p>尝试过以下办法，均未奏效：</p><ol><li>修改文件的所有者，并且设置mod为777</li><li>关闭selinux</li></ol><p>通过GDB单点跟踪，最后发现filp_open会调用may_lookup，6.1版本的内核源码如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static inline int may_lookup(struct user_namespace *mnt_userns,</span><br><span class="line">     struct nameidata *nd)</span><br><span class="line">&#123;</span><br><span class="line">if (nd-&gt;flags &amp; LOOKUP_RCU) &#123;</span><br><span class="line">int err = inode_permission(mnt_userns, nd-&gt;inode, MAY_EXEC|MAY_NOT_BLOCK);</span><br><span class="line">if (err != -ECHILD || !try_to_unlazy(nd))</span><br><span class="line">return err;</span><br><span class="line">&#125;</span><br><span class="line">return inode_permission(mnt_userns, nd-&gt;inode, MAY_EXEC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这一步里，会去检查filp_open是否会阻塞当前调用(MAY_NOT_BLOCK)，如果是单线程，则返回-ECHILD，可以确认不会阻塞；如果是多线程，则返回-EACCES。</p><p>而我使用该接口的场景是soft interrupt，众所周知，interrupt上下文是不能调用block api的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Interrupt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用gdb调试qemu运行中的内核代码</title>
      <link href="/gdb-qemu/"/>
      <url>/gdb-qemu/</url>
      
        <content type="html"><![CDATA[<p>当前文章仅讨论gdb调试qemu中运行的linux内核，需要以下步骤：</p><ol><li>确认目标内核开启了相关编译选项</li><li>qemu加入gdb相关的启动参数</li><li>关闭内核的内核地址随机化</li><li>获取目标内核的debuginfo</li></ol><h2 id="确认目标内核开启了相关编译选项"><a href="#确认目标内核开启了相关编译选项" class="headerlink" title="确认目标内核开启了相关编译选项"></a>确认目标内核开启了相关编译选项</h2><p>这步没什么好说的，大部分发行版的内核都是支持的。</p><h2 id="qemu加入gdb相关的启动参数"><a href="#qemu加入gdb相关的启动参数" class="headerlink" title="qemu加入gdb相关的启动参数"></a>qemu加入gdb相关的启动参数</h2><p>通过virsh命令编辑qemu的xml文件，加入以下启动参数:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;domain type=&#x27;kvm&#x27;</span><br><span class="line">       xmlns:qemu=&#x27;http://libvirt.org/schemas/domain/qemu/1.0&#x27; &gt;</span><br><span class="line">     &lt;qemu:commandline&gt;</span><br><span class="line">          &lt;qemu:arg value=&#x27;-s&#x27;/&gt;</span><br><span class="line">     &lt;/qemu:commandline&gt;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;qemu:commandline&gt;</span><br><span class="line">      &lt;qemu:arg value=&#x27;-gdb&#x27;/&gt;</span><br><span class="line">      &lt;qemu:arg value=&#x27;tcp::1235&#x27;/&gt;</span><br><span class="line">&lt;/qemu:commandline&gt;</span><br></pre></td></tr></table></figure><p>实际操作中发现，virt-manager修改无法生效，需要先dumpxml，再destroy，修改完之后再create.</p><h2 id="关闭内核的内核地址随机化"><a href="#关闭内核的内核地址随机化" class="headerlink" title="关闭内核的内核地址随机化"></a>关闭内核的内核地址随机化</h2><p>通过修改内核的引导参数，加入”nokaslr”，启动后通过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cmdline</span><br></pre></td></tr></table></figure><p>确认下是否顺利加入</p><h2 id="获取当前内核的debuginfo"><a href="#获取当前内核的debuginfo" class="headerlink" title="获取当前内核的debuginfo"></a>获取当前内核的debuginfo</h2><p>如果是自己编译的内核，直接拷贝相关的编译目录，使用其中的vmlinux即可。</p><p>如果是发行版的内核，使用以下命令获取debuginfo</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yumdownloader --debuginfo kernel</span><br></pre></td></tr></table></figure><p>解开rpm包之后，设置下gdb，开始使用即可。</p><h2 id="过程中，如果需要切换内核，考虑以下办法"><a href="#过程中，如果需要切换内核，考虑以下办法" class="headerlink" title="过程中，如果需要切换内核，考虑以下办法"></a>过程中，如果需要切换内核，考虑以下办法</h2><ul><li>修改grub引导</li><li>kexec</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.redhat.com/en/blog/debugging-kernel-qemulibvirt">Debugging a kernel in QEMU&#x2F;libvirt</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Qemu </tag>
            
            <tag> GDB </tag>
            
            <tag> Virsh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dnf包管理系统中debug包的使用</title>
      <link href="/dnf-rpm-debug/"/>
      <url>/dnf-rpm-debug/</url>
      
        <content type="html"><![CDATA[<p>对于某个包，dnf除了发布用于日常运行的rpm之外，还提供了以下三种用于维测场景的包：</p><ol><li>source rpm</li><li>debugsource rpm</li><li>debuginfo rpm</li></ol><p>以redis为例，以下四条命令用于下载不同类型的包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yumdownloader redis</span><br><span class="line">yumdownloader --source redis</span><br><span class="line">yumdownloader --debugsource redis</span><br><span class="line">yumdownloader --debuginfo redis</span><br></pre></td></tr></table></figure><p>获取到四个rpm包，分别为:</p><ol><li>redis-6.2.7-1.fc35.x86_64.rpm</li><li>redis-6.2.7-1.fc35.src.rpm</li><li>redis-debugsource-6.2.7-1.fc35.x86_64.rpm</li><li>redis-debuginfo-6.2.7-1.fc35.x86_64.rpm</li></ol><p>通过rpm -qlp &lt;xxx.rpm&gt;可以查看对应rpm包里的内容</p><h2 id="redis-6-2-7-1-fc35-x86-64-rpm"><a href="#redis-6-2-7-1-fc35-x86-64-rpm" class="headerlink" title="redis-6.2.7-1.fc35.x86_64.rpm"></a>redis-6.2.7-1.fc35.x86_64.rpm</h2><p>主要包括的文件为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/redis-benchmark</span><br><span class="line">/usr/bin/redis-check-aof</span><br><span class="line">/usr/bin/redis-check-rdb</span><br><span class="line">/usr/bin/redis-cli</span><br><span class="line">/usr/bin/redis-sentinel</span><br><span class="line">/usr/bin/redis-server</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="redis-6-2-7-1-fc35-src-rpm"><a href="#redis-6-2-7-1-fc35-src-rpm" class="headerlink" title="redis-6.2.7-1.fc35.src.rpm"></a>redis-6.2.7-1.fc35.src.rpm</h2><p>包括的文件为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">macros.redis</span><br><span class="line">redis-6.2.7.tar.gz</span><br><span class="line">redis-doc-3fdb6df.tar.gz</span><br><span class="line">redis-limit-systemd</span><br><span class="line">redis-sentinel.service</span><br><span class="line">redis-shutdown</span><br><span class="line">redis.logrotate</span><br><span class="line">redis.service</span><br><span class="line">redis.spec</span><br></pre></td></tr></table></figure><p>source rpm用于指导生成binary rpm，一个source rpm可以生成多个binary rpm。source rpm的作用，就是将上游发布的源码，通过rpm的方式进行管理和发布。</p><p>source rpm通常包括:</p><ol><li>上游发布的源码，一般是某种类型的压缩包</li><li>补丁文件，适应性的一些修改</li><li>配置文件</li><li>spec文件，用于指导构建过程</li></ol><h2 id="redis-debugsource-6-2-7-1-fc35-x86-64-rpm"><a href="#redis-debugsource-6-2-7-1-fc35-x86-64-rpm" class="headerlink" title="redis-debugsource-6.2.7-1.fc35.x86_64.rpm"></a>redis-debugsource-6.2.7-1.fc35.x86_64.rpm</h2><p>debugsource包含了对应binary包的源码</p><h2 id="redis-debuginfo-6-2-7-1-fc35-x86-64-rpm"><a href="#redis-debuginfo-6-2-7-1-fc35-x86-64-rpm" class="headerlink" title="redis-debuginfo-6.2.7-1.fc35.x86_64.rpm"></a>redis-debuginfo-6.2.7-1.fc35.x86_64.rpm</h2><p>主要包括的文件为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/usr/lib/debug/.build-id/e1/1ff8dbe598e32dd7fbe1fb6bd57f5ad84bebc5.debug</span><br><span class="line">/usr/lib/debug/.dwz</span><br><span class="line">/usr/lib/debug/.dwz/redis-6.2.7-1.fc35.x86_64</span><br><span class="line">/usr/lib/debug/usr</span><br><span class="line">/usr/lib/debug/usr/bin</span><br><span class="line">/usr/lib/debug/usr/bin/redis-benchmark-6.2.7-1.fc35.x86_64.debug</span><br><span class="line">/usr/lib/debug/usr/bin/redis-cli-6.2.7-1.fc35.x86_64.debug</span><br><span class="line">/usr/lib/debug/usr/bin/redis-server-6.2.7-1.fc35.x86_64.debug</span><br></pre></td></tr></table></figure><p>debugsource包提供了dwarf格式的debug information。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li><a href="https://blog.packagecloud.io/working-with-source-rpms/">source rpm</a></li><li><a href="https://fedoramagazine.org/how-rpm-packages-are-made-the-source-rpm/">source rpm</a></li><li><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/developing_c_and_cpp_applications_in_rhel_8/debugging-applications_developing-applications">debug rpm</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> dnf </tag>
            
            <tag> debug </tag>
            
            <tag> yumdownloader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DWARF and exception handling</title>
      <link href="/dwarf-debug-format-information/"/>
      <url>/dwarf-debug-format-information/</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>DWARF(debugging with attributed record formats)是一种常用的source-level调试信息。</p><p>DWARF通过树形结构来组织调试信息，树形结构的每个节点可以表示types, variables, functions.</p><p>DWARF使用一系列的DIEs(debugging information entries)来定义source program的底层表示。每一个DIE由一个标识(tag)和一系列的属性(attributes)组成。一个DIE或者一群DIE共同描述了source program中对应实体(entity)。标识(tag)指明了每个entry所属的class，以及对应entry所具有的特定属性。</p><h2 id="DWARF-sections"><a href="#DWARF-sections" class="headerlink" title="DWARF sections"></a>DWARF sections</h2><p>常见的DWARF section以及对应的含义：<br>.debug_abbrev-&gt;Abbreviations used in the .debug_info section<br>.debug_aranges-&gt;Lookup table for mapping addresses to compilation units<br>.debug_frame-&gt;Call frame information<br>.debug_info-&gt;Core DWARF information section<br>.debug_line-&gt;Line number information<br>.debug_loc-&gt;Location lists used in the DW_AT_location attributes<br>.debug_macinfo-&gt;Macro information<br>.debug_pubnames-&gt;Lookup table for global objects and functions<br>.debug_pubtypes-&gt;Lookup table for global types<br>.debug_ranges-&gt;Address ranges used in the DW_AT_ranges attributes<br>.debug_str-&gt;String table used in .debug_info<br>.debug_types-&gt;Type descriptions</p><p>.debug_abbrev section包含多个描述所有遵循DWARF格式的compilation unit的abbreviation tables。</p><p>每一个描述compilation unit的abbreviation table包含一系列的abbreviation declarations。每一个declaration指明了一个DIE的tag和attributes。这些信息用于指导.debug_info section的解释。每一个compilation unit都与一个特定的abbreviation table关联，多个compilation units可以共享一个abbreviation table。</p><h2 id="DWARF-tools"><a href="#DWARF-tools" class="headerlink" title="DWARF tools"></a>DWARF tools</h2><ul><li>readelf</li><li>dwarfdump</li><li>libdwarf</li></ul><h2 id="C-C-相关的tag和attributes"><a href="#C-C-相关的tag和attributes" class="headerlink" title="C&#x2F;C++相关的tag和attributes"></a>C&#x2F;C++相关的tag和attributes</h2><p>DW_TAG_class_type-&gt;Represents the class name and type information<br>DW_TAG_structure_type-&gt;Represents the structure name and type information<br>DW_TAG_union_type-&gt;Represents the union name and type information<br>DW_TAG_enumeration_type-&gt;Represents the enum name and type information<br>DW_TAG_typedef-&gt;Represents the typedef name and type information<br>DW_TAG_array_type-&gt;Represents the array name and type information<br>DW_TAG_subrange_type-&gt;Represents the array size information<br>DW_TAG_inheritance-&gt;Represents the inherited class name and type information<br>DW_TAG_member-&gt;Represents the members of class<br>DW_TAG_subprogram-&gt;Represents the function name information<br>DW_TAG_formal_parameter-&gt;Represents the function arguments’ information<br>DW_AT_name-&gt;Represents the name string<br>DW_AT_type-&gt;Represents the type information<br>DW_AT_artificial-&gt;Is set when it is created by compiler<br>DW_AT_sibling-&gt;Represents the sibling location information<br>DW_AT_data_member_location-&gt;Represents the location information<br>DW_AT_virtuality-&gt;Is set when it is virtual</p><h2 id="eh-frame-section"><a href="#eh-frame-section" class="headerlink" title=".eh_frame section"></a>.eh_frame section</h2><p>.eh_frame section的格式基本与.debug_frame一样，存在一些细微的差别。</p><p>.eh_frame section包含至少一条CFI(Call Frame Information)记录，而CFI &#x3D; 1 CIE(Common Information Entry) + at least 1 FDE(Frame Description Entry)。</p><p>就观察来说，对于一个源码文件编译出来的object文件，有一个CIE，记录了一些全局的信息，包括version，augmentation string等等。FDE则对应每一个函数。</p><p>在做热补丁的时候，linker报了一个如下的错误:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">no .eh_frame_hdr table will be created</span><br></pre></td></tr></table></figure><p>尽管报了这个错误，linker还是正常链接生成了目标文件。</p><p>.eh_frame_hdr简单的说，就是用于.eh_frame检索的概括信息，这些信息最终的用途是实现ELF的Exception Handling机制。(待填坑)</p><p>通过阅读binutils-gdb的源码，发现报错来自以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ENSURE_NO_RELOCS(buf);</span><br><span class="line">if ((sec-&gt;flags &amp; SEC_LINKER_CREATED) == 0 || cookie-&gt;rels != NULL)</span><br><span class="line">&#123;</span><br><span class="line">  asection *rsec;</span><br><span class="line"></span><br><span class="line">  REQUIRE(GET_RELOC(buf));</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段源码出错的逻辑，是没找到FDE对应的重定向条目。也就是说，每个FDE必须有对应的重定向条目。</p><p>通过阅读源码，发现每个FDE对应的重定向地址都是offset + 0x8. 这个地址对应的DWARF属性是 - PC Begin。</p><p>出错的原因到这里就很清楚了，做补丁的时候，我去除了没用到的symbol和relocation entry, 导致linker在处理.eh_frame时，校验失败。</p><p>解决的办法也很简单，去除relocation entry之后，把对应的FDE也去除掉。</p><p>代码实现看<a href="https://gitee.com/openeuler/syscare/pulls/138">这里</a>。</p><p>在生成新的.eh_frame时候，注意要同时更新PC Begin和eh_hdr_id，对应的relocation entry的offset也要更新。</p><p>FDE的eh_hdr_id对应的值就是其本身的偏移，CIE的eh_hdr_id是0.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><p><a href="https://developer.ibm.com/articles/au-dwarf-debug-format/">dwarf-debug-format</a></p></li><li><p><a href="https://refspecs.linuxbase.org/LSB_4.0.0/LSB-Core-generic/LSB-Core-generic/ehframechpt.html">LSB - Exception Frames</a></p></li><li><p><a href="https://refspecs.linuxfoundation.org/LSB_1.3.0/gLSB/gLSB/ehframehdr.html">LSB - ehframe_hdr</a></p></li><li><p><a href="https://github.com/mclinker/mclinker/blob/master/include/mcld/LD/EhFrameHdr.h">github - mclinker</a></p></li><li><p><a href="https://maskray.me/blog/2021-08-29-all-about-global-offset-table">GOT</a></p></li><li><p><a href="https://martin.uy/blog/understanding-the-gcc_except_table-section-in-elf-binaries-gcc/">.gcc_except_table</a> </p></li><li><p><a href="https://www.airs.com/blog/archives/166">airs - .gcc_execept_table</a></p></li><li><p><a href="https://www.airs.com/blog/archives/460">airs - .gcc_execept_table</a></p></li><li><p><a href="https://www.airs.com/blog/archives/462">airs - .gcc_execept_table</a></p></li><li><p><a href="https://www.airs.com/blog/archives/464">airs - .gcc_execept_table</a></p></li><li><p><a href="https://blog.csdn.net/wuhui_gdnt/article/details/88737310">C++异常的幕后6</a></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> ELF </tag>
            
            <tag> DWARF </tag>
            
            <tag> Debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-代码及命令小抄</title>
      <link href="/linux-code-snippt/"/>
      <url>/linux-code-snippt/</url>
      
        <content type="html"><![CDATA[<h4 id="GCC从标准输入中读取源码并且编译"><a href="#GCC从标准输入中读取源码并且编译" class="headerlink" title="GCC从标准输入中读取源码并且编译"></a>GCC从标准输入中读取源码并且编译</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;void main()&#123;&#125;&quot; | gcc -v -x c -</span><br></pre></td></tr></table></figure><p>这种用法可以参考criu中的try-cc，用途是用来检测系统以及GCC的一些参数支持。</p><p>通过这种办法生成的object，在其debug信息中，会显示如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;12&gt;   DW_AT_name        : (indirect line string, offset: 0x1b): &lt;stdin&gt;</span><br></pre></td></tr></table></figure><p>表示gcc编译的源码来自标准输入。</p><h4 id="kernel-module-filename-–-unlink对应的文件"><a href="#kernel-module-filename-–-unlink对应的文件" class="headerlink" title="[kernel-module]filename –&gt; unlink对应的文件"></a>[kernel-module]filename –&gt; unlink对应的文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static int unlink_filename(const char *filename)</span><br><span class="line">&#123;</span><br><span class="line">    struct file *filp;</span><br><span class="line">    struct inode *parent_inode;</span><br><span class="line">    struct user_namespace *user_ns;</span><br><span class="line">    int ret;</span><br><span class="line"></span><br><span class="line">    filp = filp_open(filename, O_RDONLY, 0);</span><br><span class="line">    if (IS_ERR(filp))</span><br><span class="line">        return PTR_ERR(filp);</span><br><span class="line">    </span><br><span class="line">    user_ns = mnt_user_ns(filp-&gt;f_path.mnt);</span><br><span class="line">    </span><br><span class="line">    parent_inode = filp-&gt;f_path.dentry-&gt;d_parent-&gt;d_inode;</span><br><span class="line">    inode_lock(parent_inode);</span><br><span class="line">    ret = vfs_unlink(user_ns, parent_inode, filp-&gt;f_path.dentry, NULL);    </span><br><span class="line">    inode_unlock(parent_inode);</span><br><span class="line"></span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="kernel-module-oldname-newname-–-创建soft-link"><a href="#kernel-module-oldname-newname-–-创建soft-link" class="headerlink" title="[kernel-module]oldname + newname –&gt; 创建soft link"></a>[kernel-module]oldname + newname –&gt; 创建soft link</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/* check init_symlink for more info */</span><br><span class="line">static int create_symlink(const char *oldname, const char *newname)</span><br><span class="line">&#123;</span><br><span class="line">struct dentry *dentry;</span><br><span class="line">struct path path;</span><br><span class="line">int error;</span><br><span class="line"></span><br><span class="line">    /* we do not care about its return value */</span><br><span class="line">    unlink_filename(newname);</span><br><span class="line"></span><br><span class="line">    dentry = kern_path_create(AT_FDCWD, newname, &amp;path, 0);</span><br><span class="line">if (IS_ERR(dentry))</span><br><span class="line">return PTR_ERR(dentry);</span><br><span class="line"></span><br><span class="line">error = vfs_symlink(mnt_user_ns(path.mnt), path.dentry-&gt;d_inode,</span><br><span class="line">dentry, oldname);</span><br><span class="line">done_path_create(&amp;path, dentry);</span><br><span class="line">return error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Code Snippt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Virtiofs进行内核开发</title>
      <link href="/virtiofs-qemu/"/>
      <url>/virtiofs-qemu/</url>
      
        <content type="html"><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>通过qemu运行linux时，只有两个东西是必须的，分别是编译出来的kernel和rootfs。</p><p>kernel直接从源码中，编译生成，编译命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j 8 &amp;&amp; make -j 8 modules &amp;&amp; make -j 8 modules_install &amp;&amp; make -j 8 install</span><br></pre></td></tr></table></figure><p>通过包管理器可以直接生成一个可用的rootfs，以fedora&#x2F;dnf为例，以下命令可以生成一个rootfs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf --installroot=$PWD/virtio-fs-root --releasever=36 install system-release vim-minimal systemd passwd dnf rootfiles</span><br></pre></td></tr></table></figure><p>其中，–releasever指明了fedora的版本，–installroot指明了安装目录，可以看需要，添加自己需要的软件到安装列表中。<br>rootfs生成后之后，通过chroot和passwd修改登录密码。</p><p>virtiofs的优点在于，在qemu拉起guest之后，host和guest可以同时修改一个目录，避免了频繁拉起。</p><p>virtiofs的运行要求：</p><ol><li>编译出来的guest kernel必须支持virtiofs</li><li>qemu必须支持virtiofs(&gt;&#x3D;6.2.0)</li><li>virtiofs守护程序(virtiofsd)</li></ol><p>对于第1个要求，kernel编译的时候，打开virtiofs相关的config即可。</p><p>对于第2个要求，尝试更新qemu的系统版本，如果无法成功，直接用以下命令编译一个新的qemu</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://gitlab.com/virtio-fs/qemu.git</span><br><span class="line">../configure --prefix=$PWD --target-list=x86_64-softmmu</span><br><span class="line">make -j 8</span><br><span class="line">make -j 8 virtiofsd</span><br></pre></td></tr></table></figure><p>对于第3个要求，当前只能从源码编译生成<a href="https://gitlab.com/virtio-fs/virtiofsd">virtiofsd</a>。<br>或者直接下载官网编译好的release版本，见<a href="https://gitlab.com/virtio-fs/virtiofsd/-/releases">此处</a></p><h2 id="运行virtiofs"><a href="#运行virtiofs" class="headerlink" title="运行virtiofs"></a>运行virtiofs</h2><ol><li><p>运行virtiofsd</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtiofsd --socket-path=/tmp/anatasluo -o source=fedora-fs -o cache=none</span><br></pre></td></tr></table></figure><p>其中，fedora-fs是通过virtiofs要挂载给guest的目录</p></li><li><p>添加kernel启动参数，修改qemu启动参数，完整参数如下:</p><blockquote><p>qemu-system-x86_64 -s -M pc -cpu host –enable-kvm -smp 2 -kernel .&#x2F;kernel&#x2F;bzImage -m 4G -object memory-backend-file,id&#x3D;mem,size&#x3D;4G,mem-path&#x3D;&#x2F;dev&#x2F;shm,share&#x3D;on -numa node,memdev&#x3D;mem -append “panic&#x3D;1 HOST&#x3D;x86_64 console&#x3D;ttyS0 rootfstype&#x3D;virtiofs root&#x3D;myfs rw” -chardev socket,id&#x3D;char0,path&#x3D;&#x2F;tmp&#x2F;anatasluo -device vhost-user-fs-pci,queue-size&#x3D;1024,chardev&#x3D;char0,tag&#x3D;myfs -chardev stdio,mux&#x3D;on,id&#x3D;mon -mon chardev&#x3D;mon,mode&#x3D;readline -device virtio-serial-pci -device virtconsole,chardev&#x3D;mon -vga none -display none</p></blockquote></li></ol><p>注意，修改相关的目录到自己的路径下。</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ol><li>virtiofsd提示”Error creating sandbox: No such file or directory (os error 2)”</li></ol><p>检查下virtiofsd的source文件夹是否存在</p><ol start="2"><li>进入rootfs后，一直提示”Login incorrect”</li></ol><p>检查下rootfs目录的权限，尝试用sudo运行，如何可以。退出后，通过chown修改rootfs目录权限，再次运行时可以不使用sudo。</p><ol start="3"><li>进入guest后，mount操作时，提示”unknown filesystem type ‘virtiofs’”</li></ol><p>在guest里，运行以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/filesystems</span><br></pre></td></tr></table></figure><p>查看支持的文件系统中是否有”virtiofs”，没有的话需要修改.config，重新编译内核。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li><a href="https://virtio-fs.gitlab.io/howto-qemu.html">virtio-fs - Standalone virtiofs usage</a></li><li><a href="https://virtio-fs.gitlab.io/howto-boot.html">virtio-fs - How to boot from virtiofs</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> dnf </tag>
            
            <tag> Fedora </tag>
            
            <tag> Rootfs </tag>
            
            <tag> Virtiosfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux From Scratch实验过程记录</title>
      <link href="/linux-from-scratch/"/>
      <url>/linux-from-scratch/</url>
      
        <content type="html"><![CDATA[<p>Linux From Scratch(LFS)的项目主页，点击<a href="https://www.linuxfromscratch.org/">此处</a></p><p>对于一个成熟的发行版来说，通过包管理器，比如dnf，apt等，是可以生成一个可运行的系统镜像的(ISO)。LFS做的事情，就是把这个过程手动做了一遍，教程十分详细，本文记录一些操作过程中遇到的一些问题，以及LFS后续的一些使用。</p><h2 id="常见问题和命令"><a href="#常见问题和命令" class="headerlink" title="常见问题和命令"></a>常见问题和命令</h2><ol><li><p>尽量使用web版本的教程，pdf上有些命令的显示存在残缺和格式问题。</p></li><li><p>编译过程中，提示”&#x2F;dev&#x2F;null:1:8: error: unknown type name ‘GNU’”</p></li></ol><p>这个问题，是由于chroot过程中，没有挂载虚拟内核文件系统。</p><p>进入LFS文件系统的完整过程如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mkdir -pv $LFS/&#123;dev,proc,sys,run&#125;</span><br><span class="line"></span><br><span class="line">mount -v --bind /dev/pts $LFS/dev/pts</span><br><span class="line">mount -vt proc proc $LFS/proc</span><br><span class="line">mount -vt sysfs sysfs $LFS/sys</span><br><span class="line">mount -vt tmpfs tmpfs $LFS/run</span><br><span class="line"></span><br><span class="line">if [ -h $LFS/dev/shm ]; then</span><br><span class="line">  mkdir -pv $LFS/$(readlink $LFS/dev/shm)</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">/usr/sbin/chroot &quot;$LFS&quot; /usr/bin/env -i   \</span><br><span class="line">    HOME=/root                  \</span><br><span class="line">    TERM=&quot;$TERM&quot;                \</span><br><span class="line">    PS1=&#x27;(lfs chroot) \u:\w\$ &#x27; \</span><br><span class="line">    PATH=/usr/bin:/usr/sbin \</span><br><span class="line">    /bin/bash --login</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>离开LFS环境后的清理过程如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br><span class="line"></span><br><span class="line">umount $LFS/dev/pts</span><br><span class="line">umount $LFS/&#123;sys,proc,run,dev&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>备份和还原LFS环境的命令<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd $LFS</span><br><span class="line">tar -cJpf $HOME/lfs-temp-tools-11.2.tar.xz .</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd $LFS</span><br><span class="line">rm -rf ./*</span><br><span class="line">tar -xpf $HOME/lfs-temp-tools-11.2.tar.xz</span><br></pre></td></tr></table></figure><ol start="4"><li>编译Man-DB中遇到”‘html_pager’ undeclared”</li></ol><p>看了下源码，发现编译过程中，需要加入一个宏TROFF_IS_GROFF，推测跟GROFF的编译过程有关，手动设置下，这个问题就解决了。</p><p>后续还出现一个变量未定义的问题，也跟这个宏有关，直接删掉这个用于if的变量后。编译和运行就都没问题了，代码的含义没有深究，建议如果是生产用途，仔细研究下代码。</p><ol start="5"><li>LFS环境占用的空间过大</li></ol><p>把source目录下编译完成的源码删除。<br>去除调试信息。</p><p>经过以上两步，可以把LFS环境压缩到几百M。</p><h2 id="将LFS环境用于qemu运行"><a href="#将LFS环境用于qemu运行" class="headerlink" title="将LFS环境用于qemu运行"></a>将LFS环境用于qemu运行</h2><ol><li>通过ramfs运行qemu</li></ol><p>qemu运行命令如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64  -s -nographic -no-reboot -m 4G -kernel ./kernel/bzImage -initrd ./rootfs/rootfs.cpio.gz -append &quot;nokaslr panic=1 HOST=x86_64 console=ttyS0&quot;</span><br></pre></td></tr></table></figure><p>将LFS环境生成cpio的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ./fs</span><br><span class="line">find . | cpio -o -H newc | gzip &gt; ../rootfs.cpio.gz</span><br></pre></td></tr></table></figure><p>将cpio解压成LFS环境的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd fs</span><br><span class="line">gzip -dc ../rootfs.cpio.gz &gt; rootfs.cpio</span><br><span class="line">cpio -idmv &lt; ./rootfs.cpio</span><br></pre></td></tr></table></figure><p>这里需要注意内存的大小设置，如果小于rootfs的话，会提示”qemu: initrd is too large, cannot support”。如果大小超过rootfs，但是小于解压后的rootfs话，会在引导过程中提示”Initramfs unpacking failed: write error”。</p><ol start="2"><li>通过硬盘运行qemu</li></ol><p>qemu运行命令如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64  -s -nographic -no-reboot -m 4G -kernel ./kernel/bzImage -hda ./rootfs/rootfs.img -append &quot;panic=1 HOST=x86_64 console=ttyS0 root=/dev/sda rw&quot;</span><br></pre></td></tr></table></figure><p>将LFS环境生成img的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dd if=/dev/zero of=rootfs.img bs=1M count=4096</span><br><span class="line">mkfs.ext4 rootfs.img</span><br><span class="line">mkdir fs</span><br><span class="line">sudo mount -t ext4 -o loop rootfs.img ./fs</span><br></pre></td></tr></table></figure><p>对应的解除挂载命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo umount fs</span><br></pre></td></tr></table></figure><h2 id="值得探索的几个点"><a href="#值得探索的几个点" class="headerlink" title="值得探索的几个点"></a>值得探索的几个点</h2><ol><li><p>编译器如何在Build, Host, Target之间，生成最终的交叉编译器。</p></li><li><p>如何解决libc和libgcc的相互依赖问题。</p></li><li><p>init程序</p></li><li><p>包管理器</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Qemu </tag>
            
            <tag> LFS </tag>
            
            <tag> Rootfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解相对重定向</title>
      <link href="/elf-relocate/"/>
      <url>/elf-relocate/</url>
      
        <content type="html"><![CDATA[<p>考察以下代码<em>reloc.c</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">extern int ext_func(void);</span><br><span class="line"></span><br><span class="line">extern int ext_var;</span><br><span class="line">int *ext_var_p = &amp;ext_var;</span><br><span class="line">static int *ext_var_sp = &amp;ext_var;</span><br><span class="line"></span><br><span class="line">static int sta_var = 0x05;</span><br><span class="line">int *stat_var_p = &amp;sta_var;</span><br><span class="line">static int *stat_var_sp = &amp;sta_var;</span><br><span class="line"></span><br><span class="line">static int sta_func(void)</span><br><span class="line">&#123;</span><br><span class="line">    ext_var += 0x08;</span><br><span class="line">    *ext_var_p += 0x10;</span><br><span class="line">    *ext_var_sp += 0x20;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int glo_add_func(int* a)</span><br><span class="line">&#123;</span><br><span class="line">    a += 0x50;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int glo_func(void)</span><br><span class="line">&#123;</span><br><span class="line">    sta_var += 0x30;</span><br><span class="line">    *stat_var_p += 0x40;</span><br><span class="line">    glo_add_func(stat_var_sp);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ext_func();</span><br><span class="line">    sta_func();</span><br><span class="line">    glo_func();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以下命令进行编译</p><blockquote><p>gcc -c reloc.c</p></blockquote><p>这个代码涉及到大量的重定向条目，我们一个个的来讨论。</p><p>先讨论glo_func是如何调用glo_add_func，通过objdump查看相关汇编，为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">000000000000005b &lt;glo_func&gt;:</span><br><span class="line">  5b:   55                      push   %rbp</span><br><span class="line">  5c:   48 89 e5                mov    %rsp,%rbp</span><br><span class="line">  5f:   8b 05 00 00 00 00       mov    0x0(%rip),%eax        # 65 &lt;glo_func+0xa&gt;</span><br><span class="line">  65:   83 c0 30                add    $0x30,%eax</span><br><span class="line">  68:   89 05 00 00 00 00       mov    %eax,0x0(%rip)        # 6e &lt;glo_func+0x13&gt;</span><br><span class="line">  6e:   48 8b 05 00 00 00 00    mov    0x0(%rip),%rax        # 75 &lt;glo_func+0x1a&gt;</span><br><span class="line">  75:   8b 10                   mov    (%rax),%edx</span><br><span class="line">  77:   48 8b 05 00 00 00 00    mov    0x0(%rip),%rax        # 7e &lt;glo_func+0x23&gt;</span><br><span class="line">  7e:   83 c2 40                add    $0x40,%edx</span><br><span class="line">  81:   89 10                   mov    %edx,(%rax)</span><br><span class="line">  83:   48 8b 05 00 00 00 00    mov    0x0(%rip),%rax        # 8a &lt;glo_func+0x2f&gt;</span><br><span class="line">  8a:   48 89 c7                mov    %rax,%rdi</span><br><span class="line">  8d:   e8 00 00 00 00          callq  92 &lt;glo_func+0x37&gt;</span><br><span class="line">  92:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  97:   5d                      pop    %rbp</span><br><span class="line">  98:   c3                      retq   </span><br></pre></td></tr></table></figure><p>通过readelf查看相关的重定向规则，为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00000000008e  000f00000004 R_X86_64_PLT32    0000000000000044 glo_add_func - 4</span><br></pre></td></tr></table></figure><p>不考虑重定向，仅考虑callq指令本身，根据AMD spec的描述，callq的作用为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Call near, relative, displacement relative to next instruction.</span><br></pre></td></tr></table></figure><p>callq指令会以重定向位置的下一条指令为基准，进行跳转。</p><p>Q: <em>为什么是下一条指令，而不是当前的指令？</em></p><p>A: 因为流水线(pipeline)的存在，为了提高指令的执行效率，当前指令在执行时，EIP是指向下一条指令。</p><p>现在，引入以下变量值：</p><p>addr1: 跳转的目标函数的地址，即上面的glo_add_func</p><p>addr2: callq指令所在的地址，即上面的glo_func+0x8d</p><p>addr3: callq指令的下一条指令所在的地址，即上面的glo_func+0x92</p><p>offset: callq指令之后应该填入的跳转偏移</p><p>假设callq能以当前指令的地址为基准，那么应该存在关系offset &#x3D; addr1 - addr2<br>但是实际由于流水线的存在，callq以下一条指令为基础，实际关系为offset &#x3D; addr1 - add3</p><p>现在，引入以下变量和概念</p><p>instruction_len: 重定向所在指令的长度，上文的例子中为callq本身的1bytes和offset的4bytes，为5bytes</p><p>op_len: 重定向区域到指令开始的长度，上文的例子中为callq本身的指令长度，为1bytes</p><p>relocation_len: 重定向区域到指令结束的长度，上文的例子为offset的长度，为4bytes</p><p>实际上是以重定向区域为界，将所在的指令一分为二，容易得出instruction_len &#x3D; op_len + relocation_len。</p><p>而addr3 &#x3D; addr2 + instruction_len，所以offset的计算变成offset &#x3D; addr1 - add3 &#x3D; addr1 - addr2 - instruction_len</p><p>进而推导出offset &#x3D; addr1 - addr2 - instruction_len &#x3D; addr1 - addr2 - op_len - relocation_len &#x3D; addr1 - relocation_len - (addr2 + op_len)</p><p>现在，我们再考虑重定向是如何规定的，根据type &#x3D; R_X86_64_PLT32，重定向规则为L + A - P。</p><p>这里讲一个小知识点，编译器在编译阶段，不能确定当前编译结果是否是共享对象，因此对全局的函数引用都处理成R_X86_64_PLT32类型。<br>在后续的链接阶段，会根据函数符号是否处于共享对象进行不同的处理：</p><ol><li>函数符号位于共享对象</li></ol><p>按照R_X86_64_PLT32进行处理，需要设置PLT表格等等，具体过程本文不涉及。</p><ol start="2"><li>函数符号不处于共享对象</li></ol><p>按照R_X86_64_PC32进行处理，R_X86_64_PC32的计算规则为S + A - P。即L + A - p -&gt; S + A - P</p><p>本文的例子中，符号均不处于共享对象，因此实际的重定向规则为S + A - P，其中对S, A, P的定义为：</p><blockquote><p>S: Represents the value of the symbol whose index resides in the relocation entry</p></blockquote><blockquote><p>P: Represents the place (section offset or address) of the storage unit being relocated (computed using r_offset).</p></blockquote><blockquote><p>A: Represents the addend used to compute the value of the relocatable field.</p></blockquote><p>对应到上文的例子，S就是glo_add_func的地址，即addr1。P是重定向指令所在地址，即addr2 + op_len。(实际计算中，是通过section addr + r_offset)。<br>最终的重定向计算过程为：offset &#x3D; addr1 + A - (addr2 + op_len)<br>对比我们前文的公式：offset &#x3D; addr1 - relocation_len - (addr2 + op_len)</p><p>可以得出一个结论： A &#x3D; -relocation_len</p><p>这里的重定向是以glo_add_func的变量地址为基准，进行计算的。还存在一种情况，是以section的地址为基准，进行计算。</p><p>继续考察上文的代码，通过readelf查看代码涉及到的重定向条目，发现以下条目：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Relocation section &#x27;.rela.text&#x27; at offset 0x410 contains 14 entries:</span><br><span class="line">  Offset          Info           Type           Sym. Value    Sym. Name + Addend</span><br><span class="line">000000000006  000d00000002 R_X86_64_PC32     0000000000000000 ext_var - 4</span><br><span class="line">00000000000f  000d00000002 R_X86_64_PC32     0000000000000000 ext_var - 4</span><br><span class="line">000000000016  000c00000002 R_X86_64_PC32     0000000000000000 ext_var_p - 4</span><br><span class="line">00000000001f  000c00000002 R_X86_64_PC32     0000000000000000 ext_var_p - 4</span><br><span class="line">00000000002b  000300000002 R_X86_64_PC32     0000000000000000 .data + 4</span><br><span class="line">000000000034  000300000002 R_X86_64_PC32     0000000000000000 .data + 4</span><br><span class="line">000000000061  000300000002 R_X86_64_PC32     0000000000000000 .data + c</span><br><span class="line">00000000006a  000300000002 R_X86_64_PC32     0000000000000000 .data + c</span><br></pre></td></tr></table></figure><p>在对text段的重定向过程中，存在直接以data段为基址的条目，以重定向偏移为00000000002b的条目进行以下讨论。</p><p>通过与汇编源码比较，可以知道，该重定向涉及的汇编为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1c:   48 8b 05 00 00 00 00    mov    0x0(%rip),%rax        # 23 &lt;sta_func+0x23&gt;</span><br><span class="line">23:   83 c2 10                add    $0x10,%edx</span><br><span class="line">26:   89 10                   mov    %edx,(%rax)</span><br><span class="line">28:   48 8b 05 00 00 00 00    mov    0x0(%rip),%rax        # 2f &lt;sta_func+0x2f&gt;</span><br><span class="line">2f:   8b 10                   mov    (%rax),%edx</span><br><span class="line">31:   48 8b 05 00 00 00 00    mov    0x0(%rip),%rax        # 38 &lt;sta_func+0x38&gt;</span><br><span class="line">38:   83 c2 20                add    $0x20,%edx</span><br></pre></td></tr></table></figure><p>涉及的源码为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*ext_var_sp += 0x20;</span><br></pre></td></tr></table></figure><p>从0x28开始汇编，所做的事情为</p><p>0x28 -&gt; 获取ext_var_sp的地址</p><p>0x2f -&gt; 读取ext_var_sp指向的地址</p><p>0x31 -&gt; 此处无关</p><p>0x39 -&gt; 将指向地址的值加上0x20</p><p>可以看出，此处重定向，要获取的是ext_var_sp的地址，观察汇编</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">28:   48 8b 05 00 00 00 00    mov    0x0(%rip),%rax        # 2f &lt;sta_func+0x2f&gt;</span><br></pre></td></tr></table></figure><p>这里，是以RIP为基址，根据一个offset，读取ext_var_sp的地址。因此，重定向最终的输出，应该为offset &#x3D; ext_var_sp - RIP</p><p>借用上文的变量和概念：</p><p>addr1: 跳转的目标变量的地址，对于static变量，通常表示为section + symbol offset。通过readelf查看符号表，发现为.data + 0x8</p><p>addr2: 取址指令所在的地址，即上面的sta_func+0x28</p><p>addr3: 取址指令的下一条指令所在的地址，即上面的sta_func+0x31</p><p>offset: 取址指令之后应该填入的跳转偏移</p><p>instruction_len: 见上文</p><p>op_len: 见上文</p><p>relocation_len: 见上文</p><p>因此，此时的offset &#x3D; ext_var_sp - RIP &#x3D; addr1 - addr3 &#x3D; addr1 - addr2 - instruction_len<br>充分展开后，结果为<br>offset &#x3D; section_addr + symbol_offset - relocation_len - (addr2 + op_len)</p><p>此时对应的S为section_addr， P仍然为addr2 + op_len。<br>由于S的变化，A变成了symbol_offset - relocation_len</p><p>S的变化，是因为此处以section为基址，而不是以具体的变量为base，Addend必须加上对应的symbol_offset。</p><p>以section为基址的重定向通常为static变量，这种变量外部不可见，编译时的offset是固定的，不会在链接阶段改变。</p><p>以section为基址的重定向可以在符号表中去除相关的static变量，减少最终生成的文件大小。</p><p>总结：</p><ol><li>流水线的设计，使得IP寄存器总是指向下一条指令，计算offset时，需要考虑当前指令的长度</li><li>相对偏移如果确定，则以section为基址进行重定向，可以减少符号表大小， Addend &#x3D; symbol_offset - relocation_len</li><li>相对偏移如果不确定，则以symbol为基址进行重定向，Addend &#x3D; - relocation_len</li></ol><p>思考题：</p><ol><li>X86的指令是不定长的，而ARM指令是定长的，ARM下是如何处理相对重定向的？</li><li>其他类型的重定向规则的作用？</li><li>PLT和GOT表格的具体作用过程，以及其实如何解决共享库面对的问题？</li></ol><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol><li><a href="https://www.felixcloutier.com/x86/call">call instruction描述</a></li><li><a href="https://zhuanlan.zhihu.com/p/105936114">知乎专栏 - 静态链接与动态链接的宏观概述及微观详解</a></li><li><a href="https://blog.cloudflare.com/how-to-execute-an-object-file-part-1/">blog - How to execute an object file</a></li><li><a href="https://www.amd.com/system/files/TechDocs/24592.pdf">AMD SPEC</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> ELF </tag>
            
            <tag> Relocation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell执行命令时参数传递过程</title>
      <link href="/shell-parameters/"/>
      <url>/shell-parameters/</url>
      
        <content type="html"><![CDATA[<p>考虑以下代码 <em>main.c</em> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[], char *envp[])</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    argc += 0x88;</span><br><span class="line">    printf(&quot;I am running here 0x%lx \n&quot;, argv);</span><br><span class="line">    for (i = 0; i &lt; argc; i ++) &#123;</span><br><span class="line">        printf(&quot;arg [%d]: %s \n&quot;, i, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    for (char **env = envp; *env != 0; env++) &#123;</span><br><span class="line">        printf(&quot;env: %s \n&quot;, *env);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译之后，运行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -o main</span><br><span class="line">VAR=VALUE ./main arg1 arg2</span><br></pre></td></tr></table></figure><p>结果输出为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/ # VAR=VALUE ./main arg1 arg2</span><br><span class="line">I am running here 0x7ffda5290e68 </span><br><span class="line">arg [0]: ./main </span><br><span class="line">arg [1]: arg1 </span><br><span class="line">arg [2]: arg2 </span><br><span class="line">env: SHLVL=2 </span><br><span class="line">env: HOME=/ </span><br><span class="line">env: VAR=VALUE </span><br><span class="line">env: TERM=linux </span><br><span class="line">env: HOST=x86_64 </span><br><span class="line">env: PWD=/</span><br></pre></td></tr></table></figure><h2 id="问题：包括环境变量在内的参数是如何最终传递到main函数里的？"><a href="#问题：包括环境变量在内的参数是如何最终传递到main函数里的？" class="headerlink" title="问题：包括环境变量在内的参数是如何最终传递到main函数里的？"></a>问题：包括环境变量在内的参数是如何最终传递到main函数里的？</h2><p>大体上，参数传递分为三部分：</p><ol><li>shell传递给内核的sys_execve系统调用</li><li>sys_execve系统调用放入新进程的栈中</li><li>ELF的入口函数逐步传递到main函数中</li></ol><p>本文的测试环境为：Linux longcc 5.17.7-200.fc35.x86_64 #1 SMP PREEMPT Thu May 12 14:56:48 UTC 2022 x86_64 x86_64 x86_64 GNU&#x2F;Linux</p><h3 id="shell传递给内核的sys-execve系统调用"><a href="#shell传递给内核的sys-execve系统调用" class="headerlink" title="shell传递给内核的sys_execve系统调用"></a>shell传递给内核的sys_execve系统调用</h3><p>以<a href="https://github.com/bminor/bash">bash代码</a>为例，这部分的调用过程为<br>-&gt; main<br>    -&gt; reader_loop<br>        -&gt; execute_command<br>            -&gt; …<br>                -&gt; execve</p><p>execve的原型为: int execve(const char *pathname, char *const argv[], char *const envp[]);</p><p>shell构造参数的过程，这里就不记录了。</p><h3 id="sys-execve系统调用放入新进程的栈中"><a href="#sys-execve系统调用放入新进程的栈中" class="headerlink" title="sys_execve系统调用放入新进程的栈中"></a>sys_execve系统调用放入新进程的栈中</h3><p>这部分比较复杂，与Linux的ELF加载过程有关，本文的例子调用过程为：<br>do_execve -&gt; do_execveat_common -&gt; bprm_execve -&gt; exec_binprm -&gt; search_binary_handler</p><p>当进入内核态的系统调用时，调用参数和环境变量的指针存储在内核页中，但对应的内容存储在用户态页中。</p><p>接着，通过copy_strings，所有的参数和环境变量被复制到bprm结构中，此时，所有的内容都存储在内核页中。</p><p>在后面的调用过程中，begin_new_exec将确保仅有一条线程，同时通过exec_mmap对内存地址空间进行替换，旧有的映射关系将被全部丢弃。</p><p>search_binary_handler需要按照文件格式，查找对应的加载函数，接下来的过程为：<br>load_elf_binary -&gt; start_thread</p><p>start_thread会进入ELF设置entry point执行， start_point的函数原型为: start_thread(struct pt_regs *regs, unsigned long new_ip, unsigned long new_sp)</p><p>进程的栈构造过程看load_elf_binary实现就比较清晰，大致结构如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">------------------------------------------------------------- 0x7fff6c845000</span><br><span class="line"> 0x7fff6c844ff8: 0x0000000000000000</span><br><span class="line">        _  4fec: &#x27;./stackdump\0&#x27;                      &lt;------+</span><br><span class="line">  env  /   4fe2: &#x27;ENVVAR2=2\0&#x27;                               |    &lt;----+</span><br><span class="line">       \_  4fd8: &#x27;ENVVAR1=1\0&#x27;                               |   &lt;---+ |</span><br><span class="line">       /   4fd4: &#x27;two\0&#x27;                                     |       | |     &lt;----+</span><br><span class="line"> args |    4fd0: &#x27;one\0&#x27;                                     |       | |    &lt;---+ |</span><br><span class="line">       \_  4fcb: &#x27;zero\0&#x27;                                    |       | |   &lt;--+ | |</span><br><span class="line">           3020: random gap padded to 16B boundary           |       | |      | | |</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -|       | |      | | |</span><br><span class="line">           3019: &#x27;x86_64\0&#x27;                        &lt;-+       |       | |      | | |</span><br><span class="line"> auxv      3009: random data: ed99b6...2adcc7        | &lt;-+   |       | |      | | |</span><br><span class="line"> data      3000: zero padding to align stack         |   |   |       | |      | | |</span><br><span class="line">. . . . . . . . . . . . . . . . . . . . . . . . . . .|. .|. .|       | |      | | |</span><br><span class="line">           2ff0: AT_NULL(0)=0                        |   |   |       | |      | | |</span><br><span class="line">           2fe0: AT_PLATFORM(15)=0x7fff6c843019    --+   |   |       | |      | | |</span><br><span class="line">           2fd0: AT_EXECFN(31)=0x7fff6c844fec      ------|---+       | |      | | |</span><br><span class="line">           2fc0: AT_RANDOM(25)=0x7fff6c843009      ------+           | |      | | |</span><br><span class="line">  ELF      2fb0: AT_SECURE(23)=0                                     | |      | | |</span><br><span class="line">auxiliary  2fa0: AT_EGID(14)=1000                                    | |      | | |</span><br><span class="line"> vector:   2f90: AT_GID(13)=1000                                     | |      | | |</span><br><span class="line">(id,val)   2f80: AT_EUID(12)=1000                                    | |      | | |</span><br><span class="line">  pairs    2f70: AT_UID(11)=1000                                     | |      | | |</span><br><span class="line">           2f60: AT_ENTRY(9)=0x4010c0                                | |      | | |</span><br><span class="line">           2f50: AT_FLAGS(8)=0                                       | |      | | |</span><br><span class="line">           2f40: AT_BASE(7)=0x7ff6c1122000                           | |      | | |</span><br><span class="line">           2f30: AT_PHNUM(5)=9                                       | |      | | |</span><br><span class="line">           2f20: AT_PHENT(4)=56                                      | |      | | |</span><br><span class="line">           2f10: AT_PHDR(3)=0x400040                                 | |      | | |</span><br><span class="line">           2f00: AT_CLKTCK(17)=100                                   | |      | | |</span><br><span class="line">           2ef0: AT_PAGESZ(6)=4096                                   | |      | | |</span><br><span class="line">           2ee0: AT_HWCAP(16)=0xbfebfbff                             | |      | | |</span><br><span class="line">           2ed0: AT_SYSINFO_EHDR(33)=0x7fff6c86b000                  | |      | | |</span><br><span class="line">. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .        | |      | | |</span><br><span class="line">           2ec8: environ[2]=(nil)                                    | |      | | |</span><br><span class="line">           2ec0: environ[1]=0x7fff6c844fe2         ------------------|-+      | | |</span><br><span class="line">           2eb8: environ[0]=0x7fff6c844fd8         ------------------+        | | |</span><br><span class="line">           2eb0: argv[3]=(nil)                                                | | |</span><br><span class="line">           2ea8: argv[2]=0x7fff6c844fd4            ---------------------------|-|-+</span><br><span class="line">           2ea0: argv[1]=0x7fff6c844fd0            ---------------------------|-+</span><br><span class="line">           2e98: argv[0]=0x7fff6c844fcb            ---------------------------+</span><br><span class="line"> 0x7fff6c842e90: argc=3</span><br></pre></td></tr></table></figure><p>事实上，当新进程从entry point开始执行时，此时的栈称为Initial process Stack。Initial process Stack的内存分布在<a href="https://refspecs.linuxbase.org/elf/x86_64-abi-0.99.pdf">此处</a>进行了规定。</p><h3 id="ELF的入口函数逐步传递到main函数中"><a href="#ELF的入口函数逐步传递到main函数中" class="headerlink" title="ELF的入口函数逐步传递到main函数中"></a>ELF的入口函数逐步传递到main函数中</h3><p>这部分转递过程都是通过寄存器完成的，看汇编就很清晰了。<br>如果ELF是动态链接的，大致过程为entry point of ld-linux -&gt; _start(entry point of libc) -&gt; __libc_start_main -&gt; main<br>如果是静态链接的，则没有第一步interpreter的处理。</p><p>其中_start的参数，参考内核的start_thread</p><p>__libc_start_main的函数原型为: LIBC_START_MAIN (int (*main) (int, char **, char ** MAIN_AUXVEC_DECL), int argc, char **argv)</p><p>有意思的一个地方，main可以有不同的参数个数，生成的汇编也是不一样的。</p><h2 id="拓展结论"><a href="#拓展结论" class="headerlink" title="拓展结论"></a>拓展结论</h2><p>如果通过某种手段劫持ELF的entry point，修改参数(env + arg)需要以下过程:</p><ol><li>重新设置stack结构，保留原内容的同时，塞入新参数</li><li>修改进程的寄存器，确保entry point函数读取到的是新的SP</li><li>修改mm_struct里的一堆参数，包括arg_start等等</li></ol><p>大体上，就是重新实现了一遍create_aout_tables，这个思路与内核的实现高度耦合。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><p><a href="https://www.cnblogs.com/likaiming/p/11193697.html">linux内核exec过程 </a></p></li><li><p><a href="https://lwn.net/Articles/630727/">ELF binaries</a></p></li><li><p><a href="https://lwn.net/Articles/631631/">ELF binaries</a></p></li><li><p><a href="https://refspecs.linuxbase.org/elf/x86_64-abi-0.99.pdf">System V ABI</a></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Bash </tag>
            
            <tag> Execve </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>openEuler 21.09 下运行kpatch</title>
      <link href="/openeuler-kpatch/"/>
      <url>/openeuler-kpatch/</url>
      
        <content type="html"><![CDATA[<h2 id="测试环境及说明"><a href="#测试环境及说明" class="headerlink" title="测试环境及说明"></a>测试环境及说明</h2><p>openEuler 21.09 (x86_64)<br>kpatch (version v0.9.6)</p><p>需要说明的是，社区版本的kpatch对openEuler仅仅做了十分有限的支持，来自这个<a href="https://github.com/dynup/kpatch/commit/eaaced1912c43103749366927daff5794ea4f404">提交</a>。</p><p>openEuler实现了两种打补丁策略，CONFIG_LIVEPATCH_PER_TASK_CONSISTENCY&#x3D;y时，openEuler支持社区的per-task策略；CONFIG_LIVEPATCH_STOP_MACHINE_CONSISTENCY&#x3D;y时，openEuler使用stop machine策略。</p><p>关于这两种策略的提交记录，参考<a href="https://mailweb.openeuler.org/hyperkitty/list/kernel@openeuler.org/message/MANDE5M5NQ3WRQSSW7WCIECNF67WPP75/">这里</a>。</p><p>这两种策略是互斥的，不同opeEuler kernel版本默认启用的策略不一样。</p><p>我在自己的分支上，实现了kpatch对openEuler 21.09的支持，相关PR在<a href="https://github.com/dynup/kpatch/pull/1263">这里</a>。</p><p>测试的补丁文件为0001-kpatch-test.patch</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">From cff0bb0b98b156b2fd27f45af292e3f9649cac23 Mon Sep 17 00:00:00 2001</span><br><span class="line">From: anatasluo &lt;anatasluo@localhost.localdomain&gt;</span><br><span class="line">Date: Sun, 24 Apr 2022 10:30:49 +0800</span><br><span class="line">Subject: [PATCH] kpatch test</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"> fs/proc/version.c | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"></span><br><span class="line">diff --git a/fs/proc/version.c b/fs/proc/version.c</span><br><span class="line">index b449f18..ad10ef7 100644</span><br><span class="line">--- a/fs/proc/version.c</span><br><span class="line">+++ b/fs/proc/version.c</span><br><span class="line">@@ -8,6 +8,7 @@</span><br><span class="line"> </span><br><span class="line"> static int version_proc_show(struct seq_file *m, void *v)</span><br><span class="line"> &#123;</span><br><span class="line">+seq_printf(m, &quot;It is version secret %d&quot;, 88);</span><br><span class="line"> seq_printf(m, linux_proc_banner,</span><br><span class="line"> utsname()-&gt;sysname,</span><br><span class="line"> utsname()-&gt;release,</span><br><span class="line">-- </span><br><span class="line">2.30.0</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="测试准备工作"><a href="#测试准备工作" class="headerlink" title="测试准备工作"></a>测试准备工作</h2><ol><li>准备openEuler 21.09的运行环境</li></ol><p>镜像可以从<a href="https://repo.openeuler.org/openEuler-21.09/ISO/x86_64/">此处</a>获得</p><ol start="2"><li>查看&#x2F;boot目录下的对应config文件是否使能了CONFIG_LIVEPATCH_PER_TASK_CONSISTENCY</li></ol><p>如果没有使能，通过以下命令获取源码，重新编译。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">yumdownloader --source kernel-5.10.0-5.10.0.24.oe1.x86_64</span><br><span class="line"></span><br><span class="line">rpm -D &#x27;_topdir /home/anatasluo/buildroot&#x27; -ivh ./kernel-5.10.0-5.10.0.24.oe1.src.rpm</span><br><span class="line"></span><br><span class="line">rpmbuild -D &#x27;_topdir /home/anatasluo/buildroot&#x27; -bp --nodeps --target=x86_64 /home/anatasluo/buildroot/SPECS/kernel.spec</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中，5.10.0-5.10.0.24.oe1.x86_64是kernel的版本号，&#x2F;home&#x2F;anatasluo&#x2F;buildroot是任意工作目录，请替换成自己环境参数。</p><p>执行结束后，&#x2F;home&#x2F;anatasluo&#x2F;buildroot&#x2F;BUILD&#x2F;kernel-*目录下会出现kernel的源码，如果有多个目录，多个目录内容一样，选择一个使用即可。</p><p>将&#x2F;boot目录下的config拷贝到源码目录里，make menuconfig修改livepatch相关配置，保证CONFIG_LIVEPATCH_PER_TASK_CONSISTENCY&#x3D;y。</p><p>执行内核编译命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make LOCALVERSION=-5.10.0.24.oe1.x86_64 -j28</span><br><span class="line">make modules_install</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>5.10.0.24.oe1.x86_64与当前环境的内核版本有关，请替换成当前环境里的参数。</p><ol start="3"><li>将以下内容添加到&#x2F;etc&#x2F;yum.repos.d&#x2F;openEuler.repo末尾<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[source-update]</span><br><span class="line">name=source-update</span><br><span class="line">baseurl=https://repo.openeuler.org/openEuler-21.09/update/source/</span><br><span class="line">enable=1</span><br><span class="line">gpgcheck=0</span><br></pre></td></tr></table></figure></li></ol><h2 id="测试过程"><a href="#测试过程" class="headerlink" title="测试过程"></a>测试过程</h2><ol><li><p>下载源码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/anatasluo/kpatch</span><br><span class="line">cd kpatch</span><br></pre></td></tr></table></figure></li><li><p>安装相关依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source ./test/integration/lib.sh</span><br><span class="line">kpatch_dependencies</span><br></pre></td></tr></table></figure></li><li><p>编译kpatch</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure></li><li><p>生成补丁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./kpatch-build/kpatch-build 0001-kpatch-test.patch</span><br></pre></td></tr></table></figure></li></ol><p>0001-kpatch-test.patch内容在前文。</p><p>执行结束后，当前目录会出现livepatch-0001-kpatch-test.ko。</p><ol start="5"><li>测试补丁效果</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo insmod livepatch-0001-kpatch-test.ko</span><br><span class="line">cat /proc/version</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> openEuler </tag>
            
            <tag> Kpatch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>criu代码注入原理解析</title>
      <link href="/criu-inject/"/>
      <url>/criu-inject/</url>
      
        <content type="html"><![CDATA[<p>criu中实现了一个代码注入工具 -&gt; <a href="https://github.com/checkpoint-restore/criu/tree/criu-dev/compel">compel</a></p><p>这篇blog将对compel工具的实现原理，进行一个梳理。</p><h3 id="代码注入"><a href="#代码注入" class="headerlink" title="代码注入"></a>代码注入</h3><p>wiki对code injection的介绍如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Code injection is the exploitation of a computer bug that is caused by processing invalid data. The injection is used by an attacker to introduce (or &quot;inject&quot;) code into a vulnerable computer program and change the course of execution.</span><br></pre></td></tr></table></figure><p>简单的来说，代码注入，就是在某个进程上下文中执行一段代码。</p><h3 id="实现要点"><a href="#实现要点" class="headerlink" title="实现要点"></a>实现要点</h3><p>仅讨论广泛的实现，代码注入通常分为以下过程：</p><ol><li>编写注入代码，生成relocate file</li><li>将该relocate file映射到进程上下文中</li><li>对注入的代码进行relocation处理(这一步不是必须的，取决于注入代码的复杂程度)</li><li>修改执行上下文的寄存器值，让进程跳转到区域执行</li></ol><p>compel实现，在以上步骤的基础上，还加入了一个限制：<strong>注入程序用于获取上下文信息，其执行不能影响原有上下文，注入代码执行结束后，原有上下文可以继续执行。</strong></p><p>下面，我将按个讨论以上步骤的具体实现。</p><h4 id="生成用于注入的relocate-file"><a href="#生成用于注入的relocate-file" class="headerlink" title="生成用于注入的relocate file"></a>生成用于注入的relocate file</h4><p>实际上，注入代码并不一定是relocate file。只要求是可执行的汇编代码即可。这里我用relocate file来讨论，是因为注入代码可能很复杂，这种情况下，全部手写汇编是不现实的，因此势必要让编译器来生成最终的注入代码。这种情况下，不可避免的就会出现重定向过程。</p><p>由于我们是在运行时，加载该注入代码，因此重定向过程，需要我们自行编写代码完成。</p><p><strong>为了简化实现</strong>，该relocate file生成过程存在以下的限制：</p><ol><li>不能链接任何外部库，包括libc</li><li>内存模型需要高度定制 –&gt; 需要自己编写链接脚本</li></ol><h5 id="compel的编译过程和linker-script"><a href="#compel的编译过程和linker-script" class="headerlink" title="compel的编译过程和linker script"></a>compel的编译过程和linker script</h5><p>相关的编译参数包括：</p><ul><li>ffreestanding -&gt; 告诉编译器，该程序不使用任何标准库</li><li>fno-stack-protector –&gt; 不需要在栈中插入额外空间，方便我们简化设计</li><li>nostdlib –&gt; 不链接标准库</li><li>fpie –&gt; 生成位置无关的二进制代码</li><li>-r -z noexecstack –&gt; linker参数</li></ul><p>链接脚本源码在<a href="https://github.com/checkpoint-restore/criu/blob/criu-dev/compel/arch/x86/scripts/compel-pack.lds.S">这里</a></p><p>.compel.exit和.compel.init两个section是为了实现插件的初始化，不多赘述。</p><h5 id="compel的syscall封装过程"><a href="#compel的syscall封装过程" class="headerlink" title="compel的syscall封装过程"></a>compel的syscall封装过程</h5><p>源码涉及以下两个文件：</p><ul><li><a href="https://github.com/checkpoint-restore/criu/blob/criu-dev/include/common/arch/x86/asm/linkage.h">linkage.h</a></li><li><a href="https://github.com/checkpoint-restore/criu/blob/criu-dev/compel/arch/x86/plugins/std/syscalls/syscall-common-x86-64.S">syscall-common-x86-64.S</a></li></ul><p>这里有意思的细节很多：</p><ol><li>为了对齐加入0x90，0x90在X86下是NOP指令，见参考1</li><li>“movq %rcx, %r10”是因为用户态函数调用的ABI和syscall的ABI存在一个细微差异，见参考2</li></ol><h4 id="将该relocate-file映射到进程上下文中"><a href="#将该relocate-file映射到进程上下文中" class="headerlink" title="将该relocate file映射到进程上下文中"></a>将该relocate file映射到进程上下文中</h4><p>这一步通过ptrace实现，ptrace可以实现在进程上下文进程syscall，具体原理此处不赘述。</p><h4 id="对注入的代码进行relocation处理"><a href="#对注入的代码进行relocation处理" class="headerlink" title="对注入的代码进行relocation处理"></a>对注入的代码进行relocation处理</h4><p>源码实现在<a href="https://github.com/checkpoint-restore/criu/blob/criu-dev/compel/src/lib/handle-elf.c">这里</a></p><p>这一步compel分成两部分进行</p><ol><li>将第一步生成的relocate file进行预处理，生成一个头文件</li><li>头文件里记录了简化后的relocation information</li></ol><p>第一步预处理，生成头文件，我个人猜测是为了执行速度和简化内存处理。这一步会为所有的section都分配内存，包含NOBITS的BSS，塞到一个unsigned char数组中。其他符号和重定向信息会生成特定的数据结构。<br>第二步，根据描述信息，对blob进行重定向处理。</p><p>最终执行时，还需要分配栈空间，信号处理函数的栈空间等等，其内存模型参考<a href="https://criu.org/Parasite_code">这里</a></p><p>这里内存分配中，在多线程环境下，有两个栈，一个用于主线程，一个是其他线程。其他线程共用一个栈，即其他线程之间不存在并发。</p><h4 id="修改执行上下文的寄存器值，让进程跳转到区域执行"><a href="#修改执行上下文的寄存器值，让进程跳转到区域执行" class="headerlink" title="修改执行上下文的寄存器值，让进程跳转到区域执行"></a>修改执行上下文的寄存器值，让进程跳转到区域执行</h4><p>通过ptrace实现</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://stackoverflow.com/questions/18413107/align-directive-proper-usage-with-align5-and-0x90">Why 0x90</a></li><li><a href="https://stackoverflow.com/questions/2535989/what-are-the-calling-conventions-for-unix-linux-system-calls-and-user-space-f">ABI for syscall</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Criu </tag>
            
            <tag> Compel </tag>
            
            <tag> Code injection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>libcare实现live patch的要点总结</title>
      <link href="/livepatch-libcare/"/>
      <url>/livepatch-libcare/</url>
      
        <content type="html"><![CDATA[<p>libcare是一个用户态的live patch解决方案，项目地址在<a href="https://github.com/cloudlinux/libcare">这里</a></p><h3 id="live-patch的一般原理"><a href="#live-patch的一般原理" class="headerlink" title="live patch的一般原理"></a>live patch的一般原理</h3><p>不考虑libcare的实现，live patch实现包含以下过程：</p><ol><li>生成live patch –&gt; diff-binary</li><li>解析live patch –&gt; 符号引用&#x2F;重定向</li><li>打入live patch –&gt; 栈检测&#x2F;插入jmp指令</li></ol><p>关键要点在于解决以下问题：</p><ol><li>如何解决live patch对原有地址空间的符号引用</li><li>如何解析原有地址空间的符号信息</li><li>如何将live patch注入到原有地址空间，并执行</li><li>如何识别新拉起的进程是否需要打入补丁</li><li>如何管理进程上的多个补丁以及补丁间的依赖关系</li></ol><p>下面将以libcare为例，对以上过程进行具体分析。</p><h3 id="制作live-patch"><a href="#制作live-patch" class="headerlink" title="制作live patch"></a>制作live patch</h3><p>libcare的实现主要是针对C语言，live patch的生成过程，本质是对打补丁前后生成的binary进行对比，找到差异部分，找到变化的变量和函数，以section为单位</p><p>这里又有几个关键问题需要解决：</p><ol><li>如何对两个binary进行对比(diff-binary)</li><li>如何解决补丁对原有ELF的符号引用</li></ol><p>具体的过程可以参考libcare自己的<a href="https://github.com/cloudlinux/libcare/blob/master/docs/internals.rst">文档</a></p><h3 id="解析live-patch"><a href="#解析live-patch" class="headerlink" title="解析live patch"></a>解析live patch</h3><p>Live patch制作完成后，是一个特殊的重定向文件。</p><p>解析过程需要解决的问题：</p><ol><li>为live patch分配内存–&gt; 内存地址尽可能靠近被修改的函数</li><li>解析原有地址空间里的符号地址</li></ol><h4 id="为live-patch分配内存"><a href="#为live-patch分配内存" class="headerlink" title="为live patch分配内存"></a>为live patch分配内存</h4><p>libcare读取目标进程proc目录下的smaps文件，获取目标进程的内存分布。根据内存分配，生成一个hole list，从hole list中选取一块足够大且最靠近修改函数的地址。</p><h4 id="解析原有地址空间的符号地址"><a href="#解析原有地址空间的符号地址" class="headerlink" title="解析原有地址空间的符号地址"></a>解析原有地址空间的符号地址</h4><ol><li>获取目标进程的内存分布</li><li>通过proc目录下的mem直接读取目标进程的内存内容</li><li>尝试对各段内存的头部进行解析，如果是ELF文件，获取对应的符号信息</li></ol><h3 id="打入patch"><a href="#打入patch" class="headerlink" title="打入patch"></a>打入patch</h3><p>这一步要解决的问题：</p><ol><li>栈检测 –&gt; 确保打入时，没有进程正在运行修改函数(实际上大部分情况下新旧函数一起运行也是可以的)。</li><li>修改函数入口，加入jmp指令。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Libcare的live patch主要借助ptrace和proc文件实现</p><ol><li>通过ptrace停止进程，进行代码注入</li><li>通过&#x2F;proc&#x2F;[pid]&#x2F;smaps读取内存分配</li><li>通过&#x2F;proc&#x2F;[pid]&#x2F;mem读取和修改进程内存</li></ol><p>Libcare的补丁管理比较简单</p><ol><li>补丁的文件名有一个生成规则(buildID有关)</li><li>打补丁之前，看下有无旧补丁</li><li>新进程拉起的识别问题，暂时没看到libcare有解决</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Live patch </tag>
            
            <tag> Libcare </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux ELF规范整理</title>
      <link href="/elf/"/>
      <url>/elf/</url>
      
        <content type="html"><![CDATA[<h2 id="Object-Files"><a href="#Object-Files" class="headerlink" title="Object Files"></a>Object Files</h2><p>Three types:</p><ol><li>relocatable file –&gt; need to link</li><li>executable file –&gt; exec uses it to create image</li><li>shared object file</li></ol><p><strong>Linking View</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ELF header</span><br><span class="line">-------------------------------</span><br><span class="line">Program header table optional</span><br><span class="line">-------------------------------</span><br><span class="line">Section 1</span><br><span class="line">-------------------------------</span><br><span class="line">...</span><br><span class="line">-------------------------------</span><br><span class="line">Section n</span><br><span class="line">-------------------------------</span><br><span class="line">...</span><br><span class="line">-------------------------------</span><br><span class="line">...</span><br><span class="line">-------------------------------</span><br><span class="line">Section header table</span><br><span class="line">-------------------------------</span><br></pre></td></tr></table></figure><p>Sections hold the bulk of object file information for linking view: instructions, data, symbol table, relocation information, and so on.</p><p><strong>Execution View</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ELF header</span><br><span class="line">-------------------------------</span><br><span class="line">Program header table</span><br><span class="line">-------------------------------</span><br><span class="line">Segment 1</span><br><span class="line">-------------------------------</span><br><span class="line">Segment 2</span><br><span class="line">-------------------------------</span><br><span class="line">...</span><br><span class="line">-------------------------------</span><br><span class="line">Section header table optional</span><br></pre></td></tr></table></figure><p>Segment是从在ELF执行时看到的内存视图，此时的Segment跟权限有关。ARM下是两个Segment，X86下是四个，mprotect在修改权限的过程中，会导致新Segment的出现(本质是split vma)。</p><p>在ELF规范中，仅有ELF header是有固定位置的，其余的信息被ELF header描述。program header的作用是告诉内核如何创建process，section header table的作用是在linking阶段用于描述一个section。</p><p><strong>Data Representation</strong></p><table><thead><tr><th>Name</th><th>Size</th><th>Alignment</th><th>Purpose</th></tr></thead><tbody><tr><td>Elf32_Addr</td><td>4</td><td>4</td><td>Unsigned program address</td></tr><tr><td>Elf32_Off</td><td>4</td><td>4</td><td>Unsigned file offset</td></tr><tr><td>Elf32_Sword</td><td>4</td><td>4</td><td>Signed large integer</td></tr><tr><td>Elf32_Word</td><td>4</td><td>4</td><td>Unsigned large integer</td></tr><tr><td>Elf32_Half</td><td>2</td><td>2</td><td>Unsigned medium integer</td></tr><tr><td>unsigned char</td><td>1</td><td>1</td><td>Unsigned small integer</td></tr></tbody></table><p><strong>Sections</strong></p><p>Special Section Indexes:</p><ol><li>SHN_UNDEF(0) marks an undefined, missing, irrelevant, or otherwise meaningless section reference.</li><li>SHN_LORESERVE(0xff00) lower bound of the range of reserved indexes.</li><li>SHN_LOPROC(0xff00) - SHN_HIPROC(0xff1f) inclusive range are reserved for processor-specific.</li><li>SHN_ABS(0xfff1) - absolue values for the corresponding reference.</li><li>SHN_COMMON(0xfff2) - common symbols, such like unallocated C external variables.</li><li>SHN_HIRESERVE(0xffff) - upper bound of the range of reserved indexes</li></ol><p>Special Sections(part):</p><ul><li>.bss</li><li>.comment</li><li>.data&#x2F;.data1</li><li>.debug</li><li>.dynamic (dynamic linking information)</li><li>.dynstr</li><li>.dynsym</li><li>.fini</li><li>.got (global offset table)</li><li>.hash (symbol hash table)</li><li>.init (executable instructions for initialization)</li><li>.interp</li><li>.line (symbolic debugging)</li><li>.note</li><li>.plt (procedure linkage table)</li><li>.relname&#x2F;.relaname (relacation information for one section)</li><li>.rodata&#x2F;.rodata1</li><li>.shstrtab</li><li>.text</li></ul><p>Section name with a dot (.) prefix are reserved for the system.</p><p><strong>Symbol Table</strong></p><p>Relocation，是指对symbol table进行重定向。</p><p>Symbol Table Entry:</p><ul><li>st_name -&gt; an index</li><li>st_value -&gt; value of the associated symbol</li><li>st_size</li><li>st_info -&gt; symbol’s type and binding attributes</li><li>st_other -&gt; no special meanthing</li><li>st_shndx -&gt; relevant section header table index</li></ul><p>Symbol Binding:</p><ul><li>STB_LOCAL</li><li>STB_GLOBAL</li><li>STB_WEAK</li><li>STB_LOPROC through STB_HIPROC</li></ul><p>Symbol Types:</p><ul><li>STT_NOTYPE -&gt; not specified</li><li>STT_OBJECT -&gt; data object</li><li>STT_FUNC -&gt; function&#x2F;executable code</li><li>STT_SECTION</li><li>STT_FILE</li><li>STT_LOPROC through STT_HIPROC</li></ul><p>Special Section index:</p><ul><li>SHN_ABS -&gt; an absolute value</li><li>SHN_COMMON -&gt; a common block</li><li>SHN_UNDEF -&gt; need to be resolved</li></ul><p>Procedure linkage table是为了解决objects之间func object引用的问题。</p><p><strong>Relocation</strong></p><p>Elf32_Rel:</p><ul><li>r_offset</li><li>r_info</li></ul><p>Elf32_Rela:</p><ul><li>r_offset</li><li>r_info</li><li>r_addend</li></ul><p>r_offset: the location at which to apply the relocation action<br>r_info: releated symbol table index and type of relocation to apply (low 8 bits)<br>r_addend: a constant addend used to compute the value to be stored into the relocatable field</p><p><strong>Relocation Types</strong><br>A: r_addend<br>B: mmap base address<br>G: the offset into the global offset table<br>GOT: address of the global offset table<br>L: the place of the procedure linkage table entry<br>P: r_offset<br>S: the value of the symbol</p><table><thead><tr><th>Name</th><th>Value</th><th>Field</th><th>Calculation</th></tr></thead><tbody><tr><td>R_386_NONE</td><td>0</td><td>none</td><td>none</td></tr><tr><td>R_386_32</td><td>1</td><td>word32</td><td>S+A</td></tr><tr><td>R_386_PC32</td><td>2</td><td>word32</td><td>S+A-P</td></tr><tr><td>R_386_GOT32</td><td>3</td><td>word32</td><td>G+A-P</td></tr><tr><td>R_386_PLT32</td><td>4</td><td>word32</td><td>L+A-P</td></tr><tr><td>R_386_COPY</td><td>5</td><td>none</td><td>none</td></tr><tr><td>R_386_GLOB_DAT</td><td>6</td><td>word32</td><td>S</td></tr><tr><td>R_386_JMP_SLOT</td><td>7</td><td>word32</td><td>S</td></tr><tr><td>R_386_RELATIVE</td><td>8</td><td>word32</td><td>B+A</td></tr><tr><td>R_386_GOTOFF</td><td>9</td><td>word32</td><td>S+A-GOT</td></tr><tr><td>R_386_GOTOC</td><td>10</td><td>word32</td><td>GOT+A-P</td></tr></tbody></table><h2 id="program-loading-and-dynamic-linking"><a href="#program-loading-and-dynamic-linking" class="headerlink" title="program loading and dynamic linking"></a>program loading and dynamic linking</h2><p>Type为SHT_NOTE的section用于记录一些auxiliary information，该section有固定的格式。</p><p>为了做到延迟加载，对segment的地址进行页对齐是必要的。</p><p>Interperter(dynamic linker)接收控制权的两种方法：</p><ol><li>receive a file descriptor</li><li>load the executable file into memory</li></ol><p>Interperter的作用，实际上是将一部分工作从OS中解耦出来，由OS之外的部分来定义和维护，包括：</p><ol><li>将ELF的memory segments添加至进程</li><li>将shared object的memory segments添加至进程</li><li>进行relocation动作</li><li>清理现场，比如关闭打开的ELF fd</li><li>将控制权转移给program，看起来就像是从kernel直接接过控制权一样(保持透明)</li></ol><p>Special sections from the link editor:</p><ul><li>.dynamic section &#x2F; SHT_DYNAMIC -&gt; addresses of other dynamic linking information</li><li>.hash &#x2F; SHT_HASH -&gt; symbol hash table</li><li>.got(.plt) &#x2F; SHT_PROGBITS</li></ul><p><strong>Dynamic Section</strong></p><p>如果object文件参与dynamic linking过程，其program header table中将有一个类型为PT_DYNAMIC的section。这个section包含了一个数组，以键值对的形式描述了一系列信息。</p><p><strong>Global offset table</strong></p><p>Global offset table redirects position-independent address calculations to absolute locations.</p><p><strong>Procedure linkage table</strong></p><p>Procedure linkage table redirects position-independent function calls to absolute locations.</p><p><strong>Steps of the dynamic linker</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.PLT0:pushl 4(%ebx)</span><br><span class="line">jmp *8(%ebx)</span><br><span class="line">nop; nop</span><br><span class="line">nop; nop</span><br><span class="line">.PLT1:jmp *name1@GOT(%ebx)</span><br><span class="line">pushl $offset</span><br><span class="line">jmp .PLT0@PC</span><br><span class="line">.PLT2:jmp *name2@GOT(%ebx)</span><br><span class="line">pushl $offset</span><br><span class="line">jmp .PLT0@PC</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ol><li>the dynamic linker sets the second and the third entries in the global offset table to special values.</li><li>如果procedure linkage table是PIC的，global offset table的地址必须放在ebx寄存器。每个shared object file都有自己的procedure linkage table。</li><li>假设program调用了name1，控制权将转移给lable .PLT1.</li><li>跳转到GOT中name1对应的地址，第一次运行时，会直接运行到下一条push指令。</li><li>这个offset是一个relocation offset(在relocation table中的一个偏移)，该relocation entry的type将是R_386_JMP_SLOT，relocation entry的offset将是<em>GOT</em>对应entry的位置，需要解析的位置就是name1的地址。</li><li>接着，program跳到.PLT0，此时，将把第二个GOT entry的位置放入栈中(用作dynamic的标识信息)。然后，跳入third GOT entry，将控制权转移给dynamic linker。</li><li>当dynmaic linker获得控制权后，dynamic linker将从栈中获取到参数，计算出name1的地址，将地址写入到GOT表中，将控制权转移给目标函数。</li><li>后续的name1调用，将直接进入对应函数，无需再次进入dynamic linker，就是说.PLT1中的地址，已经被改成了目标函数地址。(此处的直接，仍然是进入PLT表，再直接进入GOT指明的地址。)</li></ol><p>LD_BIND_NOW环境变量的值，将决定是否要将PLT的relocation过程推迟到第一次使用的时候。</p><p><strong>Hash Table</strong></p><p>nbucket&#x2F;nchain</p><h2 id="c-library"><a href="#c-library" class="headerlink" title="c library"></a>c library</h2><p>C library包含的符号列表(略)。</p><h2 id="ELF需要处理的核心问题"><a href="#ELF需要处理的核心问题" class="headerlink" title="ELF需要处理的核心问题"></a>ELF需要处理的核心问题</h2><ol><li>内存如何分配</li><li>如何保证安全性<ul><li>对内存设置最小权限，比如text段通常不具备写权限。</li><li>SHT_HASH的存在</li></ul></li></ol><h2 id="Q-A"><a href="#Q-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ol><li>API和ABI的区别<br>API的函数调用的规范，开发者在代码开发时，需要知道这一信息，应该传递哪些参数，以及应当获得什么样的结果，以及对错误结果的说明。</li></ol><p>ABI是对编译器而言，一个进程由不同的ELF组成，这些ELF是分别编译的，在进行函数调用时，应该如何去读取参数，是去stack中读取，还是去register中读取，哪些register由调用者保护，哪些又是由被调用者保护。</p><p>总结下，区别是，API是代码编写层面的规范，ABI是汇编生成阶段的规范。共同点是，都是为了解决不同object之间的函数调用问题。</p><ol start="2"><li>Global offset table和Procedure linkage table的区别</li></ol><p>Global offset table记录的是符号的绝对地址。</p><p>Procedure linkage table记录的是函数的绝对地址，用于函数跳转。</p><p>共同点：都是为了解决编译时无法确定地址的问题，通过一层跳转，将地址计算推迟到load stage。<br>不同点：GOT本质上是一个symbol table，PLT也是记录的地址，但是GOT是键值对，即纯粹只记录了地址，而PLT不仅记录了地址，而通过相关指令进行了jmp动作。GOT承担的是索引功能，PLT本身是text段的一部分。</p><p>总的来说，最终的地址修改都是在对GOT表生效的，而PLT的作用则是控制权的转移。</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ol><li><a href="https://www.cs.cmu.edu/afs/cs/academic/class/15213-f00/docs/elf.pdf">CMU&#x2F;ELF</a></li><li><a href="https://www.section.io/engineering-education/what-is-an-abi/">What is ABI</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> ELF </tag>
            
            <tag> Live patch </tag>
            
            <tag> Assembly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>return handler的断点原理</title>
      <link href="/rethandler/"/>
      <url>/rethandler/</url>
      
        <content type="html"><![CDATA[<h2 id="return-handler"><a href="#return-handler" class="headerlink" title="return handler"></a>return handler</h2><p>所谓return handler，是指在目标函数执行结束离开该函数时触发的handler。一般的断点是对指令进行替换，触发系统的异常处理。return handler的问题在于，函数有多个return出口，不可能全部一一识别并替换。</p><p>但是函数总是要返回的，返回的地址必然被记录在某处地方。在ARM体系结构下，有专门的LR寄存器。在X86下，return address则是被压入栈中。</p><p>注意，我们拿到的是记录返回地址的地址。这句话有点绕，寄存器或者栈本身不是返回的执行地址，而是记录了返回地址的地方。有两种办法，去修改返回地址：</p><ol><li><p>修改寄存器或者栈，直接指向某一处handler地址，函数返回后，就会跳转到该handler执行。需要注意的是，这种方案下，这个handler必须跟函数在同一地址空间里。也就是，这个handler是在用户态执行的。(这里只讨论用户态程序）</p></li><li><p>修改寄存器或者栈指向的地址，修改成break指令。这样函数在执行完毕，跳转回去后，执行该指令后，将会触发系统的异常处理，从而进入了系统的handler处理。需要注意的是，系统的handler处理是在内核态触发的。</p></li></ol><p>然而，仍然有两个问题需要解决：</p><ol><li><p>上面两种方案的前提，都是要识别已经进入函数中，再对return address进行修改。因此return handler断点处理首先需要在函数的入口处打上一般断点，在入口的断点处理流程中，修改返回值。</p></li><li><p>修改之后如何还原，第一种方案需要记录原来的地址，在handler里面通过jmp还原正常的处理流程。第二种方案使用一般断点的处理思路即可。</p></li></ol><h2 id="X64-return-handler的原理示例程序"><a href="#X64-return-handler的原理示例程序" class="headerlink" title="X64 return handler的原理示例程序"></a>X64 return handler的原理示例程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">unsigned long original_ret;</span><br><span class="line"></span><br><span class="line">static void ret_handler(void)</span><br><span class="line">&#123;</span><br><span class="line">    // doing something necessary</span><br><span class="line">    printf(&quot;return handler executed here 0x%lx \n&quot;, original_ret);</span><br><span class="line">    asm volatile(&quot;jmp *%0&quot; : : &quot;r&quot; (original_ret));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unsigned long hijack_handler = 0x40116a;</span><br><span class="line"></span><br><span class="line">#define hijack_return_address() &#123; \</span><br><span class="line">    asm volatile( \</span><br><span class="line">        &quot;mov %%rbp, %%rdi \n\t&quot; \</span><br><span class="line">        &quot;addq $0x8, %%rdi \n\t&quot; \</span><br><span class="line">        &quot;mov (%%rdi), %0 \n\t&quot; \</span><br><span class="line">        &quot;movq %1, (%%rdi) \n\t&quot; \</span><br><span class="line">        : &quot;=&amp;r&quot; (original_ret) \</span><br><span class="line">        : &quot;r&quot; (hijack_handler) \</span><br><span class="line">        : &quot;%rdi&quot; \</span><br><span class="line">    ); \</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static unsigned long test_print(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    char name[] = &quot;test for hijack handler \n&quot;;</span><br><span class="line">    unsigned long ret = 0;</span><br><span class="line">    for (i = 0; i &lt; strlen(name); i++) &#123;</span><br><span class="line">        printf(&quot;%c&quot;, name[i]);</span><br><span class="line">        ret += name[i];</span><br><span class="line">    &#125;</span><br><span class="line">    // we can execute it in any place within this func.</span><br><span class="line">    hijack_return_address();</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        test_print();</span><br><span class="line">        sleep(10);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一些说明：</p><ol><li><p>内联汇编中，由于输入和输出会操作同一个寄存器，一个是写，一个是读。因此，需要限制输入和输出动作不会使用同一个额外的寄存器进行跳转，因此要加上”&amp;”。GNU的说明，参考<a href="https://gcc.gnu.org/onlinedocs/gcc/Modifiers.html">此处</a>。</p></li><li><p>此处汇编写成宏，是因为call指令会影响rbp&#x2F;rsp寄存器，从而影响return address的寻找，实际应用过程中，这里对return address的修改一般是通过代码注入完成的。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> ELF </tag>
            
            <tag> Live patch </tag>
            
            <tag> Assembly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何对inode结构执行mmap操作</title>
      <link href="/mmap-inode/"/>
      <url>/mmap-inode/</url>
      
        <content type="html"><![CDATA[<h2 id="struct-inode-struct-dentry-struct-file"><a href="#struct-inode-struct-dentry-struct-file" class="headerlink" title="struct inode, struct dentry, struct file"></a>struct inode, struct dentry, struct file</h2><p><img src="https://miro.medium.com/max/502/1*Hg1I1fJVItCe_WvIiJEriA.png" alt="inode, dentry, file之间的关系"></p><ol><li>struct file是对打开文件的抽象，每个进程都有一个fd table，一个fd对应一个struct file</li><li>struct dentry是对文件系统里一个路径的抽象，即一个逻辑文件。(目录是一种特殊的文件)</li><li>struct inode是对磁盘里一个文件的抽象，即一个物理文件。</li><li>多个struct file可以指向同一个struct dentry，即一个文件被多次打开。</li><li>多个struct dentry可以指向同一个struct inode，即文件系统中有不同路径链接到同一个物理文件。</li></ol><h2 id="如何对一个struct-inode执行mmap操作"><a href="#如何对一个struct-inode执行mmap操作" class="headerlink" title="如何对一个struct inode执行mmap操作"></a>如何对一个struct inode执行mmap操作</h2><ol><li>kernel里执行mmap操作的API是vm_mmap，vm_mmap操作的对象是struct file。</li><li>获得一个struct file的API是filp_open，filp_open接受的是一个path。</li><li>每一个path都对应一个struct dentry，一个struct inode对应多个struct dentry。</li></ol><p>以下代码，仅考虑映射struct inode对应的文件(如果需要指定路径，则需要多一个遍历过程):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct file *d_open_inode(struct inode *inode)</span><br><span class="line">&#123;</span><br><span class="line">    struct  dentry *alias;</span><br><span class="line">    char *name = __getname(), *p;</span><br><span class="line">    struct  file *d_file = NULL;</span><br><span class="line"></span><br><span class="line">    if (hlist_empty(&amp;inode-&gt;i_dentry))</span><br><span class="line">    return NULL;</span><br><span class="line"></span><br><span class="line">    spin_lock(&amp;inode-&gt;i_lock);</span><br><span class="line">    alias = hlist_entry(inode-&gt;i_dentry.first, struct dentry, d_u.d_alias);</span><br><span class="line">    p = dentry_path_raw(alias, name, PATH_MAX);</span><br><span class="line">    if (IS_ERR(p)) &#123;</span><br><span class="line">        goto  out_unlock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    d_file = filp_open(p, O_RDWR, 0);</span><br><span class="line">out_unlock:</span><br><span class="line">    __putname(name);</span><br><span class="line">    spin_unlock(&amp;inode-&gt;i_lock);</span><br><span class="line">    return d_file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> VFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP3(QUIC)-HTTP发展历史整理</title>
      <link href="/http3-quic/"/>
      <url>/http3-quic/</url>
      
        <content type="html"><![CDATA[<h2 id="PPT链接"><a href="#PPT链接" class="headerlink" title="PPT链接"></a>PPT链接</h2><ul><li><p><a href="pdf/quic%E6%BC%94%E7%A4%BA.pdf">QUIC protocol.pdf</a></p></li><li><p><a href="pdf/quic%E6%BC%94%E7%A4%BA.pptx">QUIC protocol.pptx</a></p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>website的特点是资源较多，这些资源包括js脚本，html文件，css文件等等，这些资源大小不一，大部分都是几M左右，且相互之间存在依赖关系。</p></li><li><p>HTTP的发展历史，就是逐步解决HOL(Head of line)问题的过程，HTTP&#x2F;2支持multiplexing，在应用层解决了这个问题。HTTP&#x2F;3使用udp取代TCP，在传输层解决了这个问题。</p></li><li><p>HTTP协议最初的设计极不专业，且相比于HTTP1.0出现的年代，网络环境已经发展了极大的变化，尤其是移动网络的崛起。</p></li><li><p>HTTP&#x2F;3吸收了若干年以来网络协议的改造成果，算是集大成者。包括DTLS，ECN，SCTP等等。</p></li><li><p>QUIC在低延迟，低丢包的环境下，效率低于TCP，且存在包的超发。QUIC协议并不是要取代TCP协议，尽管QUIC协议将来可能有HTTP之外的应用场景。</p></li><li><p>QUIC协议版本众多，当前涉及到的RFC有：RFC 8009&#x2F;RFC 9000&#x2F;RFC 9001&#x2F;RFC 9002。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> HTTP </tag>
            
            <tag> QUIC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Per-CPU及RSEQ机制分析</title>
      <link href="/rseq-percpu/"/>
      <url>/rseq-percpu/</url>
      
        <content type="html"><![CDATA[<h2 id="Per-CPU"><a href="#Per-CPU" class="headerlink" title="Per-CPU"></a>Per-CPU</h2><h3 id="设计的出发点和优点"><a href="#设计的出发点和优点" class="headerlink" title="设计的出发点和优点"></a>设计的出发点和优点</h3><p>现代的cpu都有cache hierarchy的设计，这一设计会极大的加快cpu访问内存的速度。但是cache的引入会带来内存访问一致性的问题。比如一个变量对多个核是可见的，对值的修改将导致所有其他核中缓存的该值失效，需要重新load最新的值，这将带来极大的效率损失。</p><p>考虑一种场景，服务器需要统计对磁盘的访问速度，正常的设计会使用一个全局的统计值，通过原子变量或者其他同步机制去修改该统计值。但是，通过per-cpu机制，每个cpu在调度运行时，只需要修改自己的值就可以了。这样一来，在这个值上面，cpu之间将不存在竞争。如果需要获得全局的统计值，依次相加即可。</p><p>当然，per-cpu带来性能提升带前提是，程序修改值的时间要远远大于读取统计值的时间。这一前提大多数情况下是成立的。</p><h3 id="设计的要点和存在问题"><a href="#设计的要点和存在问题" class="headerlink" title="设计的要点和存在问题"></a>设计的要点和存在问题</h3><p>per-cpu会带来内存的浪费，核数越多，这种内存浪费越明显。因此，per-cpu不应该用NR_CPUS作为规格来分配内存，而是系统初始化时，按照实际内核的数量来分配，以减少内存浪费。</p><p>同时，由于per-cpu的出发点，是加速cpu的访问，避免cpu-cache的不一致问题，因此设计应该尽量符合cpu cache的特点。采取指针数组的形式，主要有以下几个问题需要考虑[^2]：</p><ol><li>指针数组如果包含在一个数据结构里面，可能会导致其前后的数据成员在内存中的位置过于<br>分散，导致cpu加载该结构时，占据更多的cache lines。</li><li>每个cpu只需要一个指针，访问其对应的区域即可。如果采用指针数组，一个cpu可能需要load多个指针的地址，带来不必要的浪费。</li><li>获取cpu对应的指针需要两步，获取数组地址，然后获取对应cpu的指针。</li></ol><p>因此，Christoph采取了一个简单的办法解决以上问题，把指针数组变成一个大数组。即所有per-cpu区域在内存上是连续的，只需要一个指针，通过计算cpu相应的偏移，就可以访问到对应区域。</p><h3 id="源码分析-Linux-5-10"><a href="#源码分析-Linux-5-10" class="headerlink" title="源码分析(Linux 5.10)"></a>源码分析(Linux 5.10)</h3><p>如上文所述，per-cpu设计的要点在于：</p><ol><li>如何减少内存的浪费</li><li>如何合理设计数据结构，保证亲和性的同时，减少cache lines的占用</li><li>如何管理per-cpu的内存区域</li></ol><h4 id="per-cpu如何分配和管理内存？"><a href="#per-cpu如何分配和管理内存？" class="headerlink" title="per-cpu如何分配和管理内存？"></a>per-cpu如何分配和管理内存？</h4><p>per-cpu的内存布局如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c0                           c1                         c2</span><br><span class="line">-------------------          -------------------        ------------</span><br><span class="line">| u0 | u1 | u2 | u3 |        | u0 | u1 | u2 | u3 |      | u0 | u1 | u</span><br><span class="line">-------------------  ......  -------------------  ....  ------------</span><br></pre></td></tr></table></figure><p>在同一个NUMA节点中，各个core的per-cpu区域是连续的。但是在NUMA节点之间，内存并不是连续的。也就是说，对于多NUMA节点的机器，需要根据cpu获取到对应的基址和偏移。</p><p>根据用途的不同，各个cpu的per-cpu的内存区域分为三部分，如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Static | [Reserved] | Dynamic&gt;</span><br></pre></td></tr></table></figure><p>static用于内核编译阶段所能识别出的per-cpu变量。<br>reserved用于内核模块使用到的static per-cpu变量。<br>dynamic用于运行过程中的per-cpu变量的申请和释放。</p><p>其中，static区域比较特殊，因为内核的运行就需要使用到该区域，必须尽可能早的进行初始化。</p><p>在start_kernel阶段，通过调用setup_per_cpu_areas()初始化per-cpu使用到的内存。</p><p>arm64下的实现比较简单，setup_per_cpu_areas的实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void __init setup_per_cpu_areas(void)</span><br><span class="line">&#123;</span><br><span class="line">unsigned long delta;</span><br><span class="line">unsigned int cpu;</span><br><span class="line">int rc;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Always reserve area for module percpu variables.  That&#x27;s</span><br><span class="line"> * what the legacy allocator did.</span><br><span class="line"> */</span><br><span class="line">rc = pcpu_embed_first_chunk(PERCPU_MODULE_RESERVE,</span><br><span class="line">    PERCPU_DYNAMIC_RESERVE, PAGE_SIZE,</span><br><span class="line">    pcpu_cpu_distance,</span><br><span class="line">    pcpu_fc_alloc, pcpu_fc_free);</span><br><span class="line">if (rc &lt; 0)</span><br><span class="line">panic(&quot;Failed to initialize percpu areas.&quot;);</span><br><span class="line"></span><br><span class="line">delta = (unsigned long)pcpu_base_addr - (unsigned long)__per_cpu_start;</span><br><span class="line">for_each_possible_cpu(cpu)</span><br><span class="line">__per_cpu_offset[cpu] = delta + pcpu_unit_offsets[cpu];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，在pcpu_embed_first_chunk调用完成per-cpu内存初始化之前，任何代码都无法使用per-cpu特性。</p><p>这一过程中，最重要的是数据结构是struct  pcpu_alloc_info，相关的内存布局信息都存储在该数据结构中。这里面的内存管理实现细节较多(为了做到严格的内存对齐，而实现加速访问)，这里不做过多赘述，重点关注下几个值的计算过程。</p><ol><li><p>pcpu_base_addr<br>pcpu_base_addr 是多个NUMA节点中最小的那个基址<br>计算过程为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ptr = alloc_fn(cpu, gi-&gt;nr_units * ai-&gt;unit_size, atom_size);</span><br><span class="line">...</span><br><span class="line">base = min(ptr, base);</span><br><span class="line">...</span><br><span class="line">pcpu_setup_first_chunk(ai, base);</span><br><span class="line">...</span><br><span class="line">pcpu_base_addr = base_addr;</span><br></pre></td></tr></table></figure></li><li><p>__per_cpu_start<br>__per_cpu_start 是链接脚本中指明的per-cpu section的起始位置，在System.map中值为0。通过__per_cpu_end - __per_cpu_start可以计算static size的大小。</p></li><li><p>__per_cpu_load<br>__per_cpu_load对PERCPU_INPUT所定义的section进行了进一步封装。在System.map中，其值是per-cpu section的内存起始地址。</p></li><li><p>pcpu_unit_offsets<br>pcpu_unit_offsets是一个数组，记录了各个CPU static区域对应pcpu_base_addr的偏移。</p></li><li><p>__per_cpu_offset<br>__per_cpu_offset是一个数组，其计算方式为：__per_cpu_offset[cpu] &#x3D; (unsigned  long)pcpu_base_addr - (unsigned  long)__per_cpu_start + pcpu_unit_offsets[cpu];<br>其结果表示，各个CPU static区域对应__per_cpu_start 的偏移。这一结果非常重要，将后续用于per_cpu变量地址的计算。</p></li></ol><p>这一函数调用结束后，vmlinux中per cpu相关的section会被拷贝到每个CPU对应的static区域。对应代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">for (group = 0; group &lt; ai-&gt;nr_groups; group++) &#123;</span><br><span class="line">struct pcpu_group_info *gi = &amp;ai-&gt;groups[group];</span><br><span class="line">void *ptr = areas[group];</span><br><span class="line"></span><br><span class="line">for (i = 0; i &lt; gi-&gt;nr_units; i++, ptr += ai-&gt;unit_size) &#123;</span><br><span class="line">if (gi-&gt;cpu_map[i] == NR_CPUS) &#123;</span><br><span class="line">/* unused unit, free whole */</span><br><span class="line">free_fn(ptr, ai-&gt;unit_size);</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">/* copy and return the unused part */</span><br><span class="line">memcpy(ptr, __per_cpu_load, ai-&gt;static_size);</span><br><span class="line">free_fn(ptr + size_sum, ai-&gt;unit_size - size_sum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何根据不同的cpu，计算出相应的偏移？-ARM64"><a href="#如何根据不同的cpu，计算出相应的偏移？-ARM64" class="headerlink" title="如何根据不同的cpu，计算出相应的偏移？(ARM64)"></a>如何根据不同的cpu，计算出相应的偏移？(ARM64)</h4><p>在boot cpu完成per cpu内存的初始化后，在后续初始化过程中，boot cpu将调用smp_prepare_boot_cpu函数，通过set_my_cpu_offset(per_cpu_offset(smp_processor_id()))完成最终设置。</p><p>对于noboot cpu，初始化过程中将调用cpu_init函数，通过set_my_cpu_offset(per_cpu_offset(cpu))完成最终设置。</p><p>per_cpu_offset(x)获取的就是之前所说的__per_cpu_offset[x]的值，即cpu x static区域相对于__per_cpu_start的偏移。 </p><p>set_my_cpu_offset的实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static inline void set_my_cpu_offset(unsigned long off)</span><br><span class="line">&#123;</span><br><span class="line">asm volatile(ALTERNATIVE(&quot;msr tpidr_el1, %0&quot;,</span><br><span class="line"> &quot;msr tpidr_el2, %0&quot;,</span><br><span class="line"> ARM64_HAS_VIRT_HOST_EXTN)</span><br><span class="line">:: &quot;r&quot; (off) : &quot;memory&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作用是把之前的偏移值直接写入tpidr_el1或者tpidr_el2寄存器。</p><blockquote><p>关于smp_processor_id的处理，smp_processor_id使用到了per cpu特性，其最早是在start_kernel–&gt;boot_cpu_init被调用，要早于setup_per_cpu_areas对per cpu的内存进行初始化。这里的调用不会引起问题吗？答案是不会，在更早的start_kernel–&gt;smp_setup_processor_id中，kernel调用了set_my_cpu_offset(0)。即把当前的per cpu偏移设置为0，后面通过per cpu机制访问到的，直接就是vmlinux中的变量。而此时的cpu_number是0，也就是boot cpu的编号。</p></blockquote><blockquote><p>一个查看kernel macro的办法，修改对应make file，加入ccflags-y :&#x3D; -save-temps&#x3D;obj</p></blockquote><h5 id="定义一个per-cpu变量"><a href="#定义一个per-cpu变量" class="headerlink" title="定义一个per-cpu变量"></a>定义一个per-cpu变量</h5><blockquote><p>DEFINE_PER_CPU(int, per_cpu_n)</p></blockquote><p>这个宏完全展开后，便是</p><blockquote><p><strong>attribute</strong>((section(“.data..percpu”))) int per_cpu_n</p></blockquote><p>在定义上，per cpu变量是section固定的变量。</p><h5 id="读取一个per-cpu变量"><a href="#读取一个per-cpu变量" class="headerlink" title="读取一个per-cpu变量"></a>读取一个per-cpu变量</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#define SHIFT_PERCPU_PTR(__p, __offset)\</span><br><span class="line">RELOC_HIDE((typeof(*(__p)) __kernel __force *)(__p), (__offset))</span><br><span class="line">...</span><br><span class="line">#define this_cpu_ptr(ptr)\</span><br><span class="line">(&#123;\</span><br><span class="line">__verify_pcpu_ptr(ptr);\</span><br><span class="line">SHIFT_PERCPU_PTR(ptr, my_cpu_offset);\</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>__verify_pcpu_ptr通过检查地址，确保该指针指向per cpu变量。SHIFT_PERCPU_PTR通过读取寄存器的值，对变量做一个偏移，从而获取到对应cpu的local变量。</p><p>为了防止调度导致上下文在不同的cpu上运行，get_cpu_var将关闭调度，put_cpu_var则重新开启调度。</p><h4 id="动态分配的per-cpu变量-chunk区域"><a href="#动态分配的per-cpu变量-chunk区域" class="headerlink" title="动态分配的per cpu变量(chunk区域)"></a>动态分配的per cpu变量(chunk区域)</h4><p>per cpu变量的管理上可以分为三类，分别为static，reserved，dynamic。其中static是编译内核时就可以确认的per cpu变量。其余两类则是运行时，动态进行管理的。其中，reserved区域用于管理模块的static per cpu变量。(模块编译时确定的per cpu变量，但是模块编译和运行，有可能在内核运行过程中，因此这类变量无法用static的方式处理。)</p><p>在模块编译时，per cpu变量便被放置在了特定命名的区域(.data..percpu)。</p><p>其内存分配过程为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">info-&gt;index.pcpu = find_pcpusec(info);</span><br><span class="line">--&gt; find_sec(info, &quot;.data..percpu&quot;);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">err = percpu_modalloc(mod, info);</span><br><span class="line"> --&gt; mod-&gt;percpu = __alloc_reserved_percpu(pcpusec-&gt;sh_size, align);</span><br><span class="line">  --&gt; pcpu_alloc(size, align, true, GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">err = post_relocation(mod, info);</span><br><span class="line"> --&gt; percpu_modcopy(mod, (void *)info-&gt;sechdrs[info-&gt;index.pcpu].sh_addr,</span><br><span class="line">                     info-&gt;sechdrs[info-&gt;index.pcpu].sh_size);</span><br><span class="line">--&gt; for_each_possible_cpu(cpu)</span><br><span class="line">                      memcpy(per_cpu_ptr(mod-&gt;percpu, cpu), from, size);</span><br></pre></td></tr></table></figure><p>chunk内存的管理逻辑本文将不涉及。</p><p>对于dynamic区域的per cpu变量，其区别在于如果该区域的内存耗尽了，是可以继续申请的。这也是first_chunk含义的由来，内核在初始化时，设置的dynamic区域被称为first chunk。其余用法与reserved一致。</p><h3 id="RSEQ-restartable-sequences-机制"><a href="#RSEQ-restartable-sequences-机制" class="headerlink" title="RSEQ(restartable-sequences)机制"></a>RSEQ(restartable-sequences)机制</h3><h4 id="诞生背景"><a href="#诞生背景" class="headerlink" title="诞生背景"></a>诞生背景</h4><p>并发控制策略可以粗略的分为两种：乐观并发控制(Optimistic Concurrency Control)和悲观并发控制(Pessimistic Concurrency Control)。</p><p>悲观并发控制，认为该数据的竞争较为激烈，总是先进行获取锁的动作，再去处理数据，典型的设计就是kernel中的mutx。</p><p>乐观并发控制，认为该数据的竞争情况较少。乐观并发控制的一般过程如下：</p><ol><li>读取数据，记录时间戳。</li><li>处理数据，处理结束后。在修改生效前，将相关数据的时间戳与记录数据戳进行比较，如果不一致，则进行回滚操作。</li><li>如果一致，则执行修改操作。<br>这种思路最直观的实现，就是CAS(compare and swap)锁。</li></ol><p>CAS锁的问题在于，其实现需要借助原子变量。体系结构的原子变量实现，通常需要锁总线，这一操作会带来较大的开销。</p><p>RSEQ机制源于一种观察，以链表插入为例，通常实现为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. node = head-&gt;next;</span><br><span class="line">2. head-&gt;next = node;</span><br></pre></td></tr></table></figure><p>将第一步称为准备区，用于产生最终需要提交的数据。第二步称为提交区，将修改完成的数据提交生效。在第二步执行之前，第一步的重复执行，是不会影响最终的程序结果的。如果线程在准备区开始到提交生效最终之前的执行过程被打断(调度或者信号…)，那么线程只需要从准备区开始位置重新执行即可。rseq机制可以避免原子操作带来的锁总线开销，但是，代价是被打断后重新执行的开销。在临界区(准备区+提交区)比较小或者竞争不激烈的情况下，刚好在这一区域被打断的概率是很低的，已有的数据表明(来自tcmalloc)，rseq的效率是高于CAS的。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ol><li><a href="https://programmer.ink/think/kernel-kernel-per-cpu-variable-module-writing.html">Per-CPU variable module writing</a></li><li><a href="https://lwn.net/Articles/258238/">Better per-CPU variables</a></li><li><a href="https://zhuanlan.zhihu.com/p/260986194">PERCPU变量实现</a></li><li><a href="https://www.cnblogs.com/still-smile/p/11655239.html">smp_processor_id()获取当前执行cpu_id</a></li><li><a href="https://www.efficios.com/blog/2019/02/08/linux-restartable-sequences/">The 5-year journey to bring restartable sequences to Linux</a></li><li><a href="https://github.com/google/tcmalloc/blob/master/docs/design.md">google&#x2F;tcmalloc</a></li><li><a href="https://github.com/facebookarchive/Rseq/blob/master/Rseq.md">facebookarchive&#x2F;Rseq</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Per-CPU </tag>
            
            <tag> RSEQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GNU C语言中的构造和析构函数</title>
      <link href="/c-cons-destr/"/>
      <url>/c-cons-destr/</url>
      
        <content type="html"><![CDATA[<p>考虑以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void __attribute__((constructor)) calledFirst();</span><br><span class="line">void __attribute__((constructor)) calledSecond();</span><br><span class="line">void __attribute__((destructor)) calledLast();</span><br><span class="line">void __attribute__((destructor)) calledLastSecond();</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;I am in main \n&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void calledSecond()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;I am called second \n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void calledFirst()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;I am called first \n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void calledLastSecond()</span><br><span class="line">&#123;</span><br><span class="line">        printf(&quot;I am called last second \n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void calledLast()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;I am called last \n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>I am called second<br>I am called first<br>I am in main<br>I am called last<br>I am called last second</p></blockquote><p>GNU对此属性的描述：</p><blockquote><p>constructor<br>destructor<br>constructor (priority)<br>destructor (priority)<br>    The constructor attribute causes the function to be called automatically before execution enters main (). Similarly, the destructor attribute causes the function to be called automatically after main () has completed or exit () has been called. Functions with these attributes are useful for initializing data that will be used implicitly during the execution of the program.<br>    You may provide an optional integer priority to control the order in which constructor and destructor functions are run. A constructor with a smaller priority number runs before a constructor with a larger priority number; the opposite relationship holds for destructors. So, if you have a constructor that allocates a resource and a destructor that deallocates the same resource, both functions typically have the same priority. The priorities for constructor and destructor functions are the same as those specified for namespace-scope C++ objects (see C++ Attributes).These attributes are not currently implemented for Objective-C.</p></blockquote><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ol><li><a href="https://gcc.gnu.org/onlinedocs/gcc-4.7.0/gcc/Function-Attributes.html">GNU Function Attributes</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> GNU </tag>
            
            <tag> GCC </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>国内宠物托运指南</title>
      <link href="/carry-cat/"/>
      <url>/carry-cat/</url>
      
        <content type="html"><![CDATA[<p>自从有了花花，大到出行，小到搬家，都像是带着孩子的寡妇，逢人总要问一句，“您这能托运(住)猫吗”。</p><p>这篇记录下我从杭州带着花花去北方的过程，总结下如何带着宠物旅行。</p><p><img src="/images/cat.png" alt="花花"></p><h2 id="自驾带着宠物"><a href="#自驾带着宠物" class="headerlink" title="自驾带着宠物"></a>自驾带着宠物</h2><p>这是最安全，也是最折腾的办法。唯一需要考虑的，是长达两三天的路途，宠物是否能适应用厕，饮食。当然，代价就是极其高昂的花费，包括但不限于车辆使用费，油费，住宿费等等。</p><h2 id="航空托运"><a href="#航空托运" class="headerlink" title="航空托运"></a>航空托运</h2><p>托运一只宠物，需要满足以下要求:</p><ol><li>宠物有卫生部门开具的检疫合格证明</li><li>航班存在有氧舱，且愿意接收宠物(一般大的客机里会有2-3个名额)</li></ol><h3 id="卫生部门开具检疫合格证明"><a href="#卫生部门开具检疫合格证明" class="headerlink" title="卫生部门开具检疫合格证明"></a>卫生部门开具检疫合格证明</h3><p>卫生部门开具检疫合格证明需要满足以下条件:</p><ol><li>宠物拥有免疫证</li><li>宠物按期接种狂犬疫苗</li></ol><p>免疫证如下图所示:</p><p><img src="/images/immune.jpg" alt="免疫证"></p><p>免疫证需要去政府指定的动物医院，政府指定的动物医院可以去政府网站查看，或者直接拨打当地的卫生所，也能查询到。办了免疫证后，还需要在当地接种疫苗。</p><p>有了免疫证且接种完疫苗后，就可以去当地卫生所办理检疫合格证明：</p><p><img src="/images/huahua-ok.jpg" alt="检疫合格证明"></p><p>有几个时间点需要注意：</p><ol><li>疫苗生效需要2周</li><li>检疫合格证明有效时间只有5天</li></ol><h3 id="航空公司受理"><a href="#航空公司受理" class="headerlink" title="航空公司受理"></a>航空公司受理</h3><p>买机票的时候，去航空公司官网查询哪些航班提供了有氧舱，或者直接拨打航空公司的服务热线电话也行。</p><p>我托运的是使用的国航，拨打电话后，先预定好有氧仓位，2个小时内预定机票即可。预定和成功锁定仓位后，都会有邮件通知。</p><p>需要自行打印一个预定申请书，并在登机时携带。</p><p><img src="/images/application.jpg" alt="预定申请书"></p><p>有了有氧仓位后，需要将宠物装进航空专用的宠物箱内，箱内可以放置一些水源和布料。</p><p>到了起飞那天，需要比往常提前40分钟左右到前台，带着检疫证明和预定申请书办理宠物托运。</p><p>航空公司会给箱子进行进一步处理，包括用网绳加固，打包处理等等。需要收取一定的服务费用，我记得在30左右。</p><p>宠物托运的价格，跟宠物的重量有关，国航的计价规则是体重(kg)*1.5%票面价格，我花费了200左右。</p><p>飞机到达目的地后，需要在拿去包裹的地方等待宠物。宠物属于特殊包裹，会有专人运过来，等待时间在15分钟左右。</p><p>整个过程，花花没有感觉到不适，运输前尽量少给宠物喂食。</p><h2 id="加急下的应急方案"><a href="#加急下的应急方案" class="headerlink" title="加急下的应急方案"></a>加急下的应急方案</h2><p>部分店家会提供托运服务，有高铁和航空。如果等不了2周办理免疫证的，他们也有渠道，安全性不可知，费用普遍在500左右，谨慎选择。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Kernel Module加载卸除过程分析</title>
      <link href="/linux-kernel-module/"/>
      <url>/linux-kernel-module/</url>
      
        <content type="html"><![CDATA[<h2 id="文章参考的代码信息"><a href="#文章参考的代码信息" class="headerlink" title="文章参考的代码信息"></a>文章参考的代码信息</h2><ul><li><p>内核: Linux v5.12-rc6</p></li><li><p>架构: X86</p></li></ul><h2 id="Kernel-Module的加载过程"><a href="#Kernel-Module的加载过程" class="headerlink" title="Kernel Module的加载过程"></a>Kernel Module的加载过程</h2><h3 id="读取kernel-module到内存-kernel-module-c"><a href="#读取kernel-module到内存-kernel-module-c" class="headerlink" title="读取kernel module到内存(kernel&#x2F;module.c)"></a>读取kernel module到内存(kernel&#x2F;module.c)</h3><p>内核中用于module load的系统调用有两个：finit_module和init_module。区别在于，finit_module接受的是一个fd，init_module直接从内存中复制。这两个调用是内核模块加载的入口，最终都会调用到load_module。加载过程中使用的管理结构为struct load_info，kernel module在内核内存中的地址，是通过__vmalloc申请出来的，被记录在info-&gt;hdr。</p><h3 id="检查签名是否存在"><a href="#检查签名是否存在" class="headerlink" title="检查签名是否存在"></a>检查签名是否存在</h3><ol><li><p>module_sig_check</p><p> 读取info-&gt;hdr末尾的一部分，并进行校验。检验结束后，更新info-&gt;len。</p></li><li><p>elf_validity_check</p><p> 校验ELF相关的内容</p></li></ol><h3 id="处理并加载section-setup-load-info"><a href="#处理并加载section-setup-load-info" class="headerlink" title="处理并加载section(setup_load_info)"></a>处理并加载section(setup_load_info)</h3><ol><li><p>读取modinfo section</p><p> .modinfo这个section中放入module相关的一些描述信息。通过<em>readelf -p .modinfo xxx.ko</em>可以读出相应的信息，包括version，description，author等信息。</p></li><li><p>遍历各个section，获取符号表信息(strtb和symtb)，这一过程中，需要根据info-&gt;hdr和section中的offset，计算出真正的内存地址</p></li><li><p>读取.gnu.linkonce.this_module section</p></li><li><p>尝试读取__versions section，并更新info-&gt;index.vers</p></li></ol><h3 id="查看是否是被禁止加载的模块-blacklisted"><a href="#查看是否是被禁止加载的模块-blacklisted" class="headerlink" title="查看是否是被禁止加载的模块(blacklisted)"></a>查看是否是被禁止加载的模块(blacklisted)</h3><p>读取kernel中的module blacklist，这一过程中判断的依据是info-&gt;name，如果info-&gt;name在blacklist中，则不加载该模块。</p><h3 id="更新各个section的地址"><a href="#更新各个section的地址" class="headerlink" title="更新各个section的地址"></a>更新各个section的地址</h3><p>二进制中的section记录的是内存offset，以info-&gt;hdr为基准，进行重定位。</p><p>清除vers和info相关section中的SHF_ALLOC标记，后续过程中将不会分配内存。</p><h3 id="检查module中的version信息是否存在"><a href="#检查module中的version信息是否存在" class="headerlink" title="检查module中的version信息是否存在"></a>检查module中的version信息是否存在</h3><ol><li><p>find_symbol</p><p> 从已经加载的kernel和module符号中，寻找name为module_layout的符号，并获取到相应的信息。</p></li><li><p>进行crc和version校验</p></li></ol><h3 id="根据读取到的section信息，对内存进行分配"><a href="#根据读取到的section信息，对内存进行分配" class="headerlink" title="根据读取到的section信息，对内存进行分配"></a>根据读取到的section信息，对内存进行分配</h3><ol><li><p>check_modinfo</p><p> 对vermagic进行校验，如果不是由内核本身维护的module，设置污染标记(内核会打印’loading out-of-tree module taints kernel’)</p><p> 检查module的编译信息</p><p> 检查是否有live-patch(check_modinfo_livepatch)</p><p> 设置license(set_license)</p></li><li><p>module_frob_arch_sections</p><p>这个函数设置了weak属性，允许arch层重定义该函数，X86中未找到相关定义。</p></li><li><p>module_enforce_rwx_sections</p><p> 检查各个section的flag</p></li><li><p>清除per-cpu sections标记中的SHF_ALLOC</p></li><li><p>将.data..ro_after_init标记为SHF_RO_AFTER_INIT(read only after init)</p></li><li><p>将__jump_table标记为SHF_RO_AFTER_INIT</p></li><li><p>遍历各个section，将section划分成两部分，分别是core part和init part。init part将在初始化完成后丢弃，从而节省内存。对于每个part，又细分为四类，分别是text，ro，ro_after_init，other，细分是为了后面设置内存页的权限。</p></li><li><p>设置core和init的符号表(layout_symtab)</p></li><li><p>move_module</p><p> 根据7和8获取到的core和init的信息，将需要的信息从二进制中复制到core和init中，此时获得的地址，便是最终的运行地址。这一步执行结束后，mod变量被正确赋值。</p></li></ol><h3 id="初步加载kernel-module"><a href="#初步加载kernel-module" class="headerlink" title="初步加载kernel module"></a>初步加载kernel module</h3><p>内核中管理module的结构为struct module</p><ol><li><p>初始化一个struct module，并更新状态为MODULE_STATE_UNFORMED</p></li><li><p>查看kernel中是否已经加载相关module</p></li><li><p>更新module_addr_min和module_addr_max</p></li><li><p>将struct module插入到kernel的list中，此时，该module开始被kernel识别并管理</p></li><li><p>校验签名</p></li></ol><h3 id="module运行现场的初始化"><a href="#module运行现场的初始化" class="headerlink" title="module运行现场的初始化"></a>module运行现场的初始化</h3><ol><li><p>分配内存给percpu section</p></li><li><p>初始化mod的依赖管理结构(source_list和target_list)</p></li><li><p>引用计数置为1</p></li><li><p>初始化mod-&gt;param_lock</p></li></ol><h3 id="find-module-sections"><a href="#find-module-sections" class="headerlink" title="find_module_sections"></a>find_module_sections</h3><ol><li><p>获取存有元数据的section，包括导出的符号表，crc校验参数等等</p></li><li><p>校验license和version(check_module_license_and_versions)</p></li><li><p>设置Module的描述信息(从.modinfo section中读取的内容)</p></li></ol><h3 id="simplify-symbols"><a href="#simplify-symbols" class="headerlink" title="simplify_symbols"></a>simplify_symbols</h3><p>这一步比较重要，进行符号表偏移的计算。对于SHN_UNDEF的符号，将在内核中进行查找，查找成功后，更新相应的依赖关系。对于weak属性的符号，会做进一步的检查和处理。对于除SHN_COMMON，SHN_ABS，SHN_LIVEPATCH，SHN_UNDEF之外的一般符号，依据符号的偏移以及所属section的基址，计算出符号的内存地址。</p><h3 id="section重定位"><a href="#section重定位" class="headerlink" title="section重定位"></a>section重定位</h3><ol><li><p>apply_relocations</p><p> 进行符号的重定位，有一类特殊的section，记录了对应section的relocation信息。relocation的计算分为三步：</p><ol><li>计算二进制中重定位部分的内存位置(src)</li><li>根据type，计算内存中重定位部分的内存地址(dst)</li><li>校验dst部分是否全为0，如果是，执行write(dst, src, size)</li></ol></li><li><p>post_relocation</p><ol><li>对exception table进行排序</li><li>执行符号表的拷贝工作(此时的符号表位置已经计算出来)<br> return module_finalize(info-&gt;hdr, info-&gt;sechdrs, mod);</li><li>arch相关的结束动作()</li></ol></li><li><p>刷新cache(flush_module_icache)，获取module的运行参数</p></li></ol><h3 id="开始运行module前的准备"><a href="#开始运行module前的准备" class="headerlink" title="开始运行module前的准备"></a>开始运行module前的准备</h3><ol><li><p>查看是否有重复的符号</p></li><li><p>对init和core部分的四个类别section进行内存权限设置</p></li><li><p>设置module状态为MODULE_STATE_COMING</p></li><li><p>对内核的通知链发出一个通知，此后状态为MODULE_STATE_GOING</p></li><li><p>解析参数</p></li><li><p>设置sys相关的文件(mod_sysfs_setup)</p></li></ol><h3 id="开始运行module"><a href="#开始运行module" class="headerlink" title="开始运行module"></a>开始运行module</h3><ol><li>如果注册了init，执行init函数</li><li>对内核的通知链发出一个通知，此后状态为MODULE_STATE_LIVE</li><li>mod计数减一</li><li>释放init区域</li></ol><h2 id="Kernel-Module的卸载过程"><a href="#Kernel-Module的卸载过程" class="headerlink" title="Kernel Module的卸载过程"></a>Kernel Module的卸载过程</h2><ol><li><p>检查是否有权限进行卸载</p></li><li><p>从用户参数中获取所要卸载的模块name</p></li><li><p>根据name寻找相应的module结构(find_module)</p></li><li><p>检查是否有其他模块依赖待卸载模块</p></li><li><p>执行module的exit函数</p></li><li><p>释放module占据的资源，更新内核的管理数据</p></li></ol><h2 id="相关Q-A"><a href="#相关Q-A" class="headerlink" title="相关Q&amp;A"></a>相关Q&amp;A</h2><ol><li><p>data段和bss段的区别</p><p> bss段由于不存在初始化值，在二进制中不需要分配位置存储，因此bss变量不会造成二进制变大。但是，在进行二进制加载时，会分配相应的内存。在符号表中，尽管bss段在二进制本身中不占据位置，但是在运行内存中占据了位置，因此偏移计算时，是将bss段作为有size进行处理的(因为符号表是描述运行内存布局的)。</p></li><li><p>是否可以将某些section单独管理</p><p> 原理上是可行的，我尝试过将bss和data单独分离出来。需要考虑的几个点:</p><ol><li>修改符号表的偏移，偏移是重定向的依据。</li><li>如果原有地址存在数据，重定向对0值的校验会失败。</li></ol></li><li><p>kernel module为何要export符号，才能被其他模块使用</p><p> export出来的符号会单独放在一个section中，module本身的符号表对内核其他部分是不可见的。但是，module跟内核其他部分是在一个地址空间里的，缺少的只是内存布局信息(也就是符号表)。</p></li><li><p>符号表中Global和Local的区别</p><p> 广义上的全局变量，是指生存周期为全局的变量，在符号表中出现的变量，代表运行内存中为该变量分配了位置，因此符号表中出现的变量，其生存周期都是全局的，都可以认为是广义上的全局变量。符号表中的Global和Local的区别在于，作用域不一样，Global对整个模块都是可见的，而Local只有一个局部作用域(文件内或者函数内)。这个作用域的检查是在编译时进行的，也就是说，如果能拿到正确的地址，即使不符合作用域，也能正常使用。</p></li><li><p>二进制运行过程中的内存管理</p><p> 此处以变量举例，来说明运行模块对内存的使用。第一类是广义上的全局变量，此类变量从二进制加载到二进制结束运行，一直存在内存中。第二类是函数内的局部变量，这部分是放置在栈中的。随着函数的运行，生成和销毁。第三类，就是程序在运行过程中，通过malloc之类的管理接口申请的内存，这类内存需要程序自行释放，否则会造成内存泄露。</p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://man7.org/linux/man-pages/man5/elf.5.html">elf header</a></li><li>深入Linux设备驱动内核机制(陈学松著)第一章</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Kernel Module </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NVDIA Steam初体验</title>
      <link href="/nvdia-stream/"/>
      <url>/nvdia-stream/</url>
      
        <content type="html"><![CDATA[<p>手头有台闲置的笔记本，一直在运行Linux。笔记本上有张GTX 970M的显卡，想着能不能拿来玩游戏(Apex)。问题在于：</p><ol><li>Apex不支持在Linux下运行，即使是借助wine的<a href="https://lutris.net/">lutris</a>。因此，只能考虑在一台笔记本上，同时运行Linux和windows。</li><li>因为要运行Linux，希望能把笔记本一直放在杂物间里，避免搬来搬去。</li></ol><p>对于第一个问题，有两个解决办法：</p><ol><li>使用虚拟机，如果要在虚拟机中使用显卡来获得较好的性能，可以考虑设备直通。支持这一用法的有ESIX。</li><li>使用双系统，通过grub来解决系统间的切换。</li></ol><h2 id="同时运行Windows和Linux"><a href="#同时运行Windows和Linux" class="headerlink" title="同时运行Windows和Linux"></a>同时运行Windows和Linux</h2><h3 id="使用EXSI通过设备直通来同时使用Windows和Linux"><a href="#使用EXSI通过设备直通来同时使用Windows和Linux" class="headerlink" title="使用EXSI通过设备直通来同时使用Windows和Linux"></a>使用EXSI通过设备直通来同时使用Windows和Linux</h3><p>安装EXSI的过程中，遇到无法找到网卡设备的问题。最后发现是ESXI内置支持的网卡驱动比较少，下载了一个别人改造过的版本，顺利安装。悲剧的是，我发现虽然GTX 970M支持设备直通，但是笔记本的bios不支持这一用法。</p><h3 id="使用双系统来同时使用Windows和Linux"><a href="#使用双系统来同时使用Windows和Linux" class="headerlink" title="使用双系统来同时使用Windows和Linux"></a>使用双系统来同时使用Windows和Linux</h3><p>双系统的使用过程不多赘述，要点如下:</p><ol><li>先安装Windows，再安装Linux</li><li>分区设置，将引导默认由Linux中的grub管理</li></ol><p>因为grub可以识别Windows启动项，但是Windows不能识别Linux启动项(至少我没发现办法)。</p><p>这样做有一个局限，就是没法同时运行Linux和Windows，考虑到使用Windows的场景并不多，偶尔拿来打游戏还是能接受的。同时，还有另外一个问题。那就是如何在不去现场操作笔记本的情况下，能在双系统间进行切换？</p><p>解决的要点如下：</p><ol><li>分别设置Windows和Linux的网卡成静态IP，同时分别打开远程桌面和sshd，保证重启后，能登录到笔记本里。</li><li>Linux下可以直接操作grub，修改默认启动项，在Linux下，将grub默认设置为Windows，然后重启；在Windows下，将grub默认设置为Linux，然后重启。</li></ol><p>关于如何在Windows下操作grub：</p><p>Windows下首先找到grub相应的引导分区，直接修改grub.cfg即可。</p><h2 id="通过NVDIA-Stream来玩游戏"><a href="#通过NVDIA-Stream来玩游戏" class="headerlink" title="通过NVDIA Stream来玩游戏"></a>通过NVDIA Stream来玩游戏</h2><p>云游戏的概念很早就出现了，毕竟，只要是使用过远程桌面，就会很自然的想到，能不能远程使用应用，尤其是游戏。当前能找到的云游戏的解决方案很多，腾讯更是几年前就推出过堡垒之夜的云端试玩。我选择了NVDIA Stream，是因为使用起来相对简单，而且我使用的是N卡，如果电脑要支持云游戏，那么我觉得显卡驱动这一层来支持是最好的。</p><p>使用NVDIA Sream过程中，遇到一些问题：</p><ol><li>NVDIA Get Experience存在网络问题</li></ol><p>一开始是无法登陆，后来是登陆了无法跳转，最后通过某加速器加速NVDIA Get Experience解决问题。</p><ol start="2"><li>远程桌面下，无法打开NVDIA Stream</li></ol><p>这个问题，我折腾了最久。后来用了命令行版的NVDIA Stream，发现是远程桌面下不能支持NVDIA Steam。可以使用vnc之类的软件来解决。当然，也可以一次设置好，下次直接让NVDIA Stream自动启动就好。注意，只要使用过远程桌面，就会导致NVDIA Steam失效。</p><ol start="3"><li>游戏运行前，需要首先运行加速器</li></ol><p>这个问题，我暂时是手动运行解决的。我觉得，可以尝试将加速器也添加到NVDIA Steam的game list中，先运行加速器，再运行游戏，应该也是，没问题的。</p><h2 id="使用体验"><a href="#使用体验" class="headerlink" title="使用体验"></a>使用体验</h2><p>我的测试环境是千兆无线网络，基本感觉不到延迟，偶尔有网络波动，通过有线网络应该可以获得更好的游戏体验。更难得的是，moonlight不仅支持在电脑上玩云游戏，在手机上也可以运行云游戏。可以预见，云游戏在不久的未来，会越来越流行。</p>]]></content>
      
      
      
        <tags>
            
            <tag> NVDIA </tag>
            
            <tag> Cloud Game </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>About Author</title>
      <link href="/about/"/>
      <url>/about/</url>
      
        <content type="html"><![CDATA[<h4 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h4><p>My interests include:</p><ul><li>operating system, mainly about linux</li><li>ELF&#x2F;linker</li><li>livepatch</li><li>network</li></ul><h4 id="Project"><a href="#Project" class="headerlink" title="Project"></a>Project</h4><ul><li><a href="https://github.com/anatasluo/ant">ant</a></li></ul><h4 id="Patch"><a href="#Patch" class="headerlink" title="Patch"></a>Patch</h4><h5 id="OPTIMIZATION"><a href="#OPTIMIZATION" class="headerlink" title="OPTIMIZATION"></a>OPTIMIZATION</h5><ul><li><a href="https://lkml.org/lkml/2020/12/15/486">linux-x86(in debate)</a></li></ul><h5 id="IMPLEMENTATION"><a href="#IMPLEMENTATION" class="headerlink" title="IMPLEMENTATION"></a>IMPLEMENTATION</h5><ul><li><a href="https://github.com/landley/toybox/commit/896fa846b1ec8cd4895f6320b56942f129e54bc9">toybox-ping</a></li><li><a href="https://github.com/dynup/kpatch/commit/6a0dcb0da8e2960559afc33ecefc22ce39e49e2b">kpatch-openEuler</a></li></ul><h5 id="DOCUMENT"><a href="#DOCUMENT" class="headerlink" title="DOCUMENT"></a>DOCUMENT</h5><ul><li><a href="https://github.com/bootlin/elixir/commit/514fa38ed8eced5bea900ef3748cd82d2306043b">elixir-selinux</a></li></ul><h5 id="BUG-FIX"><a href="#BUG-FIX" class="headerlink" title="BUG FIX"></a>BUG FIX</h5><ul><li><a href="https://github.com/apache/incubator-nuttx/commit/ab37b149729639fc96a9987f711d18f5286c5541">nuttx-vfs</a></li><li><a href="https://github.com/checkpoint-restore/criu/commit/e0da8b895ede46e197e9813dc87b55f4b1a7e93c">criu-asm</a></li><li><a href="https://github.com/checkpoint-restore/criu/commit/2cb1156e6afba4baeab5b945b0c15036af3b3a8c">criu-arch</a></li><li><a href="https://github.com/checkpoint-restore/criu/commit/d203b57357e68447964cad6b6542ebefda832504">criu-smaps</a></li><li><a href="https://github.com/openssh/openssh-portable/commit/1050109b4b2884bf50fd1b3aa084c7fd0a42ae90">openssh-log</a></li><li><a href="https://lore.kernel.org/linux-fsdevel/685386c2840b76c49b060bf7dcea1fefacf18176.1614322182.git.luolongjun@huawei.com/">linux-fs</a></li><li><a href="https://sourceware.org/pipermail/binutils/2021-April/116183.html">readelf-section</a></li><li><a href="https://github.com/dynup/kpatch/pull/1301">kpatch-rela</a></li><li><a href="https://github.com/dynup/kpatch/pull/1303">kpatch-rela2</a></li><li><a href="https://www.spinics.net/lists/kernel/msg4516532.html">linux-uprobe(in debate)</a></li><li><a href="https://lore.kernel.org/lkml/eb310620-3913-b673-d35a-cc7d50a74610@huawei.com/T/">linux-uprobe(in debate)</a></li><li><a href="https://gcc.gnu.org/pipermail/gcc-patches/2022-December/607605.html">gcc-LINE macro</a></li></ul><h4 id="MATERIAL-SHARE"><a href="#MATERIAL-SHARE" class="headerlink" title="MATERIAL SHARE"></a>MATERIAL SHARE</h4><ul><li><a href="https://anatasluo.github.io/pdf/quic.pdf">QUIC protocol</a></li><li><a href="https://fosdem.org/2022/schedule/event/security_seamless_kernel/">FOSDEM 2022 - Seamless Kernel Update</a></li><li><a href="https://fosdem.org/2022/schedule/event/security_seamless_kernel/attachments/slides/5061/export/events/attachments/security_seamless_kernel/slides/5061/Seamless_Kernel_Update.pdf">FOSDEM 2022 - Seamless Kernel Update - PDF</a></li><li><a href="https://www.accelevents.com/e/osseu2022/portal/schedule/271452">LinuxCon Europe 2022 - Livepatch in Userspace Based on Uprobe</a></li><li><a href="https://static.sched.com/hosted_files/osseu2022/19/OSS-EU22-Livepatch-in-Userspace.pdf">LinuxCon Europe 2022 - Livepatch in Userspace Based on Uprobe - PDF</a></li></ul><h4 id="RECENT-CHECKLIST"><a href="#RECENT-CHECKLIST" class="headerlink" title="RECENT CHECKLIST"></a>RECENT CHECKLIST</h4><p>MOOC:</p><ul><li><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-172-performance-engineering-of-software-systems-fall-2018/lecture-videos/">MIT 6-172</a></li></ul><p>Blog:</p><ul><li><a href="https://www.airs.com/blog/archives/38">Link History</a></li></ul><p>Document:</p><ul><li><a href="https://sourceware.org/binutils/docs/ld/index.html#SEC_Contents">GNU Link Script Example</a></li><li><a href="https://www.cs.cmu.edu/afs/cs/academic/class/15213-f00/docs/elf.pdf">CMU ELF Document</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>initrd, initramfs, rootfs</title>
      <link href="/initrd-initramfs-rootfs/"/>
      <url>/initrd-initramfs-rootfs/</url>
      
        <content type="html"><![CDATA[<p>这篇博客主要阐述initrd，initramfs，rootfs之间的关系，内容主要总结自Linux(5.12)源码中的文档&#x2F;Documentation&#x2F;filesystems&#x2F;ramfs-rootfs-initramfs.rst</p><h2 id="ramfs"><a href="#ramfs" class="headerlink" title="ramfs"></a>ramfs</h2><p>ramfs，就如名字所表示的那样，这是基于内存的文件系统。</p><h2 id="ramfs-and-ramdisk"><a href="#ramfs-and-ramdisk" class="headerlink" title="ramfs and ramdisk"></a>ramfs and ramdisk</h2><p>ram disk是早期Linux使用的一种机制，使用内存来模拟一个块设备，并将这个块设备挂载为文件系统。这一机制的优势在于，使用内存完全模拟了一个存储设备的行为。但是缺点也特别明显。首先是，文件系统的大小是固定的。其次是，在此类文件系统的操作过程中，存在不必要的内存拷贝行为。最严重的是，这个文件系统需要相关的驱动进行挂载和解释。</p><h2 id="ramfs-and-tmpfs"><a href="#ramfs-and-tmpfs" class="headerlink" title="ramfs and tmpfs"></a>ramfs and tmpfs</h2><p>ramfs的一个缺点就是，ramfs会一直写入内存，直到没有内存可以使用。</p><p>tmpfs是ramfs中的一种，tmpfs的优势在于：tmpfs增加了大小的限制；允许将数据写入到交换区；普通用户也能写入tmpfs的挂载点。</p><h2 id="rootfs"><a href="#rootfs" class="headerlink" title="rootfs"></a>rootfs</h2><p>rootfs是一种特殊的ramfs实例，rootfs自2.6之后便一直存在。rootfs是无法卸载的，就像init进程无法被kill一样。大部分系统会直接通过rootfs挂载其他文件系统。如果CONFIG_TMPFS被开启，那么rootfs将使用tmpfs，而不是ramfs。如果要强制使用ramfs，就在cmdline中加入”rootfstype&#x3D;ramfs”。</p><h2 id="initramfs"><a href="#initramfs" class="headerlink" title="initramfs"></a>initramfs</h2><p>从2.6内核开始，内核都包含一个压缩的cpio文件，在内核启动的时候，这个文件会被解压成rootfs。解压之后，内核会去检查根目录下是否存在init文件，如果存在，就作为1号进程执行。这个进程负责系统剩余的拉起工作，包括寻找并挂载真正根文件设备。如果init不存在，内核会使用以前的方式，首先找到一个root分区，然后寻找类似&#x2F;sbin&#x2F;init作为init进程。</p><p>initramfs和旧的initrd区别在于：</p><ol><li>initrd总是一个单独的文件，而initramfs可以被链接到kernel镜像中(initramfs总是存在的，initrd不是必须的)</li><li>initrd是特定的一个文件系统，比如ext2，因此需要kernel有相应的驱动。initramfs是一个压缩的cpio文件，解压十分容易。这部分解压代码在kernel启动之后，会被丢弃掉</li><li>initrd做完准备工作后，会返回kernel继续运行。initramfs一般不会返回，但是init可以挂载新的root设备，然后执行另一个init程序</li><li>当进行root设备切换时，initrd会进行pivot_root，然后卸载ramdisk。但是initramfs是rootfs，我们可以pivot_root rootfs，也可以进行卸载。相比于删掉rootfs来释放空间，initramfs可以挂载新的root，然后执行其他的init程序</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Initrd </tag>
            
            <tag> Initramfs </tag>
            
            <tag> rootfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下如何执行buffer中的一段代码</title>
      <link href="/linux-execute-buffer/"/>
      <url>/linux-execute-buffer/</url>
      
        <content type="html"><![CDATA[<p>linux中，存在一个系统调用mprotect，可以修改一段内存的权限信息，一般情况下，数据段是不可以执行的，通过mprotect，可以赋予数据段以执行权限，再将一段逻辑实现拷贝到该数据段中，通过函数指针跳转，从而执行该数据段中的代码，以下为实现部分:</p><p>两个源码文件，分别为main.c和test.S</p><p>test.S的内容为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.code64</span><br><span class="line">.align 0x1000</span><br><span class="line">.text</span><br><span class="line">.global test</span><br><span class="line">.type test, @function</span><br><span class="line"></span><br><span class="line">test:</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    movl    $22, %eax</span><br><span class="line">    popq    %rbp</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>main.c的内容为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line"></span><br><span class="line">int test(void);</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int ret;</span><br><span class="line">    int (*p)(void);</span><br><span class="line">    void *code;</span><br><span class="line"></span><br><span class="line">    code = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);</span><br><span class="line">    if (code == MAP_FAILED) &#123;</span><br><span class="line">        printf(&quot;mmap failed, errno is %d \n&quot;, errno);</span><br><span class="line">        return -errno;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = mprotect(code, 0x1000, PROT_EXEC | PROT_WRITE);</span><br><span class="line">    if (ret == -1) &#123;</span><br><span class="line">        printf(&quot;mprotect failed, errno is %d \n&quot;, errno);</span><br><span class="line">        return -errno;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = test();</span><br><span class="line">    if (ret != 22)</span><br><span class="line">        return -EINVAL;</span><br><span class="line">    puts(&quot;execute assembly successfully&quot;);</span><br><span class="line"></span><br><span class="line">    memcpy(code, test, 0x1000);</span><br><span class="line"></span><br><span class="line">    p = code;</span><br><span class="line">    ret = p();</span><br><span class="line">    if (ret != 22)</span><br><span class="line">        return -EINVAL;</span><br><span class="line">    puts(&quot;execute buffer successfully, end here&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译用的cmake文件为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.16)</span><br><span class="line">project(ACM C ASM)</span><br><span class="line">set(CMAKE_C_STANDARD 99)</span><br><span class="line">set_source_files_properties(test.S PROPERTIES COMPILE_FLAGS &quot;-x assembler-with-cpp&quot;)</span><br><span class="line">add_executable(ACM main.c test.S)</span><br></pre></td></tr></table></figure><p>运行结果如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">execute assembly successfully</span><br><span class="line">execute buffer successfully, end here</span><br></pre></td></tr></table></figure><p>gdb调试可以加入以下指令，进行查看:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">display /20i $pc</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Memory </tag>
            
            <tag> Assembly Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>X86-64下关闭MMU</title>
      <link href="/x86-64-mmu/"/>
      <url>/x86-64-mmu/</url>
      
        <content type="html"><![CDATA[<h2 id="kexec-X86-64下的执行过程"><a href="#kexec-X86-64下的执行过程" class="headerlink" title="kexec X86-64下的执行过程"></a>kexec X86-64下的执行过程</h2><p>kexec的代码是有两部分的，一部分在Linux内核中(编译时需要打开相关的编译选项)，一部分在<a href="https://github.com/horms/kexec-tools">kexec-tools</a>中。</p><p>kexec的流程主要分为两个部分，首先是内核加载，通过以下命令实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmdline=$(cat /proc/cmdline)</span><br><span class="line">kexec -l /boot/vmlinuz-linux-lts --initrd=/boot/initramfs-linux-lts.img --append=&quot;$cmdline&quot;</span><br></pre></td></tr></table></figure><p>-l指定了kernel的路径，–initrd指定了根文件系统路径，–append指定了cmdline参数</p><p>接着是开始内核切换，通过以下命令实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kexec -e</span><br></pre></td></tr></table></figure><p>内核的执行入口为&#x2F;kernel&#x2F;kexec_core.c的kernel_kexec函数，详细过程如下:</p><ol><li>通过migrate_to_reboot_cpu将kexec的执行主体迁移到主核</li><li>通过machine_shutdown发送IPI中断来关闭所有从核，从核最终会执行stop_this_cpu使cpu进入hlt状态</li><li>通过machine_kexec使主核继续进行后续的流程</li></ol><p>machine_kexec相关的逻辑实现位于&#x2F;arch&#x2F;x86&#x2F;kernel&#x2F;machine_kexec_64.c，详细过程如下:</p><ol><li>进行关中断，清除断点之类的环境准备工作</li><li>将relocate_kernel函数的实现拷贝到过渡区域(关于过渡区域的说明，见下文)</li><li>设置段寄存器，gdt表和idt表为无效状态(long mode下内存访问不涉及段机制)</li><li>跳转进入relocate_kernel</li></ol><p>relocate_kernel的实现是一段汇编，位于&#x2F;arch&#x2F;x86&#x2F;kernel&#x2F;relocate_kernel_64.S，relocate_kernel接受五个参数，比较重要的是两个，是一致性映射的pgt页表地址，以及处于一致性映射区域的入口地址，至于什么是一致性映射，以及如何实现一致性映射和如何使用一致性映射，见下文部分。</p><p>需要注意的是，这个一致性映射区域的入口不是新内核，而是kexec-tools里面的一段汇编，这段汇编位于kexec-tools源码下的&#x2F;purgatory&#x2F;arch&#x2F;x86_64&#x2F;setup-x86_64.S，入口为purgatory_start(至于如何判定入口为purgatory_start，见参考2)。</p><p>这段逻辑最后会跳转到新内核的入口中执行，从relocate_kernel开始的汇编，直到跳转到新内核入口前，主核所做的事情主要是退出long mode，关闭mmu，设置gdt表，进入protection mode，详细过程见下文。</p><h2 id="X86-64的CPU模式"><a href="#X86-64的CPU模式" class="headerlink" title="X86-64的CPU模式"></a>X86-64的CPU模式</h2><p>X86-64下CPU有以下几种模式:</p><ul><li>Long Mode<ul><li>64-bit mode(Long mode下的一种子模式，系统正常运行的模式)</li><li>Compatibility mode(Long mode下的一种子模式，可运行32位程序)</li></ul></li><li>Legacy Mode<ul><li>Protected Mode(32位程序运行时的一般模式)</li><li>Virtual-8086 Mode</li><li>Real Mode(16位程序运行时的一般模式)</li></ul></li><li>System Management Mode (SMM，系统管理模式，由外设触发)</li></ul><p>模式之间的转换关系，见下图(来自AMD64 Architecture Programmer’s Manual Volume 2:System Programming):</p><p><img src="/images/cpu-mode.png" alt="X86-64下CPU模式转换"></p><h2 id="X86-64下的内存访问机制"><a href="#X86-64下的内存访问机制" class="headerlink" title="X86-64下的内存访问机制"></a>X86-64下的内存访问机制</h2><p>X86-64下内存机制有两个:</p><ol><li>段机制</li><li>页机制</li></ol><p>一般情况下，段机制会首先对地址进行转换，其次才是页机制。相对应的，在不同阶段，内存地址有着不同的名称，分别为:</p><ol><li>Logical Addresses(虚拟地址)</li><li>Linear(Virtual) Addresses(线性地址)</li><li>Physical Addresses(物理地址)</li></ol><p>Logical Addresses经过段机制的作用，变成Linear Addresses，Linear Addresses经过页机制的作用，变成Physical Addresses。</p><p>内存地址，是一个相对偏移，在不同的坐标系中，同一个内存地址有着不同的偏移值。比较特殊的是物理地址(Physical Addresses)，可以认为是绝对地址(通用地址)。</p><p>需要说明的是，段机制在64-bit mode下是没有发挥作用的，因此64-bit运行的一般情况下，虚拟地址就是线性地址。</p><p>段机制和页机制的本质，都是对内存在不同坐标系之间进行了映射，如果这种映射是一对一的，即映射前后，没有发生变化，这种内存模式被称之为flat mode，一般用于关闭某种内存机制前后进行过渡。</p><h3 id="段机制"><a href="#段机制" class="headerlink" title="段机制"></a>段机制</h3><p>段机制发挥作用，需要gdt(idt)表和段寄存器同时发挥作用，段寄存器指向gdt(idt)表中的某一项。gdt(idt)表的切换，通过lgdt(lidt)实现，lgdt(lidt)接受一个十字节的元数据，前两个字节描述表的大小，后八个字节描述表的虚拟地址。gdt(idt)表中的每一项，描述了段的基础地址，段大小，权限信息和控制信息。</p><p>以下是一种gdt表的书写技巧，gdt表的第一项通常不用，空出第二项，两项共16个字节，前10个字节用于放置gdt表的元数据，即gdt表中放置了gdt表的描述信息(该表实现了上文所说的flat mode):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.balign16</span><br><span class="line">.globl tr_gdt</span><br><span class="line">tr_gdt:</span><br><span class="line">.shorttr_gdt_end - tr_gdt - 1# gdt limit</span><br><span class="line">.longpa_tr_gdt</span><br><span class="line">.short0</span><br><span class="line">.quad0x00cf9b000000ffff# __KERNEL32_CS</span><br><span class="line">.quad0x00af9b000000ffff# __KERNEL_CS</span><br><span class="line">.quad0x00cf93000000ffff# __KERNEL_DS</span><br><span class="line">tr_gdt_end:</span><br></pre></td></tr></table></figure><p>当执行完lgdt(lidt)，还需要进一步刷新段寄存器，除CS段寄存器外，都可以通过以下方式实现:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov 0x18, %ds</span><br></pre></td></tr></table></figure><p>CS段寄存器需要通过far jmp实现，需要注意的是，每个段寄存器都存在一个不可见的缓存，只有段寄存器被改变时，才会从最新的gdt(idt)表中刷新缓存，也就是说，如果只是改变了gdt(idt)表，发挥作用的仍然是原有的段表，一般情况下，在段表被刷新后，就应该及时刷新段寄存器，以防止后续进行刷新时，段表地址不可用。</p><p>far jmp的实现，有三种方式，分别为:</p><ul><li>lret</li><li>lcall</li><li>ljmp</li></ul><p>以下是一种lret的示例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">leaqstack_init(%rip), %rsp</span><br><span class="line">pushq$0x10 /* CS */</span><br><span class="line">leaqnew_cs_exit(%rip), %rax</span><br><span class="line">pushq%rax</span><br><span class="line">lretq</span><br></pre></td></tr></table></figure><h3 id="页机制"><a href="#页机制" class="headerlink" title="页机制"></a>页机制</h3><p>页机制借助pgt表实现，pgt表中存在了多重映射关系，pgt表的切换通过以下方式实现:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movq%r9, %cr3</span><br></pre></td></tr></table></figure><p>其中r9寄存器存放了新pgt表的物理地址。</p><h2 id="如何关闭MMU"><a href="#如何关闭MMU" class="headerlink" title="如何关闭MMU"></a>如何关闭MMU</h2><p>所谓关闭MMU，即无效化页机制，直接使用物理地址访问内存。关闭MMU，仅需要一条指令即可实现。问题在于，在该指令之前，页机制生效，在该指令之后，页机制不生效，但是，PC的值是连续自增的，因此需要在一致性映射区域中关闭MMU。在一致性映射中，虚拟地址和物理地址相等，此时关闭MMU，不会影响PC的自增。</p><p>正常系统运行时，使用的不是一致性映射，同理，从原有的页表切换到一致性映射页表，也需要一个过渡区域。在该过渡区域中，既存在部分以前页表的映射关系(页表切换前后的指令所在函数)，也要存在一致性映射区域。</p><p>设计上，可以直接在一致性映射页表的基础上，加上原有页表的一段映射。一致性映射的添加，Linux内核通过kernel_ident_mapping_init实现，kexec中相关实现位于&#x2F;arch&#x2F;x86&#x2F;kernel&#x2F;machine_kexec_64.c中的init_pgtable函数。</p><p>因此，关闭MMU过程中，需要经历以下过程:</p><ol><li>跳转到过渡区域</li><li>在过渡区域中切换一致性映射页表，并跳转到一致性映射区域</li><li>在一致性映射区域关闭MMU</li></ol><h2 id="如何在X86-64下关闭MMU"><a href="#如何在X86-64下关闭MMU" class="headerlink" title="如何在X86-64下关闭MMU"></a>如何在X86-64下关闭MMU</h2><p>X86-64的正常运行模式为64 bit mode，该模式下不能直接关闭MMU。按照手册的描述，Long mode下关闭MMU，需要经过以下过程:</p><ol><li>进入一致性映射区域(参考上文说明)</li><li>设置段机制为flat mode，并且刷新段寄存器</li><li>通过far jmp切换cpu mode为Compatibility mode</li><li>关闭MMU</li><li>退出long mode(此时进入protection mode)</li><li>关闭PAE</li></ol><p>进入一致性映射区域可以参考kexec的relocate_kernel，后续流程参考kexec-tools的purgatory_start。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://segmentfault.com/a/1190000016433947">符号的重定位</a></li><li><a href="https://eastrivervillage.com/kexec-tools-with-the-hidden-purgatory/">A travel to the purgatory</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> X86 </tag>
            
            <tag> AMD </tag>
            
            <tag> Kexec </tag>
            
            <tag> Long mode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[note]高效程序员的45个习惯</title>
      <link href="/note-skills-programmer/"/>
      <url>/note-skills-programmer/</url>
      
        <content type="html"><![CDATA[<p><em>高效程序员的45个习惯</em>(Venkat Subramaniam&#x2F;Andy Hunt)(人民邮电出版社)的读书笔记。</p><h2 id="比较重要的一些法则总结"><a href="#比较重要的一些法则总结" class="headerlink" title="比较重要的一些法则总结"></a>比较重要的一些法则总结</h2><ul><li>对事不对人，集中精力解决问题</li><li>重结果胜于重过程</li><li>消除误解</li><li>解决深层次的问题</li><li>经过充分讨论后，应该专注于执行</li><li>行动优于抱怨</li><li>迭代和增量式的学习</li><li>评估新技术的优势，而不是盲目追求</li><li>避免成为团队中最优秀的成员</li><li>摆脱不合时宜的习惯</li><li>设计指导实现，但是设计不宜过于详细</li><li>保持谨慎，保证工程的可持续运行</li><li>提早集成，频繁集成</li><li>追求真实的估计</li><li>重视用户的抱怨</li><li>避免过早的优化</li><li>对于派生类的要求 – 不要求更多，不承诺更少</li><li>告知用户通用的错误信息并且记录日志</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Programmer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中全局对象的初始化</title>
      <link href="/c-object-init/"/>
      <url>/c-object-init/</url>
      
        <content type="html"><![CDATA[<h2 id="全局对象初始化"><a href="#全局对象初始化" class="headerlink" title="全局对象初始化"></a>全局对象初始化</h2><p>查看如下C++代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">    int val;</span><br><span class="line">    A() &#123;</span><br><span class="line">        printf(&quot;construct ok \n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A g_al;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的运行结果是对象A的构造函数被调用，串口输出”construct ok”。根据全局对象的初始化规则，这个调用是发生在main函数之前的，而且可以是多个函数依次调用。那么，这种调用时如何实现的？</p><p>通过gcc生成arm64汇编，汇编代码如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">.arch armv8-a</span><br><span class="line">.file&quot;main.cpp&quot;</span><br><span class="line">.text</span><br><span class="line">.section.rodata</span><br><span class="line">.align3</span><br><span class="line">.LC0:</span><br><span class="line">.string&quot;construct ok &quot;</span><br><span class="line">.section.text._ZN1AC2Ev,&quot;axG&quot;,@progbits,_ZN1AC5Ev,comdat</span><br><span class="line">.align2</span><br><span class="line">.weak_ZN1AC2Ev</span><br><span class="line">.type_ZN1AC2Ev, %function</span><br><span class="line">_ZN1AC2Ev:</span><br><span class="line">.LFB1:</span><br><span class="line">.cfi_startproc</span><br><span class="line">stpx29, x30, [sp, -32]!</span><br><span class="line">.cfi_def_cfa_offset 32</span><br><span class="line">.cfi_offset 29, -32</span><br><span class="line">.cfi_offset 30, -24</span><br><span class="line">addx29, sp, 0</span><br><span class="line">.cfi_def_cfa_register 29</span><br><span class="line">strx0, [x29, 24]</span><br><span class="line">adrpx0, .LC0</span><br><span class="line">addx0, x0, :lo12:.LC0</span><br><span class="line">blputs</span><br><span class="line">nop</span><br><span class="line">ldpx29, x30, [sp], 32</span><br><span class="line">.cfi_restore 30</span><br><span class="line">.cfi_restore 29</span><br><span class="line">.cfi_def_cfa 31, 0</span><br><span class="line">ret</span><br><span class="line">.cfi_endproc</span><br><span class="line">.LFE1:</span><br><span class="line">.size_ZN1AC2Ev, .-_ZN1AC2Ev</span><br><span class="line">.weak_ZN1AC1Ev</span><br><span class="line">.set_ZN1AC1Ev,_ZN1AC2Ev</span><br><span class="line">.globalg_al</span><br><span class="line">.bss</span><br><span class="line">.align3</span><br><span class="line">.typeg_al, %object</span><br><span class="line">.sizeg_al, 4</span><br><span class="line">g_al:</span><br><span class="line">.zero4</span><br><span class="line">.text</span><br><span class="line">.align2</span><br><span class="line">.globalmain</span><br><span class="line">.typemain, %function</span><br><span class="line">main:</span><br><span class="line">.LFB3:</span><br><span class="line">.cfi_startproc</span><br><span class="line">movw0, 0</span><br><span class="line">ret</span><br><span class="line">.cfi_endproc</span><br><span class="line">.LFE3:</span><br><span class="line">.sizemain, .-main</span><br><span class="line">.align2</span><br><span class="line">.type_Z41__static_initialization_and_destruction_0ii, %function</span><br><span class="line">_Z41__static_initialization_and_destruction_0ii:</span><br><span class="line">.LFB4:</span><br><span class="line">.cfi_startproc</span><br><span class="line">stpx29, x30, [sp, -32]!</span><br><span class="line">.cfi_def_cfa_offset 32</span><br><span class="line">.cfi_offset 29, -32</span><br><span class="line">.cfi_offset 30, -24</span><br><span class="line">addx29, sp, 0</span><br><span class="line">.cfi_def_cfa_register 29</span><br><span class="line">strw0, [x29, 28]</span><br><span class="line">strw1, [x29, 24]</span><br><span class="line">ldrw0, [x29, 28]</span><br><span class="line">cmpw0, 1</span><br><span class="line">bne.L6</span><br><span class="line">ldrw1, [x29, 24]</span><br><span class="line">movw0, 65535</span><br><span class="line">cmpw1, w0</span><br><span class="line">bne.L6</span><br><span class="line">adrpx0, g_al</span><br><span class="line">addx0, x0, :lo12:g_al</span><br><span class="line">bl_ZN1AC1Ev</span><br><span class="line">.L6:</span><br><span class="line">nop</span><br><span class="line">ldpx29, x30, [sp], 32</span><br><span class="line">.cfi_restore 30</span><br><span class="line">.cfi_restore 29</span><br><span class="line">.cfi_def_cfa 31, 0</span><br><span class="line">ret</span><br><span class="line">.cfi_endproc</span><br><span class="line">.LFE4:</span><br><span class="line">.size_Z41__static_initialization_and_destruction_0ii, .-_Z41__static_initialization_and_destruction_0ii</span><br><span class="line">.align2</span><br><span class="line">.type_GLOBAL__sub_I_g_al, %function</span><br><span class="line">_GLOBAL__sub_I_g_al:</span><br><span class="line">.LFB5:</span><br><span class="line">.cfi_startproc</span><br><span class="line">stpx29, x30, [sp, -16]!</span><br><span class="line">.cfi_def_cfa_offset 16</span><br><span class="line">.cfi_offset 29, -16</span><br><span class="line">.cfi_offset 30, -8</span><br><span class="line">addx29, sp, 0</span><br><span class="line">.cfi_def_cfa_register 29</span><br><span class="line">movw1, 65535</span><br><span class="line">movw0, 1</span><br><span class="line">bl_Z41__static_initialization_and_destruction_0ii</span><br><span class="line">ldpx29, x30, [sp], 16</span><br><span class="line">.cfi_restore 30</span><br><span class="line">.cfi_restore 29</span><br><span class="line">.cfi_def_cfa 31, 0</span><br><span class="line">ret</span><br><span class="line">.cfi_endproc</span><br><span class="line">.LFE5:</span><br><span class="line">.size_GLOBAL__sub_I_g_al, .-_GLOBAL__sub_I_g_al</span><br><span class="line">.section.init_array,&quot;aw&quot;,%init_array</span><br><span class="line">.align3</span><br><span class="line">.xword_GLOBAL__sub_I_g_al</span><br><span class="line">.ident&quot;GCC: (Ubuntu/Linaro 7.5.0-3ubuntu1~18.04) 7.5.0&quot;</span><br><span class="line">.section.note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure><p>关键的汇编代码是以下几部分；</p><p>构造函数的具体实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">.LC0:</span><br><span class="line">.string&quot;construct ok &quot;</span><br><span class="line">.section.text._ZN1AC2Ev,&quot;axG&quot;,@progbits,_ZN1AC5Ev,comdat</span><br><span class="line">.align2</span><br><span class="line">.weak.</span><br><span class="line">.type_ZN1AC2Ev, %function</span><br><span class="line">_ZN1AC2Ev:</span><br><span class="line">.LFB1:</span><br><span class="line">.cfi_startproc</span><br><span class="line">stpx29, x30, [sp, -32]!</span><br><span class="line">.cfi_def_cfa_offset 32</span><br><span class="line">.cfi_offset 29, -32</span><br><span class="line">.cfi_offset 30, -24</span><br><span class="line">addx29, sp, 0</span><br><span class="line">.cfi_def_cfa_register 29</span><br><span class="line">strx0, [x29, 24]</span><br><span class="line">adrpx0, .LC0</span><br><span class="line">addx0, x0, :lo12:.LC0</span><br><span class="line">blputs</span><br><span class="line">nop</span><br><span class="line">ldpx29, x30, [sp], 32</span><br><span class="line">.cfi_restore 30</span><br><span class="line">.cfi_restore 29</span><br><span class="line">.cfi_def_cfa 31, 0</span><br><span class="line">ret</span><br><span class="line">.cfi_endproc</span><br></pre></td></tr></table></figure><p>梳理汇编中的bl指令，可以得出以下的调用过程：</p><p>_GLOBAL__sub_I_g_al -&gt; _Z41__static_initialization_and_destruction_0ii -&gt; _ZN1AC1Ev(_ZN1AC2Ev)</p><p>其中_ZN1AC1Ev是一个弱符号，最终解析成_ZN1AC2Ev，即class A的构造函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.weak_ZN1AC1Ev</span><br><span class="line">.set_ZN1AC1Ev,_ZN1AC2Ev</span><br></pre></td></tr></table></figure><p>那现在问题就变成_GLOBAL__sub_I_g_al是谁调用的，查看汇编里的相关信息，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.LFE5:</span><br><span class="line">.size_GLOBAL__sub_I_g_al, .-_GLOBAL__sub_I_g_al</span><br><span class="line">.section.init_array,&quot;aw&quot;,%init_array</span><br><span class="line">.align3</span><br><span class="line">.xword_GLOBAL__sub_I_g_al</span><br><span class="line">.ident&quot;GCC: (Ubuntu/Linaro 7.5.0-3ubuntu1~18.04) 7.5.0&quot;</span><br><span class="line">.section.note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure><p>可以发现，_GLOBAL__sub_I_g_al存在一个单独的，名为”init_array”的section中。</p><p>关于这个section，ARM的官方文档中，描述如下:</p><blockquote><p>The C++ Standard places certain requirements on the construction and destruction of objects with static storage duration.</p></blockquote><blockquote><p>The ARM C++ compiler uses the .init_array area to achieve this. This is a const data array of self-relative pointers to functions.</p></blockquote><blockquote><p>The linker collects each .init_array from the various translation units together. It is important that the .init_array is accumulated in the same order.</p></blockquote><blockquote><p>The library routine _<em>cpp_initialize__aeabi</em> is called from the C library startup code, __rt_lib_init, before main. _<em>cpp_initialize__aeabi</em> walks through the .init_array calling each function in turn. On exit, __rt_lib_shutdown calls __cxa_finalize.</p></blockquote><blockquote><p>Usually, there is at most one function for T::T(), mangled name _ZN1TC1Ev, one function for T::~T(), mangled name _ZN1TD1Ev, one <strong>sti</strong> function, and four bytes of .init_array for each translation unit. The mangled name for the function f() is _Z1fv. There is no way to determine the initialization order between translation units.</p></blockquote><blockquote><p>Function-local static objects with destructors are also handled using __aeabi_atexit.</p></blockquote><blockquote><p>.init_array sections must be placed contiguously within the same region for their base and limit symbols to be accessible. If they are not, the linker generates an error.</p></blockquote><h2 id="查看init-array里的信息"><a href="#查看init-array里的信息" class="headerlink" title="查看init_array里的信息"></a>查看init_array里的信息</h2><p>通过以下命令，可以解析出具体调用的函数信息：</p><blockquote><p>objdump -D -j .init_array <your-application></p></blockquote><p>在我的环境中，输出如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a.out:     file format elf64-littleaarch64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .init_array:</span><br><span class="line"></span><br><span class="line">0000000000010d78 &lt;__frame_dummy_init_array_entry&gt;:</span><br><span class="line">   10d78:00000770 .word0x00000770</span><br><span class="line">   10d7c:00000000 .word0x00000000</span><br><span class="line">   10d80:000007c0 .word0x000007c0</span><br><span class="line">   10d84:00000000 .word0x00000000</span><br></pre></td></tr></table></figure><p>通过以下命令，将具体的地址，解析成相应的函数符号:</p><blockquote><p>addr2line 0xc1000a68 -e <your-application></p></blockquote><p>在我的环境中，输出如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/tmp/tmp.KS3wdL1X4n/main.cpp:16</span><br></pre></td></tr></table></figure><p>需要注意的是，这部分信息属于调试信息，编译的时候，加上”-g”，编译器才会生成这些额外信息。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://stackoverflow.com/questions/21386125/what-goes-to-the-init-array">What goes to the __init_array?(StackOverflow)</a></li><li><a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0475c/Chdfiffc.html">C++ initialization, construction and destruction(Arm)</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Class </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>体系结构对原子操作的实现和支持</title>
      <link href="/atomic-op/"/>
      <url>/atomic-op/</url>
      
        <content type="html"><![CDATA[<h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>查看以下C语言代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int val = 169;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    val = 275;</span><br><span class="line">    printf(&quot;val %d \n&quot;, val);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过GCC生成的arm64汇编如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">.arch armv8-a</span><br><span class="line">.file&quot;main.c&quot;</span><br><span class="line">.text</span><br><span class="line">.globalval</span><br><span class="line">.data</span><br><span class="line">.align2</span><br><span class="line">.typeval, %object</span><br><span class="line">.sizeval, 4</span><br><span class="line">val:</span><br><span class="line">.word169</span><br><span class="line">.section.rodata</span><br><span class="line">.align3</span><br><span class="line">.LC0:</span><br><span class="line">.string&quot;val %d \n&quot;</span><br><span class="line">.text</span><br><span class="line">.align2</span><br><span class="line">.globalmain</span><br><span class="line">.typemain, %function</span><br><span class="line">main:</span><br><span class="line">stpx29, x30, [sp, -16]!</span><br><span class="line">addx29, sp, 0</span><br><span class="line">adrpx0, val</span><br><span class="line">addx0, x0, :lo12:val</span><br><span class="line">movw1, 275</span><br><span class="line">strw1, [x0]</span><br><span class="line">adrpx0, val</span><br><span class="line">addx0, x0, :lo12:val</span><br><span class="line">ldrw1, [x0]</span><br><span class="line">adrpx0, .LC0</span><br><span class="line">addx0, x0, :lo12:.LC0</span><br><span class="line">blprintf</span><br><span class="line">movw0, 0</span><br><span class="line">ldpx29, x30, [sp], 16</span><br><span class="line">ret</span><br><span class="line">.sizemain, .-main</span><br><span class="line">.ident&quot;GCC: (Ubuntu/Linaro 7.5.0-3ubuntu1~18.04) 7.5.0&quot;</span><br><span class="line">.section.note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure><p>在现代计算机体系结构中，对变量的赋值过程是分为三步的，以上文的val为例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adrpx0, val</span><br><span class="line">movw1, 275</span><br><span class="line">strw1, [x0]</span><br></pre></td></tr></table></figure><p>为了加速访问，程序在运行过程中访问的变量，通常会放置在寄存器中。如果在多线程环境中，某个线程中该三步执行的间隙，该变量被用于其他线程，这就带来了脏值问题。</p><p>为了解决这一问题，可以通过加锁解决。加锁是一种比较廉价且低效的方法，在体系结构中，提供了三个操作作为一个整体执行的原子操作。</p><h2 id="ARM"><a href="#ARM" class="headerlink" title="ARM"></a>ARM</h2><h3 id="SWP指令"><a href="#SWP指令" class="headerlink" title="SWP指令"></a>SWP指令</h3><p>在比较早的arm指令集中，提供SWP和SWPB指令，用于进行原子操作。用法如下：</p><blockquote><p>SWP{B}{cond} Rt, Rt2, [Rn]</p></blockquote><p>关于该指令的更多用法，参考<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0489c/Chdbbbai.html">这里</a></p><p>由于该指令的效率比较低，会降低整体系统的性能，在ARMv6及之后的指令集中已经不再建议使用。</p><h3 id="LDREX-STREX指令"><a href="#LDREX-STREX指令" class="headerlink" title="LDREX&#x2F;STREX指令"></a>LDREX&#x2F;STREX指令</h3><p>在ARMv6及之后的指令集中，引入了两条指令 – LDREX&#x2F;STREX 来提供原子操作。</p><p>这两条操作，都会引起exclusive monitor(s)状态的变化，下文将举一个简单的例子。</p><p>查看如下用法:</p><blockquote><p>LDREX R1, [R0]</p></blockquote><p>将R0地址的值加载到R1，并对相应的物理地址设置相应的标志，该标志由exclusive monitors进行管理。</p><blockquote><p>STREX R2, R1, [R0]</p></blockquote><p>根据物理地址的状态，决定是否要进行值的写会操作。R0是将要写入的物理地址，R1中存储需要写会的值，R2则存储了这一操作的运行结果，成功返回0，失败则返回1。</p><p>关于exclusive monitor，在arm的手册中，被描述为一个简单的状态机。LDREX被称之为Load-Exclusive指令，STREX被称之为Store-Exclusive指令。对于一个Store-Exclusive指令来说，访问中涉及到的物理内存都被标记为exclusive才能够写回成功。</p><p>更多关于exclusive monitor的描述，可以查看参考一。</p><p>在Load&#x2F;Store-Exclusive的基础上，原子操作可以用如下代码实现(实现来自Linux):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#define ATOMIC_OP(op, c_op, asm_op)\</span><br><span class="line">static inline void atomic_##op(int i, atomic_t *v)\</span><br><span class="line">&#123;\</span><br><span class="line">unsigned long tmp;\</span><br><span class="line">int result;\</span><br><span class="line">\</span><br><span class="line">prefetchw(&amp;v-&gt;counter);\</span><br><span class="line">__asm__ __volatile__(&quot;@ atomic_&quot; #op &quot;\n&quot;\</span><br><span class="line">&quot;1:ldrex%0, [%3]\n&quot;\</span><br><span class="line">&quot;&quot; #asm_op &quot;%0, %0, %4\n&quot;\</span><br><span class="line">&quot;strex%1, %0, [%3]\n&quot;\</span><br><span class="line">&quot;teq%1, #0\n&quot;\</span><br><span class="line">&quot;bne1b&quot;\</span><br><span class="line">: &quot;=&amp;r&quot; (result), &quot;=&amp;r&quot; (tmp), &quot;+Qo&quot; (v-&gt;counter)\</span><br><span class="line">: &quot;r&quot; (&amp;v-&gt;counter), &quot;Ir&quot; (i)\</span><br><span class="line">: &quot;cc&quot;);\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ATOMIC_OP(atomic_add)</span><br></pre></td></tr></table></figure><p>更多关于原子操作，可以查看Linux arch源码里的atomic.h</p><h2 id="X86"><a href="#X86" class="headerlink" title="X86"></a>X86</h2><p>X86的指令支持”lock”前缀，对于支持该前缀的cpu指令，使用该前缀后，能够保证是原子执行的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://infocenter.arm.com/help/topic/com.arm.doc.dht0008a/DHT0008A_arm_synchronization_primitives.pdf">DHT0008A_arm_synchronization_primitives.pdf</a></li><li><a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0489c/Cihbghef.html">LDREX&#x2F;STREX(arm)</a></li><li><a href="https://stackoverflow.com/questions/11894059/atomic-operations-in-arm">Atomic operations in ARM(StackOverflow)</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> ARM </tag>
            
            <tag> X86 </tag>
            
            <tag> Computer Architecture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++中的内存泄露检测</title>
      <link href="/memory-leak-for-c/"/>
      <url>/memory-leak-for-c/</url>
      
        <content type="html"><![CDATA[<h2 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h2><p>在理解内存泄露前，先简要讲下C&#x2F;C++的内存模型。可执行文件使用的内存，粗略的可以分为由开发者主动支配以及由程序被动分配。举个简单的例子，全局变量以及局部变量的存储，就是由编译器编译器时候规划好的，通过malloc&#x2F;new接口获得的内存则是从堆中获得的，由开发者来通过free接口释放。</p><p>内存泄露，即开发者从堆中获得的内存，用完之后没有还给系统，从而引起了有效内存减少。</p><p>检测内存的泄露的思路大致有两种，他们之间的区别，在于检查的层面。</p><h2 id="实现自己的malloc-new-free接口"><a href="#实现自己的malloc-new-free接口" class="headerlink" title="实现自己的malloc&#x2F;new&#x2F;free接口"></a>实现自己的malloc&#x2F;new&#x2F;free接口</h2><p>通过宏定义或者GCC的wrapper参数，可以取代系统的相关实现。在自己的实现中，记录下malloc&#x2F;new&#x2F;free接口的调用信息，比如指向内存的指针数量，分配内存的大小，是否被释放，接口的调用位置等等。依据这一原理实现的关键在于，能正确计算出什么时候应该释放内存，比如已经没有有效指针指向内存，比如释放内存的大小与申请内存大小不一等等。</p><p>使用这一原理的工具，有<a href="https://dmalloc.com/">Dmalloc</a></p><h2 id="使用虚拟机来检测内存泄露"><a href="#使用虚拟机来检测内存泄露" class="headerlink" title="使用虚拟机来检测内存泄露"></a>使用虚拟机来检测内存泄露</h2><p>另一个更加行之有效，也更加耗费大的方法，则是通过虚拟机。即通过专门的虚拟机程序，在程序的实际运行过程中，实时检测内存的使用情况。</p><p>使用这一原理的工具，有<a href="https://www.valgrind.org/">valgrind</a></p><p>无论哪种办法，本质都是通过记录额外信息来实现的，区别在于记录信息的层面，是可执行程序本身，或者由系统来记录。<br>，</p><h2 id="常见的内存泄露场景"><a href="#常见的内存泄露场景" class="headerlink" title="常见的内存泄露场景"></a>常见的内存泄露场景</h2><ol><li>未释放内存，又申请了新内存<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">char* str = new char[100];</span><br><span class="line"></span><br><span class="line">str = new char [150];</span><br><span class="line"></span><br><span class="line">delete[] str;</span><br></pre></td></tr></table></figure></li><li>局部变量被销毁后，指向的内存未被释放</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    char* lo = new char[100];</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://stackoverflow.com/questions/28446850/memory-leak-detectors-working-principle#:~:text=The%20basic%20implementation%20is%20actually,allocation%20should%20have%20been%20freed.">Memory Leak Detectors Working Principle(StackOverFlow)</a></p></li><li><p><a href="https://stackoverflow.com/questions/6261201/how-to-find-memory-leak-in-a-c-code-project">How to find memory leak in a C++ code&#x2F;project?(StackOverFlow)</a></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> C++ </tag>
            
            <tag> Memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Weak Symbol in C/C++</title>
      <link href="/weak-symbol-in-c/"/>
      <url>/weak-symbol-in-c/</url>
      
        <content type="html"><![CDATA[<h2 id="weak-symbol"><a href="#weak-symbol" class="headerlink" title="weak symbol"></a>weak symbol</h2><p><em>weak symbol</em>是二进制文件里的一种符号类型，与之相对的，是<em>strong symbol</em>。符号的类型跟代码中的声明和实现有关，查看以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line"></span><br><span class="line"># define weak_alias(name, aliasname) _weak_alias (name, aliasname)</span><br><span class="line"># define _weak_alias(name, aliasname) \</span><br><span class="line">  extern __typeof (name) aliasname __attribute__ ((weak, alias (#name)));</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">    extern void UndefinedSymbol();</span><br><span class="line"></span><br><span class="line">    void StrongSymbol()</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Strong Symbol \n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    weak_alias(StrongSymbol, WeakAliasSymbol);</span><br><span class="line"></span><br><span class="line">    int g_1;</span><br><span class="line">    int g_2 = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    StrongSymbol();</span><br><span class="line">    WeakAliasSymbol();</span><br><span class="line">    UndefinedSymbol();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以下命令得到对应的符号类型</p><blockquote><p>g++ -c main.cpp<br>nm main.o</p></blockquote><p>得到的输出为</p><blockquote><p>B g_1<br>D g_2<br>T StrongSymbol<br>U UndefinedSymbol<br>W WeakAliasSymbol</p></blockquote><p>基本涵盖了常见的符号类型:</p><ol><li>g_1 -&gt; B 表示未初始化或初始化为0的符号，存储在BSS段</li><li>g_2 -&gt; D 表示初始化的符号，存储在DATA段</li><li>StrongSymbol -&gt; T 表示既有声明，也有定义的函数，存储在TEXT段</li><li>UndefinedSymbol -&gt; U 该函数仅有声明，没有定义，具体的定义推迟到链接阶段出现</li><li>WeakAliasSymbol -&gt; W 该函数有声明，也可能存在定义，但是属于弱符号</li></ol><h2 id="一般用法"><a href="#一般用法" class="headerlink" title="一般用法"></a>一般用法</h2><p>如果在一个二进制文件中，出现两个类型均为T的同名符号，就会出现”Mutiple definition”的错误。但是如果如果一个类型为W的弱符号跟一个类型为T的强符号同时出现，那么定义便由类型为T的强符号决定，这也是弱符号(weak symbol)的一般用途，即允许使用该库的开发者自定义相关实现，但同时也提供了一个默认实现。关于这一用法，可以参考<a href="http://www.vishalchovatiya.com/default-handlers-in-c-weak_alias/">这里</a></p><p>更多的符号类型，参考<a href="https://sourceware.org/binutils/docs/binutils/nm.html">GNU文档</a></p><h2 id="更本质的原则"><a href="#更本质的原则" class="headerlink" title="更本质的原则"></a>更本质的原则</h2><p>考虑以下情形：</p><ol><li>二进制文件中调用了某个外部接口UndefinedSymbol</li><li>动态链接库libt1中声明了UndefinedSymbol为一个类型为T的StrongAlias符号的weak alias</li><li>动态链接库libt2中声明了UndefinedSymbol为一个类型为T的符号，即给出了具体的定义</li><li>二进制同时链接了libt1和libt2</li></ol><p>问题是，二进制会链接哪一个库中的UndefinedSymbol？<br>答案是，取决于链接的顺序。</p><p>关于这一符号解析原则的阐述，在以下的两份文档中给出了说明(见参考2和3)：</p><p>关于符号解析的规则</p><blockquote><p>Another form of simple symbol resolution, interposition, occurs between relocatable objects and shared objects, or between multiple shared objects. In these cases, when a symbol is multiply-defined, the relocatable object, or the first definition between multiple shared objects, is silently taken by the link-editor. The relocatable object’s definition, or the first shared object’s definition, is said to interpose on all other definitions. This interposition can be used to override the functionality provided by another shared object. Multiply-defined symbols that occur between relocatable objects and shared objects, or between multiple shared objects, are treated identically. A symbols weak binding or global binding is irrelevant. By resolving to the first definition, regardless of the symbols binding, both the link-editor and runtime linker behave consistently.</p></blockquote><p>关于链接顺序的说明</p><blockquote><p>Search the library named library when linking. (The second alternative with the library as a separate argument is only for POSIX compliance and is not recommended.) It makes a difference where in the command you write this option; the linker searches and processes libraries and object files in the order they are specified. Thus, <code>foo.o -lz bar.o&#39; searches library </code>z’ after file foo.o but before bar.o. If bar.o refers to functions in &#96;z’, those functions may not be loaded. The linker searches a standard list of directories for the library, which is actually a file named liblibrary.a. The linker then uses this file as if it had been specified precisely by name.</p></blockquote><p>简单的来说，就是以最先链接到的为准。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://leondong1993.github.io/2017/04/strong-weak-symbol/">strong weak symbol</a></li><li><a href="https://docs.oracle.com/cd/E19120-01/open.solaris/819-0690/chapter2-93321/index.html">Oracle Symbol Resolution</a></li><li><a href="https://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Link-Options.html">GNU Link Options</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> GCC </tag>
            
            <tag> C </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++代码扩张</title>
      <link href="/code-extend/"/>
      <url>/code-extend/</url>
      
        <content type="html"><![CDATA[<p>编译器的编译过程，可以粗略的分为前端和后端，如<a href="http://icps.u-strasbg.fr/~pop/images/front-end.png">下图</a>所示:</p><p><img src="/images/front-end.png" alt="编译器编译过程"></p><p>除了使用反汇编研究编译器的最终结果外，也可以查看编译器生成的AST树表示。AST树是编译器前端所产生的最终代码表现形式。</p><p>下面是主流编译器clang和gcc生成AST树的方法:</p><h2 id="AST-in-GCC"><a href="#AST-in-GCC" class="headerlink" title="AST in GCC"></a>AST in GCC</h2><blockquote><p>gcc -fdump-tree-all main.c</p></blockquote><blockquote><p>g++ -fdump-tree-all main.cpp</p></blockquote><p>关于GCC中AST树生成的更多选项，参考<a href="https://gcc.gnu.org/onlinedocs/gcc-6.2.0/gcc/Developer-Options.html">这里</a></p><h2 id="AST-in-clang"><a href="#AST-in-clang" class="headerlink" title="AST in clang"></a>AST in clang</h2><blockquote><p>clang -Xclang -ast-print -fsyntax-only main.c</p></blockquote><p>关于clang中AST树生成的更多选项，参考<a href="https://clang.llvm.org/docs/ClangCommandLineReference.html">这里</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flexible array in C/C++</title>
      <link href="/flexible-array-in-c/"/>
      <url>/flexible-array-in-c/</url>
      
        <content type="html"><![CDATA[<p>数据结构，是数据的抽象和组织方式。对程序语言来说，数据结构是内存的解释方式。可变数组，是指大小不固定的数组。可变数组，通常是某个结构体的最后一个成员。可变数组，在通信等场景中有着大量的应用。</p><h2 id="ISO-C99中的可变数组"><a href="#ISO-C99中的可变数组" class="headerlink" title="ISO C99中的可变数组"></a>ISO C99中的可变数组</h2><p>可变数组(flexible array member)已经成为ISO C99标准的一部分，在C99的规定中，可变数组的使用存在以下限制:</p><ol><li>可变数组属于incomplete type，仅能为结构体的最后一个成员</li><li>不能有包含可变数组成员的结构体组成的数组</li><li>拥有可变数组成员的结构体不能作为其他结构体的成员</li><li>拥有可变数组成员的结构体还应该拥有至少一个其他命名成员</li></ol><p>查看如下代码，C99标准中可变数组的使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">#define SIZE 100</span><br><span class="line"></span><br><span class="line">struct Pack &#123;</span><br><span class="line">    int num;</span><br><span class="line">    char data[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    struct Pack *p = (struct Pack *)malloc(SIZE + sizeof(struct Pack));</span><br><span class="line">    p-&gt;num = SIZE;</span><br><span class="line">    memset(p-&gt;data, 0, sizeof(char) * p-&gt;num);</span><br><span class="line">    free(p);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可变数组的起始地址，是通过偏移计算出来的。因此可变数组如果长度为0，本身并不占据空间。对于编译器来说，可变数组是无视越界检查的incomplete type，因此，可变数组的使用过程中，需要十分谨慎，不能引起越界访问，否则可能造成各种无法预知的问题。</p><h2 id="标准之前的可变数组"><a href="#标准之前的可变数组" class="headerlink" title="标准之前的可变数组"></a>标准之前的可变数组</h2><p>在可变数组成为ISO C一部分之前，其使用方式通过是如下方式实现的(以下代码来自<a href="https://github.com/apache/incubator-nuttx">Nuttx</a>)</p><p>包含可变数组的结构体定义:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct tmpfs_file_s</span><br><span class="line">&#123;</span><br><span class="line">  /* First fields must match common TMPFS object layout */</span><br><span class="line"></span><br><span class="line">  FAR struct tmpfs_dirent_s *tfo_dirent;</span><br><span class="line">  struct tmpfs_sem_s tfo_exclsem;</span><br><span class="line"></span><br><span class="line">  size_t   tfo_alloc;    /* Allocated size of the file object */</span><br><span class="line">  uint8_t  tfo_type;     /* See enum tmpfs_objtype_e */</span><br><span class="line">  uint8_t  tfo_refs;     /* Reference count */</span><br><span class="line"></span><br><span class="line">  /* Remaining fields are unique to a directory object */</span><br><span class="line"></span><br><span class="line">  uint8_t  tfo_flags;    /* See TFO_FLAG_* definitions */</span><br><span class="line">  size_t   tfo_size;     /* Valid file size */</span><br><span class="line">  uint8_t  tfo_data[1];  /* File data starts here */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>大小计算方式如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define SIZEOF_TMPFS_FILE(n) (sizeof(struct tmpfs_file_s) + (n) - 1)</span><br></pre></td></tr></table></figure><p>相比于ISO C99的用法，这种用法，要求可变数组的长度至少为1。因此，在计算数组长度的时候，需要减去1，以消除该成员带来的影响，使用方式上则与ISO C99上没有差异。倒不如说，正是由于C语言标准的发展滞后，才会出现这种写法，并最终发展为C语言标准的一部分。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://wiki.sei.cmu.edu/confluence/display/c/DCL38-C.+Use+the+correct+syntax+when+declaring+a+flexible+array+member">DCL38-C. Use the correct syntax when declaring a flexible array member</a></p></li><li><p><a href="https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html">Arrays of Length Zero</a></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> C++ </tag>
            
            <tag> Memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Empty struct/class in C/C++</title>
      <link href="/empty-struct-class-in-c/"/>
      <url>/empty-struct-class-in-c/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li><p>C语言中，对”struct A {};”进行sizeof运算，结果应该是多少？</p></li><li><p>C++中，对”class A {};”进行sizeof运算，结果应该是多少？</p></li></ol><h2 id="C语言对empty-struct的规定"><a href="#C语言对empty-struct的规定" class="headerlink" title="C语言对empty struct的规定"></a>C语言对empty struct的规定</h2><p>在标准C中，对empty struct的大小没有做出规定，该行为是未定义的。然而，gcc做了拓展，在gcc中，empty struct的sizeof结果为0，更多的信息见参考1。</p><p>事实上，即使是gcc中，empty struct的行为还有再复杂一些，查看如下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">struct T &#123;&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    struct T a, b;</span><br><span class="line">    struct T *pa = &amp;a;</span><br><span class="line">    struct T *pb = &amp;b;</span><br><span class="line">    if ((struct T *)&amp;a == (struct T *)&amp;b) &#123;</span><br><span class="line">        printf(&quot;first is equal \n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (pa == pb) &#123;</span><br><span class="line">        printf(&quot;second is equal \n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是</p><blockquote><p>second is equal</p></blockquote><p>看起来有些无法理解，在x86的机器上，查看对应源码的汇编代码，发现第一个比较直接被视为不成立而优化掉了。也就是说，对于编译器来说，即使是空结构体，两个不同的结构体的地址也不应该相等。gcc虽然拓展了empty struct的大小定义，但是使用上仍然有些模糊，可能会有期望之外的行为发生。</p><h2 id="C-对empty-struct-class的规定"><a href="#C-对empty-struct-class的规定" class="headerlink" title="C++对empty struct&#x2F;class的规定"></a>C++对empty struct&#x2F;class的规定</h2><p>在C++11中，empty struct&#x2F;class的sizeof结果是1，至于原因，stroustrup(C++之父)解释说，是为了保证new出来的不同对象之间，即使是empty class，地址也不应该相等，详细信息见参考2。</p><p>对于大部分C++编译器来说，一般还会做一个称之为”empty base class optimization”的优化，查看如下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">class T &#123;&#125;;</span><br><span class="line">class TT : public T &#123;</span><br><span class="line">    int x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; sizeof(class TT) &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果是</p><blockquote><p>4</p></blockquote><p>也就是说，如果一个class继承自empty class，那么empty class多余的那个1就不会出现，以避免预期之外的行为。</p><p>那问题来了，C++中存在sizeof为0的class吗？答案是C++标准中是不允许存在，但是在g++中，可以构造一个出来，查看如下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">class T &#123;</span><br><span class="line">    int x[0];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; sizeof(class T) &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>*g++*中，输出结果为</p><blockquote><p>0</p></blockquote><p>这个行为是未定义，属于预期之外的行为。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://gcc.gnu.org/onlinedocs/gcc/Empty-Structures.html">gcc关于empty struct的扩展</a></li><li><a href="https://www.stroustrup.com/bs_faq2.html#sizeof-empty">为什么C++的empty class大小不为0</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> GCC </tag>
            
            <tag> C </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[note]理解编程语言</title>
      <link href="/note-program-language/"/>
      <url>/note-program-language/</url>
      
        <content type="html"><![CDATA[<p><em>Understanding Programming Languages</em> (M.Ben-Ari) 的读书笔记。</p><hr><br/><h2 id="编程语言定义，组成及编程环境"><a href="#编程语言定义，组成及编程环境" class="headerlink" title="编程语言定义，组成及编程环境"></a>编程语言定义，组成及编程环境</h2><br/><h3 id="编程语言定义"><a href="#编程语言定义" class="headerlink" title="编程语言定义"></a>编程语言定义</h3><p>对程序员来说，编程语言只是编程的工具，很多程序员沉迷于比较不同的编程语言，但是缺乏分析不同语言特点的能力。</p><p>编程语言知识的匮乏，导致以下问题：</p><ol><li>尽管计算机硬件和现代软件系统的爆炸发展，大多数人仍然使用1970年甚至更早之前发展出的语言。编程语言的发展落后，使得程序员不得不采用更多的工具和方法进行弥补。</li><li>在选择开发语言时，没有充分考虑安全性和效率，导致开发出的项目难以维护，开发者常常通过汇编而不是算法和编程本身来解决效率问题。</li></ol><p>编程语言的存在，是为了弥补硬件和真实世界之间的不同抽象差距。高抽象的语言易于理解和使用，低抽象的语言则更为灵活和高效。设计和选择一门语言，就是选择一种合适的抽象。</p><p>从数学上来说，一个程序是详细说明一个运算过程的一段符号序列。一门编程语言是描述这个序列如何构成以及运算过程含义的规则集合。<br><br/></p><h3 id="编程语言分类"><a href="#编程语言分类" class="headerlink" title="编程语言分类"></a>编程语言分类</h3><p>在wiki百科中，对编程语言分类方式的描述是：</p><blockquote><p>编程范式、编程范式或程序设计法(Programming paradigm)，是一类典型的编程风格，是指从事软件工程的一类典型的风格。如函数式编程、过程式编程、面向对象编程、指令式编程等等为不同的编程范型。</p><p>编程范型提供了（同时决定了）程序员对程序执行的看法。例如，在面向对象编程中，程序员认为程序是一系列相互作用的对象，而在函数式编程中一个程序会被看作是一个无状态的函数计算的序列。</p><p>正如软件工程中不同的群体会提倡不同的“方法学”一样，不同的编程语言也会提倡不同的“编程范型”。一些语言是专门为某个特定的范型设计的（如Smalltalk和Java支持面向对象编程，而Haskell和Scheme则支持函数式编程），同时还有另一些语言支持多种范型（如Ruby、Common Lisp、Python和Oz）。</p><p>很多编程范型已经被熟知他们禁止使用哪些技术，同时允许使用哪些。例如，纯粹的函数式编程不允许有副作用；结构化编程不允许使用goto。可能是因为这个原因，新的范型常常被那些习惯于较早的风格的人认为是教条主义或过分严格。然而，这样避免某些技术反而更加证明了关于程序正确性——或仅仅是理解它的行为——的法则，而不用限制程序语言的一般性。</p><p>编程范型和编程语言之间的关系可能十分复杂，由于一个编程语言可以支持多种范型。例如，C++设计时，支持过程化编程、面向对象编程以及泛型编程。然而，设计师和程序员们要考虑如何使用这些范型元素来构建一个程序。一个人可以用C++写出一个完全过程化的程序，另一个人也可以用C++写出一个纯粹的面向对象程序，甚至还有人可以写出杂揉了两种范型的程序。</p></blockquote><p>以下是常见的分类：<br><br/></p><h4 id="指令式语言和声明式语言"><a href="#指令式语言和声明式语言" class="headerlink" title="指令式语言和声明式语言"></a>指令式语言和声明式语言</h4><p>指令式语言(Imperative programming)，即详细的描述整个过程，一步步的告诉计算机如何完成计算过程。<br>考虑一个简单的数学问题 —— 从一组数中寻找最大数，对于指令式语言来说，过程通常如下：</p><ol><li>创建一个用于保存结果的变量</li><li>遍历数组，一一比较</li><li>将最终的结果返回</li></ol><p>声明式语言(Declarative programming)，即告诉计算机结果应该满足的条件，由编译器来决定如何获得结果。</p><p>相同的问题，对声明式语言来说，最大的数就是结果限制，编译器会自动推导出过程。</p><p>声明式语言,主要用于处理大量数据或者那些解决过程无法被详细描述的问题，包括：</p><ul><li>language processing(语言处理)</li><li>pattern matching(模式匹配)</li><li>process optimization(模型优化)</li></ul><p>指令式语言和声明式语言是一个相对的概念，如上文所说，编程语言是为了弥补硬件和真实世界之间的抽象差距。对于最底层的CPU指令来说，其核心就是用“变量定义 + 顺序执行 + 分支判断 + 循环”来表达逻辑过程。上层的应用，则是通过层层封装，来表现现实世界中的过程。越接近底层的表达，就越“指令式”;越接近现实世界的表达，就越“声明式”。</p><p>一般来说，C&#x2F;C++，Java，JavaScript，Python等等被认为是指令式语言。SQL，HTML&#x2F;CSS等等被认为是声明式语言。指令式语言通常需要更多的表达，声明式语言通常在效率上有所损失。<br><br/></p><h4 id="编译型语言和解释型语言"><a href="#编译型语言和解释型语言" class="headerlink" title="编译型语言和解释型语言"></a>编译型语言和解释型语言</h4><p>编译型和解释型语言的差别在于，生成目标CPU指令的时机不同。编译型是语言是源代码通过编译器，直接生成特定CPU体系的可执行文件。解释型语言通过源代码生成一种<strong>平台无关</strong>的中间代码，在运行过程中再将中间代码解释成目标平台的CPU指令。</p><p>一般认为C&#x2F;C++等等是编译型语言，JavaScript、Python等等是解释型语言。相对来说，编译型语言效率更高，解释型语言更为灵活。但是，当前编程语言的发展，编译型语言和解释型语言的界限并不是特别清晰，考虑以下几个情况：</p><ul><li><p>Java代码首先会被编译成虚拟机指令，然后，由虚拟机执行的时候，翻译成目标架构CPU指令。在一些教科书上，Java被成为半编译型或者混合型语言。</p></li><li><p>Python既可以直接解释源代码执行，也可以编译成虚拟机指令后，运行。</p></li><li><p>C#的源代码会首先被编译成一种中间文件，然后，借助.Net Framework虚拟机，通过中间代码，直接生成目标CPU架构的可执行文件。接着，直接执行该可执行文件。</p></li><li><p>通过V8引擎，JavaScript源码可以直接生成目标CPU架构指令。这种应用在解释器上的技术，被称为JIT(即时编译, Just-In-Time)。对于解释型语言来说，通过JIT，再将生成的目标文件缓存起来，与编译型语言直接生成可执行文件，其实是没有太大区别的。</p></li></ul><p>如上文所说，编程语言本质是为了弥补硬件和真实世界之间的抽象差距。所谓编译型&#x2F;解释型，只是最终生成目标CPU指令的时机不同。两者之间的界限是非常模糊的，在一些情况下，甚至是可以相互转化的。<br><br/></p><h4 id="面向数据编程"><a href="#面向数据编程" class="headerlink" title="面向数据编程"></a>面向数据编程</h4><p>面向数据编程，即围绕着一种数据结构以及与数据结构相关的操作进行编程。这种编程范式在编程语言发展早期非常流行，这种编程语言主要用于科学计算和研究中，从数学的角度，而不是从工程的角度来实现语言。</p><p>支持该种设计的语言包括：</p><ul><li>Lisp: Lisp的基本数据结构是linked list，当前，Lisp主要活跃在人工智能领域。</li><li>APL : APL的基本数据结构是vectors和matrics, APL是从数学形式体系中发展出来的。</li><li>Snobol&#x2F;Icon :Snobol和Icon的基本数据结构是string，主要用于文本处理。</li><li>SETL: SETL的基本数据结构是set，用于数学计算。</li></ul><p>这种类型的语言，当前已经不再那么流行，主要由于以下两个原因：</p><ol><li>面向对象语言，拥有类似的能力。</li><li>函数式编程和逻辑式编程概念的出现。</li></ol><br/><h4 id="面向对象编程-OOP"><a href="#面向对象编程-OOP" class="headerlink" title="面向对象编程(OOP)"></a>面向对象编程(OOP)</h4><p>面向对象编程(Object-oriented programming, OOP)，即将对象作为基本单元的编程方式。对象，是对真实世界中物体概念的抽象，对象包括数据以及对相应数据的操作。</p><p>最早出现的OOP语言是Simula，于20世纪60年代由K.Nygaard和O.-J.Dahl开发，用于系统仿真。</p><p>早期OOP中发展出的最重要的概念为 – 动态(dynamic, run-time)内存分配，动态运行调度，动态类型检查。区别于静态(static, compiler-time)，动态会带来额外的时间和内存花销。</p><p>C++既支持静态内存分配和静态类型检查的，也支持OOP的动态内存分配和动态类型检查。这表明，动态和静态的设计并不冲突，动态可以在需要的时候使用。就OOP来说，Java要比C++的设计更为“纯粹”。<br><br/></p><h3 id="编程语言标准化"><a href="#编程语言标准化" class="headerlink" title="编程语言标准化"></a>编程语言标准化</h3><p>编程语言的标准化，对编程语言的发展至关重要。但是，标准化常常是滞后于编程语言发展的。以C语言为例，gcc实现的很多特性，并不是标准C语言支持的，这些特性有些被广泛接受，成为后续标准的一部分，有些没有被接受。如果这些非标准的特性被使用，一定要特别谨慎，因为这会导致程序的兼容性变差。<br><br/></p><h3 id="编程语言存在的理论基础-可计算性"><a href="#编程语言存在的理论基础-可计算性" class="headerlink" title="编程语言存在的理论基础(可计算性)"></a>编程语言存在的理论基础(可计算性)</h3><p>在20世界30年代，早于电子计算机发明之前，逻辑学家已经开始研究计算的抽象概念。Alan Turing和Alonzo Church分别提出一种经典，简单的计算模型，分别叫做图灵机和λ演算。随后，Church-Turing 猜想被提出：</p><blockquote><p>任何在算法上可计算的问题同样可由图灵机计算。</p></blockquote><p>尽管该猜想未能被证明，但是，到目前为止，几乎是被全面接受的。</p><p>图灵机的基本思想使用机器来模拟人们用纸笔来进行数学运算的过程，图灵机将这种过程分成四步：</p><ol><li>一条无限长的纸带TAPE。纸带被划分为一个接一个的小格子，每个格子上包含一个来自有限字母表的符号，字母表中有一个特殊的符号□表示空白。纸带上的格子从左到右依次被编号为0, 1, 2, …，纸带的右端可以无限伸展。</li><li>一个读写头HEAD。该读写头可以在纸带上左右移动，它能读出当前所指的格子上的符号，并能改变当前格子上的符号。</li><li>一套控制规则TABLE。它根据当前机器所处的状态以及当前读写头所指的格子上的符号来确定读写头下一步的动作，并改变状态寄存器的值，令机器进入一个新的状态，按照以下顺序告知图灵机命令：<ol><li>写入（替换）或擦除当前符号；</li><li>移动 HEAD， ‘L’向左， ‘R’向右或者’N’不移动；</li><li>保持当前状态或者转到另一状态</li></ol></li><li>一个状态寄存器。它用来保存图灵机当前所处的状态。图灵机的所有可能状态的数目是有限的，并且有一个特殊的状态，称为停机状态。参见停机问题。</li></ol><p>图灵机的模型是如此简单，任何编程语言都可以实现对图形机的模拟。因此，如果图灵机可以解决一个问题，那么编程语言同样可以。<br><br/></p><h3 id="编程语言的构成元素"><a href="#编程语言的构成元素" class="headerlink" title="编程语言的构成元素"></a>编程语言的构成元素</h3><br/><h4 id="句法-Syntax"><a href="#句法-Syntax" class="headerlink" title="句法(Syntax)"></a>句法(Syntax)</h4><p>句法，是定义编程语言中有效符号序列的规则集合。</p><p>句法，通过形式记号(formal notation)来描述。句法中最广泛使用的形式记号是扩充巴科斯范式(Extended Backus-Naur Form，EBNF)。</p><p>句法相关的常见错误包括：</p><ul><li>标识符的长度限制</li><li>大小写是否敏感</li><li>注释的不同写法</li><li>写法接近但含义完全不同的符号(&#x3D; vs &#x3D;&#x3D;)</li><li>分割符</li></ul><br/><h4 id="语义-Semantics"><a href="#语义-Semantics" class="headerlink" title="语义(Semantics)"></a>语义(Semantics)</h4><p>语义，是编程语言中表达式的含义，即描述程序如何在不同状态之间进行转换。</p><p>形式化编程语言语义(a formalization of the semantics of programming languages)的好处在于，程序的正确性很容易得到证明。如果程序的输入数据满足要求，那么相应的输出也将符合预期。<br><br/></p><h4 id="数据-Data"><a href="#数据-Data" class="headerlink" title="数据(Data)"></a>数据(Data)</h4><p>编程语言中，都会有对数据的抽象。即使是最底层的汇编语言，也是基于对寄存器、内存单元之类的物理实体的操作。因此，编程语言可以有如下定义：</p><p>type(类型): 值，以及对这些值的操作的集合<br>value(值): 一个未定义的基本概念<br>Literal: 程序中文字声明的特定值<br>Representation: 值在计算机中的二进制表示<br>Variable: 存储值的内存单元名称<br>Constant: 不变的值<br>Object: variable or Constant</p><p>对于一个Variable来说，一定是某个特定的类型。因为，只有知道了类型，编译器才能分配相应的内存。<br><br/></p><h4 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h4><p>编程语言的赋值过程分为3步：</p><ol><li>计算右值</li><li>计算左值地址</li><li>将右值存储于左值地址</li></ol><br/><h4 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h4><p>类型检查用于检查赋值过程中右值结果与左值类型是否兼容。</p><p>赋值包括函数调用过程中，将实参赋给形参，可能的结果有3种：</p><ol><li>类型一致</li><li>隐式转换</li><li>无法转换，报错</li></ol><p>类型转换是可靠性和便捷性之间的一种权衡。<br><br/></p><h4 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h4><p>控制结构有2种：</p><ol><li>选择语句</li><li>循环语句</li></ol><br/><h4 id="子程序和模块"><a href="#子程序和模块" class="headerlink" title="子程序和模块"></a>子程序和模块</h4><p>对于大型的工程来说，不同的程序语言，提供了不同的组织方式。比如，C语言的.c，.h文件，Java的包管理器等等。<br><br/></p><h3 id="编程环境"><a href="#编程环境" class="headerlink" title="编程环境"></a>编程环境</h3><p>使用编程语言的过程中，需要一系列的工具，包括：</p><ul><li>编辑器</li><li>编译器&#x2F;解释器</li><li>链接器</li><li>装载器</li><li>库管理工具</li><li>调试器</li><li>分析器</li><li>测试工具</li><li>配置工具</li></ul><br/><h2 id="编程语言的基本概念"><a href="#编程语言的基本概念" class="headerlink" title="编程语言的基本概念"></a>编程语言的基本概念</h2><br/><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ul><li>Integer types</li><li>Enumeration types</li><li>Character type(可以借助Enumeration types实现)</li><li>Boolean type</li><li>Subtypes(已有类型+使用限制)</li><li>Derived types</li><li>Expressions(一般借助逆波兰表达式[RPN]实现)</li><li>Assignment statements</li></ul><br/><h3 id="复杂数据类型"><a href="#复杂数据类型" class="headerlink" title="复杂数据类型"></a>复杂数据类型</h3><ul><li><p>Records</p>  <div style="text-indent:0em;padding:2em">Records是由一系列其他类型组成的统合，比如C语言中的struct，Ada中的components。Records的定义表明了其内存布局，组成Records的每一个部分，都对应的名称和类型，编译器可以很容易的计算出每一部分的offset，从而找到其在内存中的位置。</div></li><li><p>Arrays</p>  <div style="text-indent:0em;padding:2em">Arrays与Records的不同在于，Arrays是由同一类型组成的。</div></li><li><p>Reference semantics(引用)</p>  <div style="text-indent:0em;padding:2em">C/C++的设计中，pointer的使用常常导致严重的bug。Ada通过类型检查和访问级别(access levels)来规范pointer的使用，Java/Eiffel/Smalltalk则使用引用来解决这一问题。对于Java来说，非基本类型的声明，不会导致相应类型内存被分配，只是获得了一个隐式的指针，内存的分配需要通过new来获得。引用可以看做更加安全的指针用法，内存分配，寻址，越界检查等等的操作都是由编译器自动完成的，也就减少了出问题的概率。</div></li><li><p>String type</p>  <div style="text-indent:0em;padding:2em">字符串，本质上就是char类型的数组。但是，通常，编译器会提供一些语法糖，来增强字符串的用法。</div></li><li><p>Multi-dimensional arrays</p>  <div style="text-indent:0em;padding:2em">多维数组有两种声明方式：一种是直接声明，比如C语言中的a[2][2];一种是声明类型是数组的数组。</div></li></ul><h3 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h3><ul><li><p>switch-&#x2F;case-statements</p></li><li><p>if-statements</p>  <div style="text-indent:0em;padding:2em">if有两种实现：(1) short-circuit evaluation: C语言采用的就是这种实现，即逻辑计算过程中，一步步进行，如果结果确定，就不进行后续计算。(2) full-evaluation: 将逻辑表达式作为一个整体，计算出结果后跳转。 短路的实现，可以执行更少的指令，但是需要更多的jump，也就需要更多的内存去存储多余的指令。两者之间的效率对比取决于逻辑表达式的复杂程度。</div></li><li><p>loop statements</p></li><li><p>for-statements</p></li><li><p>sentinels(一种循环优化写法)</p>  <div style="text-indent:0em;padding:2em">一个改善循环写法的技巧，比如在长度为N的数组A中寻找dst，将数组A扩展至N+1, 最后一个元素存储为dst，从头遍历数组，判断返回的下表即可知道数组是否包含dst。这种写法被称为“哨兵”，好处在于，只需要判断值是否相等，不需要担心下标越界，因为总会有满足的下标，从而减少了所需要的判断，提升了效率。</div></li><li><p>go-to statements</p>  <div style="text-indent:0em;padding:2em">关于goto，是否应该被使用在编程语言中，仍然存在严重争论。反对者中包括Dijkstra，1968年Dijkstra写了一篇著名的文章 - “goto Considered Harmful"，阐明他反对goto的原因。</div></li></ul><h3 id="子程序结构"><a href="#子程序结构" class="headerlink" title="子程序结构"></a>子程序结构</h3><ul><li><p>子程序定义</p>  <div style="text-indent:0em;padding:2em">子程序是程序中独立的编译/执行单位，使用子程序的好处是显而易见的： (1)代码复用，节省空间，提高开发效率。(2)代码的可读性和维护性都会得到提升。子程序通常包括：(1)接口，表明子程序的调用方式。(2)子程序使用到的本地参数。(3)子程序实现。C语言中最典型的子程序结构是function。</div></li><li><p>传参</p>  <div style="text-indent:0em;padding:2em">传参过程中有两种定义需要区分：(1) 形参(formal parameter)：形参是函数声明中的参数值。(2)实参(actual parameter):函数调用发生时，实际传给子程序的参数值。传参的方式有两种，一种是值传递，一种是地址传递。地址传递可以看做特殊的值传递，传递的值是地址，地址传递过程中经常会有踩内存的问题，需要对程序的内存管理有一定了解，才能最大程度上缓解该问题。一些编程语言的实现中，将参数和具体的名称关联，允许默认参数，简化了传参过程。</div></li><li><p>Block structure</p>  <div style="text-indent:0em;padding:2em">这个概念，我没找到很好的翻译。所谓Block structure，就是子程序的主体部分，即除了声明之外的部分。编程语言对Block structure的支持，主要有两个区别：(1) 是否被命名。(2)是否支持嵌套使用。C语言对应的支持为：(1)未命名(2)不嵌套。未命名的Block structure是为了约束变量的使用范围;嵌套则是为了在子程序内部进一步复用重复的逻辑。这也引出一个很重要的问题，即参数是否能被访问。有3个概念对此进行描述：(1)访问范围 - scope (2) 可见性 - visibility (3) lifetime - 生命周期。一般来说，在访问范围内，变量都是可见的。但是存在一种变量被隐藏的情况，以C语言为例，如果函数体内部有跟全局变量同名的本地变量，那么对于该全局变量来说，就是可以访问，但是不可见。相比与写成子程序，Block structure的优势在于可以访问内部的变量。问题在于，过多的嵌套，会造成代码难以维护。Javascript对于嵌套函数的使用，就是一个很好的例子。在嵌套的调用过程中，对于如何获取外部的参数，存在两种方式：(1)Dynamic chain：每部分都保存指向上级内存的指针，层层回溯，直到找到需要的参数值。(2)Static chain: 嵌套调用过程中，给每个调用部分设定一个level，仅寻找level低于当前调用部分的上级，这是编译器的一种优化策略，缩短寻找的过程，具体内容可以查询参考9。</div></li></ul><h2 id="编程语言的高级概念"><a href="#编程语言的高级概念" class="headerlink" title="编程语言的高级概念"></a>编程语言的高级概念</h2><br/><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><div style="text-indent:0em;padding:2em">指针，即存储的内容是一个内存地址。无论指针指向的类型是什么，指针占用的内存大小都是一样的，都为一个字长。指针的类型，决定了编译器对地址开始的内存空间的解释，以及偏移的计算。</div><div style="text-indent:0em;padding:2em">指针的操作包括：取地址，解引用，赋值，地址自增、自减。根据这些概念，又出现了二维指针，数组等概念。大体上，指针和类型，结合内存管理，实现了对内存的解释。</div><div style="text-indent:0em;padding:2em">在内存的管理上，内存类型可以分为Code/Constants/Stack/Static Data/Heap 。其中Heap的使用比较灵活，类似C这种偏底层的语言，完全由开发者管理，类似于Java这种上层语言，则发展出了垃圾回收机制。</div><br/><h3 id="数的表示-Real-Numbers"><a href="#数的表示-Real-Numbers" class="headerlink" title="数的表示(Real Numbers)"></a>数的表示(Real Numbers)</h3><ul><li><p>数的表示方法</p>  <div style="text-indent:0em;padding:2em">对于小数0.2，有两种表达方式，一种是直接表示对应的十进制数，即对于小数的每一位，直接分配4个bit表示，这种方法被称为 binary-coded decimal(BCD)。一种是分权二进制表示，即第一位表示1/2，第二位1/4，以此类推，这种方法是存在精度损失的。</div>  <div style="text-indent:0em;padding:2em">由于BCD使用四位bit去表示十种情况，对内存的浪费事比较多的。同时BCD的表示方法，也不利于运算。因此，实际使用中，二进制表示法更为广泛，只有少数语言支持了BCD，比如Cobol。</div></li><li><p>定点数(fixed-point numbers)</p>  <div style="text-indent:0em;padding:2em">定点数表示，即使用固定的位数表示小数点前面的部分，使用固定的位数表示小数点后面的部分。</div>  <div style="text-indent:0em;padding:2em">定点数表示法的优势在于，足够准确，即绝对错误比较小。劣势在于，不够精确，相对错误较大。</div></li><li><p>浮点数(float-point numbers)</p>  <div style="text-indent:0em;padding:2em">浮点数表示法，发展自科学计数法。将数通过科学技术法表示成固定形式，再分别存储数的符号，底数和指数部分即可。</div>  <div style="text-indent:0em;padding:2em">浮点数表示法的优势在于相对错误较小，因为指数部分是单独存储的。缺点在于绝对错误较大，相对错误会被指数部分进行放大。</div></li><li><p>硬件和软件浮点</p>  <div style="text-indent:0em;padding:2em">一般来说，浮点计算是有专门的硬件支持的。对于没有硬件支持的计算机来说，可以通过触发异常，使用软件模拟浮点运算。</div></li><li><p>浮点运算的三类错误</p>  <div style="text-indent:0em;padding:2em">浮点数运算中，存在三类比较常见的错误：(1)微增(Negligible addition):一个很大的数加上一个很小的数，由于浮点数的表示，很小的数会被忽略不计。(2)错误方法(Error magnification):由于浮点数的表示方式，很小的相对错误被指数方法后，绝对错误很大。(3)失去含义(Loss of significance):计算机中的比较，是通过相减，然后将结果与0相比较。由于浮点数的表示方式，或者是编译器的优化，都会导致一定的误差。从而导致最终的结果不符合预期。一般来说，会将结果在一个小范围内进行比较。</div></li></ul><h3 id="多态-Polymorphism"><a href="#多态-Polymorphism" class="headerlink" title="多态(Polymorphism)"></a>多态(Polymorphism)</h3><ul><li><p>类型转换</p>  <div style="text-indent:0em;padding:2em">类型转换，即从一个类型，转换到另外一个类型。有两种情况：(1)将一种类型的值，有效的转换为另外一种。(2)将值转换为未被解释的比特字符串。(即存储内容不变，解释方式变化。)</div></li><li><p>重载(Overloading)</p>  <div style="text-indent:0em;padding:2em">重载，即在同一个作用范围里，使用同一个名字来表示不同的实体。</div></li><li><p>Generics(泛型)</p>  <div style="text-indent:0em;padding:2em">泛型，是一种在编译时，由编译器来决定类型的类型。泛型的出现，是为了复用那些类型无关的代码，比如最常见的排序算法。</div></li><li><p>Variant records(可变类型)</p>  <div style="text-indent:0em;padding:2em">可变类型，是指同一种可以被解释成不同的内存布局。C语言中比较常见的用法是，一个结构体中，存在一个字段表明类型，以及一些共同的字段，以及一个联合体。依据类型的不同，联合体的解释也不同。</div></li><li><p>Dynamic dispatching(动态分发)</p>  <div style="text-indent:0em;padding:2em">在运行时，根据类型，运行对应的路径。动态分发，一般用在面向对象的设计中。</div></li></ul><br/><h3 id="异常-Exception"><a href="#异常-Exception" class="headerlink" title="异常(Exception)"></a>异常(Exception)</h3><ul><li><p>异常的定义</p>  <div style="text-indent:0em;padding:2em">异常，即程序遇到错误时，需要做的处理。简单的可以是打印一些现场信息，复杂的则需要做一些处理，帮助恢复程序的运行，如果是不可恢复的问题，则直接退出。</div></li><li><p>异常的代价</p>  <div style="text-indent:0em;padding:2em">引入异常机制的代价主要来自于两个方面：(1)异常检测和处理本身需要额外的实现和运算。(2)异常处理代码本身也可能有bug，从而继续引发问题。</div></li><li><p>好的异常处理机制</p>  <div style="text-indent:0em;padding:2em">从异常的代价很容易就看到，一个好的异常处理机制应该满足:(1)在没有异常发生时，异常机制引入的代价几乎可以忽略不计。(2)异常机制应该是安全且易于使用的。</div></li><li><p>异常机制与if的区别</p>  <div style="text-indent:0em;padding:2em">if表明的是一种可能性的判断，是预期内的事情。异常是预期之外发生的事情，一般表明程序运行出了问题。</div></li><li><p>异常机制的实现</p>  <div style="text-indent:0em;padding:2em">异常机制，一般通过一张异常向量表实现。由于异常极少数情况下才会发生，异常向量表的代价几乎可以忽略不计。</div></li></ul><br/><h3 id="并发-Concurrency"><a href="#并发-Concurrency" class="headerlink" title="并发(Concurrency)"></a>并发(Concurrency)</h3><ul><li><p>并发需要处理的问题</p><ul><li>同步(Synchronization)</li><li>通信(Communication)</li></ul></li><li><p>CSP(Communicating Sequential Processes)(单独开坑写写这个)</p></li></ul><h2 id="编写大型系统"><a href="#编写大型系统" class="headerlink" title="编写大型系统"></a>编写大型系统</h2><h3 id="程序分解"><a href="#程序分解" class="headerlink" title="程序分解"></a>程序分解</h3><ul><li>分开编译</li><li>模块化编程</li><li>依赖管理</li></ul><h3 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h3><ul><li><p>面向对象编程的三个特征</p><ul><li>封装和抽象(Encapsulation and data abstraction)</li><li>继承(Inheritance)</li><li>多态(Dynamic polymorphism)</li></ul></li><li><p>关于面向对象的更多内容</p><ul><li>虚拟类(Abstract classes)</li><li>泛型(Generics)</li><li>多继承(Multiple inheritance)</li></ul></li></ul><br/><h2 id="非指令性编程语言-Non-imperative-Programming-Languages"><a href="#非指令性编程语言-Non-imperative-Programming-Languages" class="headerlink" title="非指令性编程语言(Non-imperative Programming Languages)"></a>非指令性编程语言(Non-imperative Programming Languages)</h2><ul><li><p>面向函数编程(Functional Programming)</p>  <div style="text-indent:0em;padding:2em">面向函数编程，更符合数学思维的表达习惯。对函数式编程来说，不需要直接管理内存，也不存在一般语言中组件间相互作用带来的副作用。代表性的语言包括：ML(Meta Language)</div></li><li><p>面向逻辑编程(Logic Programming)</p>  <div style="text-indent:0em;padding:2em">面向逻辑编程，即把计算过程，分解成一个个逻辑表达式。整个编程风格是高度抽象，声明式的。代表性的编程语言包括：Prolog</div></li></ul><br/><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.zhihu.com/question/22285830">声明式编程和命令式编程有什么区别？</a></li><li><a href="https://blog.csdn.net/zhu_xun/article/details/16921413">解释型语言和编译型语言的区别</a></li><li><a href="https://www.zhihu.com/question/21486706">程序的编译与解释有什么区别？</a></li><li><a href="https://segmentfault.com/a/1190000014722508">JavaScript、Node.js与V8的关系</a></li><li><a href="https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%9E%8B">编程范型</a></li><li><a href="https://zh.wikipedia.org/wiki/%E9%82%B1%E5%A5%87%EF%BC%8D%E5%9B%BE%E7%81%B5%E8%AE%BA%E9%A2%98">邱奇－图灵论题</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E6%9C%BA">图灵机</a></li><li><a href="https://zh.wikipedia.org/wiki/%E6%89%A9%E5%85%85%E5%B7%B4%E7%A7%91%E6%96%AF%E8%8C%83%E5%BC%8F">扩充巴科斯范式</a></li><li><a href="http://courses.cs.vt.edu/~cs3304/Spring00/notes/Chapter-9/index.htm">Implementing Subprograms</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Program Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式系统概述</title>
      <link href="/mooc-embbed/"/>
      <url>/mooc-embbed/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.icourse163.org/course/DLUT-1002607070">嵌入式系统概述(中国大学Mooc)</a>的课堂笔记</p><br/><h2 id="嵌入式系统的定义，组成及一般开发流程"><a href="#嵌入式系统的定义，组成及一般开发流程" class="headerlink" title="嵌入式系统的定义，组成及一般开发流程"></a>嵌入式系统的定义，组成及一般开发流程</h2><p>目前国内普遍接受的概念<sup>[1]</sup>：嵌入式系统是以应用为中心，以计算机技术为基础，软硬件可裁剪，适于应用系统对功能、可靠性、成本、体积、功耗严格要求的专用计算机系统。</p><p>嵌入式系统的一般设计过程<sup>[1]</sup>： </p><ol><li>硬件原理图的设计</li><li>PCB设计</li><li>硬件制板</li><li>硬件元器件的安装</li><li>嵌入式操作系统的移植</li><li>嵌入式软件设计</li></ol><p>嵌入式系统的设计，通常要考虑到实时性、可靠性、稳定性。具体的问题包括：</p><ul><li>硬件资源、运行环境和设计指标</li><li>升级方式</li><li>开发和测试策略</li></ul><p>嵌入式的概念，是相对于通用计算机的，当然，这种通用也是相对的，嵌入式强调的是一种专用用途，应用场景常常是资源受限的，优先考虑的也不是用户友好性，是安全性和可靠性。嵌入式系统的用途非常广，包括但不限于无人驾驶、通信设备、军事武器等等。</p><br/><h2 id="嵌入式C语言编程写法及优化技巧"><a href="#嵌入式C语言编程写法及优化技巧" class="headerlink" title="嵌入式C语言编程写法及优化技巧"></a>嵌入式C语言编程写法及优化技巧</h2><p>嵌入式开发过程中，最为常用的编程语言是C语言，原因很多，很重要的一个原因，内核通常是用C语言写的。</p><p>一般的单任务嵌入式程序典型架构是：</p><ol><li>从cpu复位时的指定地址开始执行</li><li>跳转至汇编代码startup处执行，完成部分初始化动作</li><li>跳转至用户主程序main执行，在main中完成：<ul><li>初始化部分硬件设备</li><li>初始化各软件模块</li><li>进入死循环(无线循环)，调用各模块的处理函数</li></ul></li></ol><p>尽管C语言并不是一门面向对象的语言，但是，通过sturct和函数指针，仍然可以很好的模拟”类”的写法，使得写出的代码，具备很好的维护性。</p><p>以下，是这种写法的一种实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#define C_Class struct</span><br><span class="line"></span><br><span class="line">C_Class A&#123;</span><br><span class="line">    C_Class A *A_this;</span><br><span class="line"></span><br><span class="line">    void (*foo)(C_Class A*A_this);</span><br><span class="line">    int (*parea)(int length, int width);</span><br><span class="line"></span><br><span class="line">    int a;</span><br><span class="line">    int b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>嵌入式平台中，最常用的芯片是arm系列，因此，如果需要处理一些性能敏感的场景，需要结合生成的arm汇编代码一起查看。</p><p>尽管现在的编译器已经非常智能，能够帮助程序员处理很多情况。但是，在一些存在歧义的情况下，编译器一般会采取保守的判断，以防止程序行为超出预期。因此需要对编译器有一定的了解，了解编译器在哪些方面是保守的，了解编译器对应的处理器体系结构。</p><p>以指针别名为例，来展示编译器的保守方面以及对应的优化策略：</p><p>考虑以下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void timers_v1(int *timer1, int *timer2, int *step)</span><br><span class="line">&#123;</span><br><span class="line">    *timer1 += *step;</span><br><span class="line">    *timer2 += *step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的arm汇编为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LDR r3, [r0, #0]     --&gt; r3 = *timer1</span><br><span class="line">LDR r12,[r2, #0]     --&gt; r12 = *step</span><br><span class="line">ADD r3, r3, r12      --&gt; r3 += r12</span><br><span class="line">STR r3, [r0, #0]     --&gt; *timer1 = r3</span><br><span class="line">LDR r0, [r1, #0]     --&gt; r0 = *timer2</span><br><span class="line">LDR r2, [r2, #0]     --&gt; r2 = *step</span><br><span class="line">ADD r0, r0, r2       --&gt; r0 += r2</span><br><span class="line">STR r0, [r1, #0]     --&gt; *timer2 = r0</span><br><span class="line">MOV pc, r14          --&gt; return</span><br></pre></td></tr></table></figure><p>可以看到, step指针指向的值被取出来两次，有一次是明显多余的。出现这种情况的原因，是编译器必须考虑所有可能的情况，假设step跟timer1指向同一个地址，那么第一次运算后，timer和step的值都被更新了，所以第2次重取step的值，才能保证在这种情况下，行为也符合预期。</p><p>但是如果程序员确定step和timer指向不同的地址，那么可以采取下面的写法，来减少一次step取值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void timers_v2(int *timer1, int *timer2, int *step)</span><br><span class="line">&#123;</span><br><span class="line">    int tmp = *step;</span><br><span class="line">    *timer1 += tmp;</span><br><span class="line">    *timer2 += tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，数据结构在内存中的布局也能极大影响程序的效率，如果结构的成员变量不全是内存对齐的，那么在取值时，就需要多余的操作。</p><p>总之，嵌入式程序的优化，是在基于对所写程序面向的场景，编译器和程序语言的了解上，使得生成的arm汇编最为精简。需要说明的是，效率最优并不总是程序首先考虑的事情，代码的可维护性以及优化所要付出的努力和优化带来的效果对比，这些都是优化前所要考虑的事情。</p><br/><h2 id="Linux-C的编程工具链以及构建系统"><a href="#Linux-C的编程工具链以及构建系统" class="headerlink" title="Linux C的编程工具链以及构建系统"></a>Linux C的编程工具链以及构建系统</h2><p>嵌入式开发过程中，涉及到的编译器，调试器，构建工具等等一系列的工具，被称之为工具链。</p><p>嵌入式系统开发中，开发环境和运行环境常常是不同架构的，因此就需要交叉编译，即在开发环境中编译出与之不同的运行环境的可执行文件。</p><p>当前使用最为广泛的为GNU工具链，GNU支持本地程序开发，也交叉编译，即GNU工具链包括  ：</p><ul><li>GNU Tools (GNU Development Toolchains)</li><li>GNU Tools交叉开发环境 (GNU Cross-Platform Development Toolchains)</li></ul><p>嵌入式C语言最早流行的构建系统是make，后来进一步发展出了CMake，CMake足够处理一些常见的项目场景，但在更复杂的构建场景中，比如系统的生成需要从多个仓库获取源码，进行编译链接时。对于这种复杂的场景，当前比较主流的构建系统是yocto。</p><p>一个嵌入式系统通常由3部分构成：</p><ul><li>Bootloader</li><li>嵌入式操作系统内核</li><li>文件系统</li></ul><p>Bootloader可以分为单阶段和多阶段。多阶段的Bootloader能提供更加复杂的功能，以及更好的移植性。大多数Bootloader都有两种工作模式，分别是Bootloader自动加载操作系统运行，全程不需要用户介入，即正常工作模式;以及通过串口或者网络等方式首先下载所需文件，再进行后续引导，即下载模式，通常首次启动时使用。</p><br/><h2 id="嵌入式系统书籍推荐"><a href="#嵌入式系统书籍推荐" class="headerlink" title="嵌入式系统书籍推荐"></a>嵌入式系统书籍推荐</h2><ol><li>嵌入式软件设计(清华大学出版社)</li><li>ARM嵌入式系统开发 - 软件设计与优化(北京航空航天大学出版社)</li><li>Linux程序设计(人民邮电出版社)</li><li>Linux设备驱动程序(中国电力出版社)</li><li>Linux设备驱动开发详解(人民邮电出版社)</li><li>Proteus电子电路设计及仿真(电子工业出版社)</li></ol><br/><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.icourse163.org/course/DLUT-1002607070">嵌入式系统概述(中国大学MOOC)</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Note </tag>
            
            <tag> Embeded System </tag>
            
            <tag> Mooc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[IC221]USNA/Systems Programming</title>
      <link href="/ic221-uana/"/>
      <url>/ic221-uana/</url>
      
        <content type="html"><![CDATA[<p>偶然找到一门unix课程，是由usna(美国海军学院)开设的，课程编号是IC221，质量非常高。本来是准备翻译整个系列的，但是精力有限，计划按照授课大纲写成几篇总结。</p><p><a href="https://www.usna.edu/Users/cs/aviv/classes/ic221/s16/cal.html">课程主页</a></p><p>内容主题以及对应地址将会记录如下：</p><ol><li><p><a href="">UNIX系统介绍</a></p><ul><li>(lecture1)  Unix 和 Linux 介绍</li><li>(lecture2)  Unix文件系统和命令行工具</li><li>(lecture3)  Unix设计哲学以及标准流</li></ul></li><li><p><a href="">C语言编程</a></p><ul><li>(lecture4)  格式化输入&#x2F;输出和基本类型</li><li>(lecture5)  结构，指针和数组</li><li>(lecture6)  字符串和字符串系统库</li><li>(lecture7)  命令行参数和二维数组</li><li>(lecture8)  程序内存布局和动态内存</li><li>(lecture9)  动态数组分配和数据表示</li><li>(lecture10) 字符串和字符串系统库</li><li>(lecture11) 用户态，内核态和系统调用</li><li>(lecture12) 通过系统调用操作文件和设备I&#x2F;O</li></ul></li><li><p><a href="">进程</a></p><ul><li>(lecture13) 进程创建和管理</li><li>(lecture14) fork&#x2F;exec&#x2F;wait</li><li>(lecture15) 进程状态和OS进程调度</li><li>(lecture16) 终端设备和作业控制（Job Control)</li><li>(lecture17) 进程组和终端信号</li><li>(lecture18) 管道和文件复制</li><li>(lecture19) 信号和信号处理</li><li>(lecture20) 定时器，sigaction()和可重入系统调用</li></ul></li><li><p><a href="">文件系统</a></p><ul><li>(lecture21) 文件系统，内核数据结构和打开文件</li><li>(lecture22) 文件链接：软链接&#x2F;硬链接</li></ul></li><li><p><a href="">操作系统安全</a></p><ul><li>(lecture23) 设置用户&#x2F;用户组权限</li><li>(lecture24) 修改环境变量，代码注入，溢出攻击</li></ul></li><li><p><a href="">网络</a></p><ul><li>(lecture25) 网络基础&#x2F;客户端服务器模型(C&#x2F;S模型)</li><li>(lecture26) scoket编程基础</li><li>(lecture27) socket服务器</li></ul></li><li><p><a href="">线程</a></p><ul><li>(lecture28) Posix线程</li><li>(lecture29) 锁，死锁和并发</li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> C </tag>
            
            <tag> USNA </tag>
            
            <tag> IC221 </tag>
            
            <tag> UNIX </tag>
            
            <tag> OS </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一行打印引出的Linux信号知识</title>
      <link href="/linux-signal/"/>
      <url>/linux-signal/</url>
      
        <content type="html"><![CDATA[<h2 id="引发问题的打印"><a href="#引发问题的打印" class="headerlink" title="引发问题的打印"></a>引发问题的打印</h2><p><img src="/images/shell_print.png"></p><p>一个正常运行的进程，在收到52号信号后，打印了”实时信号 18”，然后便异常退出了，异常退出码是180。</p><p>问题以如下几个：</p><ul><li>进程为什么会异常退出</li><li>18号实时信号跟52号信号有什么关系</li><li>是什么地方打印了提示内容</li><li>退出码180跟52有什么关系</li></ul><br/><h2 id="进程为什么会退出"><a href="#进程为什么会退出" class="headerlink" title="进程为什么会退出"></a>进程为什么会退出</h2><p><img src="/images/signal_default.png"></p><p>根据man page里的描述，信号的默认处理行为有四种，52号信号属于实时信号，一个进程收到实时信号的默认行为，就是直接终止进程。<br><br/></p><h2 id="18号实时信号跟52号信号有什么关系"><a href="#18号实时信号跟52号信号有什么关系" class="headerlink" title="18号实时信号跟52号信号有什么关系"></a>18号实时信号跟52号信号有什么关系</h2><p><img src="/images/realtime.png"></p><p>根据man page里的描述，实时信号总共有32个，起始编号从SIGRTMIN开始，SIGRTMIN的值由Glibc决定，一般为34或35。显然，此处的52 &#x3D; 34 + 18。即52号信号，是 “实时信号 18”的另一种描述。<br><br/></p><h2 id="是什么地方打印了提示内容"><a href="#是什么地方打印了提示内容" class="headerlink" title="是什么地方打印了提示内容"></a>是什么地方打印了提示内容</h2><p>粗略分析，有3个地方可能打印了该内容，分别为kernel, shell, glibc。</p><p>通过对源码的分析，一一检索之后，发现是glibc打印了该提示。</p><p><img src="/images/strsignal.png"></p><p>这个打印是由glibc中的strsignal函数产生的。<br><br/></p><h2 id="退出码180跟52有什么关系"><a href="#退出码180跟52有什么关系" class="headerlink" title="退出码180跟52有什么关系"></a>退出码180跟52有什么关系</h2><p><img src="/images/exit_codes.png"></p><p>如图所示，180表示128 + 52，表示进程是被52号信号停止的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Signal </tag>
            
            <tag> Shell </tag>
            
            <tag> Glibc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言发展史及标准库梳理</title>
      <link href="/c-history/"/>
      <url>/c-history/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要内容来自网络上公开的资源，来源我贴在了最后。<br><br/></p><h2 id="C语言发展历史"><a href="#C语言发展历史" class="headerlink" title="C语言发展历史"></a>C语言发展历史</h2><p>简单的说，C语言是为了开发Unix系统而出现的，C语言最初的开发者是Dennis MacAlistair Ritchie和Kenneth Lane Thompson。</p><p>1973年，Unix系统的核心正式采用C语言改写。</p><p>C语言发展至今，按时间先后，使用的标准以及主要特性如下。<br><br/></p><h3 id="K-R-C"><a href="#K-R-C" class="headerlink" title="K&amp;R C"></a>K&amp;R C</h3><p>1975年，Brian Wilson Kernighan和Dennis MacAlistair Ritchie合作编写了一本书 《The C Programming Language》。书里介绍的C语言标准，被称为 K&amp;R C。</p><p>书中介绍的C语言特性主要包括：</p><ul><li>标准I&#x2F;O库</li><li>struct 类型</li><li>long int 类型</li><li>unsigned int 类型</li><li>把运算符 &#x3D;+和&#x3D;-改为+&#x3D;和-&#x3D;，以避免编译器在处理时产生混淆</li></ul><br/><h3 id="C89-ANSI-C"><a href="#C89-ANSI-C" class="headerlink" title="C89(ANSI C)"></a>C89(ANSI C)</h3><p>1989年，C语言被ANSI(美国国家标准协会)标准化，编号为ANSI X3.159-1989，因此这个版本的C语言既被成为C89，也被成为ANSI C。</p><p>C89引入的C语言特性主要包括：</p><ul><li>void函数</li><li>函数返回struct或者union类型</li><li>void *数据类型</li></ul><br/><h3 id="C90-ISO-C"><a href="#C90-ISO-C" class="headerlink" title="C90(ISO C)"></a>C90(ISO C)</h3><p>1990年，ISO(国际标准组织)开始成立工作组，来制定国际标准的C语言规范，ANSI随之接受ISO的标准，并宣布不再发展新的C语言标准。ISO发布标准，在ANSI C的基础上进行了改进，被称之为C90，或者ISO C。</p><p>C90对C语言的改进包括：</p><ul><li>增加了标准库</li><li>新的预处理命令和特性</li><li>函数原型允许在函数申明中指明参数类型</li><li>一些关键字，包括const、volatile与signed</li><li>宽字符、宽字符串与多字节字符</li><li>对约定规则、声明和类型检查的许多小改动与澄清</li></ul><p>1994年， ISO的WG14工作组，又对1985年颁布的标准(应该是C++标准)做了两处技术修订和一个补充，主要包括：</p><ul><li>3个标准库头文件iso646.h、wctype.h和wchar.h</li><li>几个新记号与预定义宏，用于对国际化提供更好的支持</li><li>printf&#x2F;sprintf函数一系列新的格式代码</li><li>大量的函数和一些类型与常量，用于多字节字符和宽字节字符</li></ul><br/><h3 id="C99"><a href="#C99" class="headerlink" title="C99"></a>C99</h3><p>1994年，ISO对C语言的修订和补充，引出了ISO 9899:1999的发表，这一标准又被成为C99。</p><p>C99引入的特性包括：</p><ul><li><p>增加了对编译器的限制，比如源代码每行要求至少支持到4095字节，变量名函数名的要求至少到63字节（extern要求支持到31字节）</p></li><li><p>增强了预处理功能，包括</p><ol><li>宏支持可变参数，即#define Macro(…) <strong>VA_ARGS</strong></li><li>使用宏的时候，允许省略参数，被省略的参数将被扩展成空串</li><li>支持&#x2F;&#x2F;开头的单行注释</li></ol></li><li><p>增加了新关键字restrict, inline, _Complex, _Imaginary, _Bool。支持long long, long double _Complex, float _Complex等类型</p></li><li><p>支持不定长的数组，即数组长度可以在运行时决定。但是，考虑到效率和实现，不定长数组不能在全局，或者struct,union中使用</p></li><li><p>变量声明不必放在语句块的开头，for语句提倡写成for(int i &#x3D; 0; i &lt; 100; ++i)的形式，即i只在for语句块内部有效</p></li><li><p>允许采用(type_name){xx,xx,xx}类似于C++的构造函数的形式构造匿名的结构体</p></li><li><p>初始化结构时，允许对特定的元素赋值，形式为</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct test &#123;</span><br><span class="line">    int a[3], b;</span><br><span class="line">&#125; foo[] = &#123;</span><br><span class="line">    [0].a = &#123;1&#125;,</span><br><span class="line">    [1].a = &#123;2&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct test &#123;</span><br><span class="line">    int a, b, c, d;</span><br><span class="line">&#125;foo = &#123;</span><br><span class="line">    .a = 1,</span><br><span class="line">    .c = 3, 4,</span><br><span class="line">    .b = 5</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>格式化字符串中，利用\u支持unicode的字符</p></li><li><p>支持16进制的浮点数的描述</p></li><li><p>printf&#x2F;scanf的格式化增加了对long long int类型的支持</p></li><li><p>浮点数的内部数据描述支持了新标准，可以使用 #pragma编译器指令指定</p></li><li><p>除了已有的__line__ __file__以外，增加了 <strong>func</strong> 获取当前函数名</p></li><li><p>允许编译器化简非常数的表达式</p></li><li><p>修改了 &#x2F;% 处理负数时的定义，这样可以给出明确的结果。在C89中 -22 &#x2F; 7 &#x3D; -3, -22 % 7 &#x3D; -1, 或者 -22 &#x2F; 7 &#x3D; -4, -22 % 7 &#x3D; 6。C99中明确为-22 &#x2F; 7 &#x3D; -3, -22 % 7 &#x3D; -1，结果是确定的。</p></li><li><p>取消了函数返回值默认为int的规定</p></li><li><p>允许在struct的最后定义的数组不指定其长度（变长数组）</p></li><li><p>const const int i 将被当作 const int i 处理</p></li><li><p>增加和修改了一些标准头文件，详情见下文对标准头文件的汇总</p></li><li><p>输入输出对宽字符以及长整数等做了相应的支持</p></li></ul><br/><h3 id="C11"><a href="#C11" class="headerlink" title="C11"></a>C11</h3><p>2011年12月8日，ISO正式发布了新的C语言标准C11，该标准早期被称为C1X，官方名为ISO&#x2F;IEC 9899:2011。</p><p>C11提高了对C++的兼容性，部分增加的特性包括：</p><ul><li><p>泛型宏</p></li><li><p>多线程</p></li><li><p>带边界检查的函数</p></li><li><p>匿名结构</p></li></ul><br/><h3 id="C18"><a href="#C18" class="headerlink" title="C18"></a>C18</h3><p>2018年6月，ISO发布了C18，官方名称为ISO&#x2F;IEC 9899:2018。</p><p>相比于C11，C18未引入新的语言特性，仅对C11进行了补充和修正。</p><hr><br/><h2 id="C语言标准库"><a href="#C语言标准库" class="headerlink" title="C语言标准库"></a>C语言标准库</h2><table><thead><tr><th align="left">名称</th><th align="center">用途</th><th align="center">最早引入标准</th></tr></thead><tbody><tr><td align="left">&lt;assert.h&gt;</td><td align="center">条件编译宏</td><td align="center">C89</td></tr><tr><td align="left">&lt;complex.h&gt;</td><td align="center">复数运算</td><td align="center">C99</td></tr><tr><td align="left">&lt;ctype.h&gt;</td><td align="center">字符类型判断</td><td align="center">C89</td></tr><tr><td align="left">&lt;errno.h&gt;</td><td align="center">涉及错误报告的宏</td><td align="center">C89</td></tr><tr><td align="left">&lt;fenv.h&gt;</td><td align="center">浮点数运算环境相关</td><td align="center">C99</td></tr><tr><td align="left">&lt;float.h&gt;</td><td align="center">float类型的限制</td><td align="center">C89</td></tr><tr><td align="left">&lt;inttypes.h&gt;</td><td align="center">int类型的格式转换</td><td align="center">C99</td></tr><tr><td align="left">&lt;iso646.h&gt;</td><td align="center">可选的运算符拼写方式</td><td align="center">C95</td></tr><tr><td align="left">&lt;limits.h&gt;</td><td align="center">基础类型大小</td><td align="center">C89</td></tr><tr><td align="left">&lt;locale.h&gt;</td><td align="center">本地化工具</td><td align="center">C89</td></tr><tr><td align="left">&lt;math.h&gt;</td><td align="center">通用的数学函数</td><td align="center">C89</td></tr><tr><td align="left">&lt;setjmp.h&gt;</td><td align="center">非本地跳转</td><td align="center">C89</td></tr><tr><td align="left">&lt;signal.h&gt;</td><td align="center">信号处理相关</td><td align="center">C89</td></tr><tr><td align="left">&lt;stdalign.h&gt;</td><td align="center">alignas和alignof 转换宏</td><td align="center">C11</td></tr><tr><td align="left">&lt;stdarg.h&gt;</td><td align="center">可变变量声明相关</td><td align="center">C89</td></tr><tr><td align="left">&lt;stdatomic.h&gt;</td><td align="center">原子操作相关</td><td align="center">C11</td></tr><tr><td align="left">&lt;stdbool.h&gt;</td><td align="center">boolean类型相关</td><td align="center">C99</td></tr><tr><td align="left">&lt;stddef.h&gt;</td><td align="center">通用的宏定义</td><td align="center">C89</td></tr><tr><td align="left">&lt;stdint.h&gt;</td><td align="center">固定长度的int类型</td><td align="center">C99</td></tr><tr><td align="left">&lt;stdio.h&gt;</td><td align="center">输入输出</td><td align="center">C89</td></tr><tr><td align="left">&lt;stdlib.h&gt;</td><td align="center">通用的工具：内存操作，程序工具，字符串转换，随机数</td><td align="center">C89</td></tr><tr><td align="left">&lt;stdnoreturn.h&gt;</td><td align="center">noreturn 宏相关</td><td align="center">C11</td></tr><tr><td align="left">&lt;string.h&gt;</td><td align="center">字符串处理</td><td align="center">C89</td></tr><tr><td align="left">&lt;tgmath.h&gt;</td><td align="center">泛类型的数学宏相关</td><td align="center">C99</td></tr><tr><td align="left">&lt;threads.h&gt;</td><td align="center">线程库</td><td align="center">C11</td></tr><tr><td align="left">&lt;time.h&gt;</td><td align="center">时间&#x2F;日期 工具</td><td align="center">C89</td></tr><tr><td align="left">&lt;uchar.h&gt;</td><td align="center">UTF-16 和 UTF-32 字符工具</td><td align="center">C11</td></tr><tr><td align="left">&lt;wchar.h&gt;</td><td align="center">拓展的多字节和宽字符工具</td><td align="center">C95</td></tr><tr><td align="left">&lt;wctype.h&gt;</td><td align="center">区分宽字符类型的函数</td><td align="center">C95</td></tr></tbody></table><br/><h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><ul><li><a href="https://zh.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80">Wiki&#x2F;C语言</a></li><li><a href="https://en.cppreference.com/w/c/header">C语言标准库列表</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式设备中的Linux引导方式</title>
      <link href="/embed-boot/"/>
      <url>/embed-boot/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>主要是总结Linux的引导过程，包括:</p><ul><li>从开机到控制权交接给内核</li><li>内核初始化过程</li><li>用户空间初始化过程</li></ul><p>本文参考的Linux代码版本是2.6.x，是比较老的版本，如果与最新的代码特性有出入，以最新的为主。<br><br/></p><h2 id="嵌入式设备的关键属性"><a href="#嵌入式设备的关键属性" class="headerlink" title="嵌入式设备的关键属性"></a>嵌入式设备的关键属性</h2><p>嵌入式设备和非嵌入式设备并没有明确的界限，嵌入式设备通常具有以下属性：</p><ul><li>包含一个处理引擎，比如通用微处理器</li><li>一般是针对某种具体的应用或目的设计的</li><li>用户界面通常不是考量的关键因素，甚至会为了安全性而牺牲一部分可用性</li><li>资源通常受限，比如没有硬盘，供电受限等等</li><li>应用程序通常是内置的，出厂时，软硬件均已经集成完善。</li></ul><br/><h2 id="从开机到控制权交接给内核"><a href="#从开机到控制权交接给内核" class="headerlink" title="从开机到控制权交接给内核"></a>从开机到控制权交接给内核</h2><p>对于这一过程的概述，嵌入式设备和一般的桌面PC设备稍有差别，也可以说是ARM世界和x86世界的差别。</p><p>在一般的桌面PC系统中，通电之后，Bios立刻接管了设备，在完成硬件自检等工作后，跳转，将控制权交给Bootloader，如果硬盘里不只安装了一个系统，在Bootloader这一步可以决定启动哪一个操作系统。在这个语境中，Bios被称为“first-stage boot loader”，bootloader被称为“second-stage boot loader”。主流的Bootloader包括bootmgr, grub等等。</p><p>在嵌入式设备中，通常不会有多个系统的情况，因此，不需要将整个引导过程拆成两步进行。所以，嵌入式设备中，很少使用bios的概念，而是直接将两个步骤统称为 bootloader，本文以下内容涉及到的bootloader，除非特别说明，都是指嵌入式开发中的概念。</p><p>在嵌入式设备中，bootloader的关键职能，包括：</p><ul><li>初始化关键的硬件，比如SDRAM控制器，I&#x2F;O控制器和图形控制器</li><li>为外设控制器分配必要的系统资源，比如内存和中断电路</li><li>提供一个定位和加载操作系统镜像的机制</li><li>加载操作系统，并将控制权移交给它，同时传递必要的启动信息。内容可能包括内存总容量、时钟频率、串行端口频率（波特率）等等</li></ul><p>嵌入式开发过程中，使用最为广泛的bootloader便是U-Boot。本文不会过多的涉及U-Boot的内容，以避免行文过于臃肿，U-Boot的用法可以参考<a href="#supplement">补充内容</a>。</p><br/><h2 id="内核空间初始化过程"><a href="#内核空间初始化过程" class="headerlink" title="内核空间初始化过程"></a>内核空间初始化过程</h2><p>如果bootloader引导顺利的话，控制权接着就转交给了linux内核。</p><p>Linux内核的引导过程比较复杂，本文从<strong>源码</strong>角度简单介绍下其中比较重要的几个环节。</p><br/><h3 id="内核入口-head-S"><a href="#内核入口-head-S" class="headerlink" title="内核入口 head.S"></a>内核入口 head.S</h3><p>head.S位于..&#x2F;arch&#x2F;<ARCH>&#x2F;kernel&#x2F;head.S，从目录也可以看出，该文件是用来处理架构相关的初始化工作，主要有以下的作用：</p><ol><li>检查处理器和架构的有效性</li><li>创建初始的页表（page table)表项</li><li>启用处理器的内存管理单元（MMU）</li><li>进行错误检测并报告</li><li>跳转到内核主体的起始位置，即main.c中的函数start_kernel()</li></ol><br/><h3 id="内核开始-main-c"><a href="#内核开始-main-c" class="headerlink" title="内核开始 main.c"></a>内核开始 main.c</h3><p>该文件位于..&#x2F;init&#x2F;main.c中，如前文所述，head.S在执行结束后，将开始执行main.c中的start_kernel()。main.c完成大部分内核启动工作，从初始化第一个内核线程开始，直至挂在根文件系统并执行最初的用户空间Linux应用程序。</p><p>主要工作及过程如下：</p><ol><li><p>架构设置</p><p> 通过调用setup_arch(),完成对某种架构通用的初始化工作，该参数接受一个指向内核命令行的指针 –&gt; setup_arch(&amp;command_line)</p></li><li><p>内核命令行的处理</p><p> 内核命令行是引导程序启动时，向内核传递的参数，相比与编译时指定的参数，cmdline要灵活得多。一个典型的cmdline通常如下:</p><blockquote><p>console&#x3D;ttys0,115200 root&#x3D;&#x2F;dev&#x2F;nfs</p></blockquote><p> cmdline拥有的参数可以多达上百个，内核中使用__setup宏将cmdline与相关的模块关联起来。其一般用法如下所示：</p><blockquote><p>__setup(“console&#x3D;”, console_setup);</p></blockquote><p> 含义为，当cmdline中遇到console&#x3D;字符串时，就调用__setup宏的第二个参数指定的函数。详细的过程涉及到ELF文件的生成和链接器的使用，不在本文的讨论范围。内核会遍历cmdline中的参数，并调用相应的处理函数。</p></li><li><p>子系统的初始化</p><p> 子系统的初始化有两种方式，一种是显式初始化，比如调用init_timers()函数，console_init()函数，另外一种是借助类似__setup宏这种技巧实现的初始化，承担这种宏有一个系列*__initcall，具体过程本文不涉及。</p></li><li><p>init线程</p><p> 执行到这里，内核生成了第一个内核线程 – init线程。init线程是Linux所有用户空间进程的父进程。需要说明的是，对于linux来说，并没有严格区分线程和进程，他们由同一种结构表示，区别在于资源的调度。</p></li><li><p>最后的引导步骤</p><p> 在完成初始化工作之后，内核开始执行最后的引导步骤，包括：</p><ul><li>释放初始化函数和数据占用的内存</li><li>打开系统控制台设备</li><li>启动第一个用户空间进程</li><li>….</li></ul> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (execute_command) &#123;</span><br><span class="line">    run_init_process(execute_command);</span><br><span class="line">    printk(KERN_WARNING &quot;Failed to execute %s. Attempting&quot;</span><br><span class="line">            &quot;defaults...\n&quot;, execute_command);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run_init_process(&quot;/sbin/init&quot;);</span><br><span class="line">run_init_process(&quot;/etc/init&quot;);</span><br><span class="line">run_init_process(&quot;/bin/init&quot;);</span><br><span class="line">run_init_process(&quot;/bin/sh&quot;);</span><br><span class="line"></span><br><span class="line">panic(&quot;No init found, Try passing init= option to kernel&quot;);</span><br></pre></td></tr></table></figure><p> 上述代码来自main.c中的init_post函数最后一段，如果该函数执行到最后，将会产生一个”No init found”的错误，这也是嵌入式开始过程中见到比较多的一个错误。run_init_process执行成功后，并不会返回，而是通过execve()系统调用生成一个新进程覆盖旧进程，因此，init过程是第一个执行成功的run_init_process函数。</p></li></ol><br/><h2 id="用户空间初始化"><a href="#用户空间初始化" class="headerlink" title="用户空间初始化"></a>用户空间初始化</h2><p>根文件系统，简单的说，就是内核挂载最早的文件系统。如上文所说，内核引导的最后，会试图通过run_init_process执行类似&#x2F;sbin&#x2F;init的二进制程序。根文件系统，在进行到最后的引导步骤前，就已经初始化并挂在完成。</p><p>根文件的生成，挂在过程，会在另外一篇blog中详细介绍。在run_init_process执行成功后，第一个用户态程序便开始执行了。<br><br/></p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a><span id="supplement">补充</span></h2><br/><h3 id="1-dtb-dts-dtc介绍及常用用法"><a href="#1-dtb-dts-dtc介绍及常用用法" class="headerlink" title="1. dtb,dts,dtc介绍及常用用法"></a>1. dtb,dts,dtc介绍及常用用法</h3><p>dts,即device tree source。是arm嵌入式中，用于描述硬件的方式。dts通过dtc工具，生成供内核使用的dtb文件。</p><br/><h3 id="2-U-Boot的一般用法"><a href="#2-U-Boot的一般用法" class="headerlink" title="2. U-Boot的一般用法"></a>2. U-Boot的一般用法</h3><ul><li><p>加载内容镜像到固定内存地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tftp 600000 uImage</span><br></pre></td></tr></table></figure></li><li><p>加载dtb到固定内存位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tftp c00000 dtb</span><br></pre></td></tr></table></figure></li><li><p>根据之前的dtb开始引导系统</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bootm 600000 - c00000</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p>从磁盘引导</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diskboot Ox400000 0:0</span><br></pre></td></tr></table></figure><p>此处中的0：0指第一个IDE设备的第一个分区</p></li><li><p>从内存的某个位置开始引导</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bootm Ox400000</span><br></pre></td></tr></table></figure></li></ul><hr><br/><h2 id="需要区分的概念"><a href="#需要区分的概念" class="headerlink" title="需要区分的概念"></a>需要区分的概念</h2><ul><li>BIOS-MBR 与 GPT-UEFI</li><li>GRUB, GRUB2</li><li>ROM 与 EEPROM</li><li>U-boot</li><li>dtb, dtc, dts</li></ul><br/><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《嵌入式LINUX基础教程（第2版）》 第1章至第7章</li><li><a href="https://neosmart.net/wiki/mbr-boot-process/">The BIOS&#x2F;MBR Boot Process</a></li><li><a href="https://en.wikipedia.org/wiki/Booting">booting</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Uboot </tag>
            
            <tag> Bootloader </tag>
            
            <tag> Bios </tag>
            
            <tag> Arm </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
