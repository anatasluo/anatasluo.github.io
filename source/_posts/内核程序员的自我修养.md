---
title: 内核程序员的自我修养
date: 2020-06-05 11:05:11
tags:
    - Programmer
---

## 前言

本来这是一篇讲解什么是内核程序员，以及作为一个内核程序员，我准备如何构建技术栈的博客。但是，我准备写一点，在我成为一个内核程序员之前的事情，复盘一下我是如何一步步做出这些选择的。

## 技术方向选择的困惑

作为一个计算机科学专业出身的学生来说，有个问题一直困扰着我。那就是，我应该学习什么。学校教授给我的课程覆盖了方方面面，语言方面就涵盖C语言，Python，C++，Java，更不要提游戏设计，网站设计此类的课程。课程体系覆盖的面很广，但是缺少深度和难度。我需要找一个方向，深耕下去。构建完整知识体系的同时，也能在某个领域有深刻的见解。

根据知识体系和兴趣，我考虑过以下几个方向：

1. 前端，技术栈围绕nodejs和angular构建
2. 后端，技术栈围绕Golang构建
3. 信息安全，准确点来说，是网络安全

### nodejs相关的前端

大二暑假的时候，我在Coursera上接触了一门[全栈课程](https://www.coursera.org/specializations/full-stack-react?#about)，在后面的相当长的一段时间内，我都围绕着第一方向，构建自己的技术栈。参加过一些软件比赛，拿过一些奖，甚至实习都是做的前端开发，尽管是vue相关的。秋招过程中，学长看过我简历后，认为我更适合后端，当时没有仔细考虑学长的建议，颇为后悔。

现在来看，围绕这个思路，这个成长过程存在以下问题
+ 我对前端的理解，始终停留在解决问题的思路上，我能很快接受新知识，并且利用这些知识解决自己的问题，但是从来没去系统学习过。我没了解过JS的闭包，对浏览器的渲染过程知之甚少，诸如此类。
+ 后续的成长过程中，我的兴趣更偏向于设计和美工，失去了探索前端技术本身的动力，而且对JavaScript的设计哲学和理念也不是很认同，逐步丧失了成长的基础。

### golang相关的后端

意识到这个问题的时候，已经是实习结束，处在大三的末尾了，我很清楚，我不会把前端作为我的方向，开始寻找其他可能。恰好这个时候，golang作为一门新语言，正在强势崛起，实习的时候因为业务需要，也有所接触。我意识到，这门语言的前景十分广阔。因此，就有了后来的[ant](https://github.com/anatasluo/ant)项目，这也是我的毕业设计。我结合自己的前端优势，通过项目加深了对golang的学习，在Github上小有收获。对我来说，是个很大的鼓励。后面的很长一段时间，我也在坚持学习golang相关的东西，19年底的时候也尝试社招过相关的岗位。整体上来说，这个方向要比前端有吸引力的多，包括兴趣的吻合，实际的收益等等。

### 网络安全

会想到做信息安全，是因为大学时候我是打ACM出身，也了解过一些CTF的知识。刚接触的时候，给我打开了新世界，这是一种直观表现计算机水平的方式，不仅是对内行人展示，更重要的是对外行人展示。每个男孩子都有一个侠客梦想，我在相当长的一段时间内，在CTF上投入了很多精力。小有收获，但是专业性却十分欠缺。毕竟，我既不是信息安全专业出身，也找不到足够的人跟我一起参考正式的CTF比赛，属于玩票兴致，找工作几乎没指望。

## 内核工程师

时间节点来到毕业前，尽管因为对技术方向的错误选择，让我在nodejs上浪费了大量精力，但是却培养了我对Linux的兴趣。自己写网站，就需要自己去搭建网站，维护网站服务器，数据库服务器等等。这里面遇到的奇奇怪怪的问题，都需要自己去解决，无形中让我有了一定的运维基础。

对Linux的兴趣，进一步培养了我对开源的兴趣，以致于后来了解到GNU运动，更是一发不可收拾。因此，在秋招拿到来自一个参与操作系统内核开发的机会时，我就毫不犹豫的选择了，尽管那时我都不知道什么是内核开发，以及内核开发要做什么。但是，这个听起来就很酷。

经过一年时间的快速学习，作为内核工程师，我收获很多，我对编译链接，二进制，内核的调度等等都有了长足的掌握。但是，这个问题仍然困扰着我，那就是 —— 我应该如何深入。在后面的行文中，我将尝试解决以下问题：

+ 什么是内核工程师
+ 内核工程师的技术栈构建

### 什么是内核工程师

一般来说，很少有机会去让我们写一个内核。原因很多，首先，内核是个很复杂的东西，不仅仅在于代码规模，更在于内核对代码质量要求很高，需要开发者的素养很好。其次，计算机体系结构近些年的发展缓慢，内核没什么新的技术发展，开源世界的Linux在大多数情况下，就是最经济实用的解决方案。因此，在几乎大多数语境下，内核工程师，就是指的Linux内核工程师，这些人中，有一部分专注于驱动开发，有一部分专注于性能优化，也有一部分做虚拟化之类的东西，总之，都需要对Linux内核有很深的理解。

### 内核的起源 -- 贝尔实验室

因为内核涉及的东西实在太宽泛了，作为内核工程师，从何处开始积累，这个问题困扰了我相当长的一段时间。在开始解释这个问题前，我想先讲一群人 —— 贝尔实验室。

贝尔实验室(Bell Labs)是当时的通信业巨头AT&T的一个研发机构，贝尔实验室的肯·汤普逊(Ken Thompso)、丹尼斯·里奇(Dennis Ritchie)、道格拉斯·麦克罗伊(Douglas McIlroy)于1969年开发出了unix内核。为了完成unix的开发，他们于1967年左右设计出了BCPL语言，在1970年，进一步发展出了C语言。1979年，同样供职贝尔实验室的比雅尼·斯特劳斯特鲁普(Stroustrup)，受当时流行的程序语言Simula、ALGOL 68、Ada、ML等影响，开发出了C with class。这门语言，既保持了C语言的底层支持优势，也吸取了OOP的开发效率优点，这门语言于1983年改名为C++。

从C语言到unix内核，再到C++的出现，这三者可以说是紧密联系，相辅相成的。unix内核的发展，为后续很多内核的出现提供了蓝本，相当多的理念都被其他内核吸收，并进一步发扬光大。

在长时间的C语言开发过程中，我深刻体会到作为底层语言的C语言，相比于纯OOP的Java语言，开发效率的底下，设计模式的单一。尽管Linux内核仍然采取C语言编写，但是在内核的开发过程中，出现了相当多的伪OOP的用法。比如一union类型中，放置不同类型的成员变量，根据type字段，将union解释成不同的类型。在我看来，这就是一种最原始的继承实现。后来，看了*Inside the C++ Object Model*，发现早期的C++就是用C这么实现的。C++对于内核的开发可能过于复杂(要不然也不会一直使用C开发内核)，但是C++相当多的特性，确实是一种开发效率上的长足进步。因此，C++的出现是一个很自然的事情，倒不如说，C++在保持对C相当兼容的同时，仍然支持OOP，无论如何都是一个非常惊艳的设计。

当然，由于C++过于复杂的特性，使得开发人员困苦不堪，在2007年左右，肯·汤普逊又参与开发了一门新语言的设计，也就是后来的golang。

### 内核技术栈

在对编程语言的掌握上，包括:

+ C语言
    <div style="text-indent:0em;padding:2em">C语言相对来说，是一门比较容易的语言。但是实际使用过程中，需要对编译器的方方面面都有所了解，才能对内核的行为有充分的掌握。</div>
+ C++
    <div style="text-indent:0em;padding:2em">对C++的学习，不单单能写出更优雅的C语言，早期的C++就是编译成C语言实现的，更重要的是，OOP已经发展成了编程语言中主流，对C++的掌握，也能对设计模式，异常处理等等一窥全貌，培养更深的兴趣。</div>
+ golang
    <div style="text-indent:0em;padding:2em">golang为了弥补C和C++的不足而出现，同样出自肯·汤普逊之手，处在快速崛起的时期，未来的潜力不可估量。</div>

总之，这三门语言血脉相连，有着相同的历史传承，设计上也有诸多相似之处，学习起来可以相互映照，相辅相成。既能对底层的世界一窥究竟，也能培养出对上层世界的兴趣。

在对基础学科的掌握上，包括:

+ 汇编语言
+ 编译原理
+ 编程语言
+ 操作系统
+ 设计模式
+ 软件工程

从汇编语言到编译原理，再到编程语言。都是为了讲清楚，底层世界是如何一步步构建起来的，以及构建过程中最重要的工具 —— 编程语言，是如何设计的。操作系统，则是在此基础上，为上层世界构建运行环境，因为操作系统通常又可以被称为"软硬件接口"。再往上，设计模式和软件工程，就是讲如何在操作系统构建的环境之上，进一步高效的构建应用。到这里，整个计算机世界，就都被串联起来了。当我写下“class A {};”的时候，我很容易就能想到，最后这串代码在内存的模型是什么样的，编译成的汇编又会是什么样的，这是一件尽在掌握中的满足感。

### 技术栈展开

编程语言和基础学科的学习过程，是相互促进的，不存在严格的先后关系，下面整理了我当前以及后续学习过程使用的材料。

#### C++

书籍：
1. C++ Primer(第五版)
2. Inside the C++ Object Model
3. STL源码剖析(侯捷著)
4. Effective C++
5. More Effective C++

网站：
1. [Bjarne Stroustrup's C++ Style and Technique FAQ](http://www.stroustrup.com/bs_faq2.html)
2. [计算机书籍控](http://bestcbooks.com/recommended-cpp-books/)

概念和问题：
1. C++的特性能用C来实现吗，如果可以，如何实现
2. C++的历史发展和新特性(C++11)

#### 汇编语言、编译原理和编程语言

书籍:
1. 汇编语言(王爽著)
2. Understanding Programming Languages

概念和问题：
1. 汇编和C语言的调用接口和规范 -- AACPS(ARM中的规范)
2. 当前的主流编译器实现，他们之间的区别
3. 什么是IR
4. 如何评价一门编程语言，不同语言间如何比较


#### 操作系统

概念和问题：
1. 当前主流内核之间的联系和发展历程
2. 对内核最深入的一个模块

## 结尾

这篇博客，看起来更像是我学习过程中的一个书单。当我看到贝尔实验室这段发展历史的时候，整个思路豁然开朗。无论是什么学科，对于学科历史的了解都是十分必要的，这些历史，解释了这门学科为什么发展成这样，以及解释了未来可能会是什么样。作为一个内核工程师，我沿着这群人的步伐，从底层的机器语言世界，到上层的设计模式，整个计算机世界都自然的在我眼前展开，这既让我满怀欣喜和期待，又十分忐忑畏惧。总之，这是一个很好的进展，我对于我将沿着这一道路深信不疑。

## 参考

+ [C++维基词条](https://zh.wikipedia.org/wiki/C%2B%2B)