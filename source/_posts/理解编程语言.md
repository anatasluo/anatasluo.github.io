---
title: 理解编程语言
date: 2020-02-14 00:06:01
tags:
- Program Language
---


## 前言

本篇blog是 *Understanding Programming Languages* (M.Ben-Ari) 的读书笔记，主要是介绍编程语言的常见知识，包括编程语言的定义，组成以及设计等等。

--------------------
<br/>

## 编程语言定义，组成及编程环境
<br/>

### 编程语言定义

对程序员来说，编程语言只是编程的工具，很多程序员沉迷于比较不同的编程语言，但是缺乏分析不同语言特点的能力。

编程语言知识的匮乏，导致以下问题：

1. 尽管计算机硬件和现代软件系统的爆炸发展，大多数人仍然使用1970年甚至更早之前发展出的语言。编程语言的发展落后，使得程序员不得不采用更多的工具和方法进行弥补。
2. 在选择开发语言时，没有充分考虑安全性和效率，导致开发出的项目难以维护，开发者常常通过汇编而不是算法和编程本身来解决效率问题。

编程语言的存在，是为了弥补硬件和真实世界之间的不同抽象差距。高抽象的语言易于理解和使用，低抽象的语言则更为灵活和高效。设计和选择一门语言，就是选择一种合适的抽象。

从数学上来说，一个程序是详细说明一个运算过程的一段符号序列。一门编程语言是描述这个序列如何构成以及运算过程含义的规则集合。
<br/>

### 编程语言分类

在wiki百科中，对编程语言分类方式的描述是：

> 编程范式、编程范式或程序设计法(Programming paradigm)，是一类典型的编程风格，是指从事软件工程的一类典型的风格。如函数式编程、过程式编程、面向对象编程、指令式编程等等为不同的编程范型。
> 
> 编程范型提供了（同时决定了）程序员对程序执行的看法。例如，在面向对象编程中，程序员认为程序是一系列相互作用的对象，而在函数式编程中一个程序会被看作是一个无状态的函数计算的序列。
> 
> 正如软件工程中不同的群体会提倡不同的“方法学”一样，不同的编程语言也会提倡不同的“编程范型”。一些语言是专门为某个特定的范型设计的（如Smalltalk和Java支持面向对象编程，而Haskell和Scheme则支持函数式编程），同时还有另一些语言支持多种范型（如Ruby、Common Lisp、Python和Oz）。
> 
> 很多编程范型已经被熟知他们禁止使用哪些技术，同时允许使用哪些。例如，纯粹的函数式编程不允许有副作用；结构化编程不允许使用goto。可能是因为这个原因，新的范型常常被那些习惯于较早的风格的人认为是教条主义或过分严格。然而，这样避免某些技术反而更加证明了关于程序正确性——或仅仅是理解它的行为——的法则，而不用限制程序语言的一般性。
> 
> 编程范型和编程语言之间的关系可能十分复杂，由于一个编程语言可以支持多种范型。例如，C++设计时，支持过程化编程、面向对象编程以及泛型编程。然而，设计师和程序员们要考虑如何使用这些范型元素来构建一个程序。一个人可以用C++写出一个完全过程化的程序，另一个人也可以用C++写出一个纯粹的面向对象程序，甚至还有人可以写出杂揉了两种范型的程序。

以下是常见的分类：
<br/>

#### 指令式语言和声明式语言

指令式语言(Imperative programming)，即详细的描述整个过程，一步步的告诉计算机如何完成计算过程。
考虑一个简单的数学问题 —— 从一组数中寻找最大数，对于指令式语言来说，过程通常如下：

1. 创建一个用于保存结果的变量
2. 遍历数组，一一比较
3. 将最终的结果返回


声明式语言(Declarative programming)，即告诉计算机结果应该满足的条件，由编译器来决定如何获得结果。

相同的问题，对声明式语言来说，最大的数就是结果限制，编译器会自动推导出过程。

声明式语言,主要用于处理大量数据或者那些解决过程无法被详细描述的问题，包括：
+ language processing(语言处理)
+ pattern matching(模式匹配)
+ process optimization(模型优化)

指令式语言和声明式语言是一个相对的概念，如上文所说，编程语言是为了弥补硬件和真实世界之间的抽象差距。对于最底层的CPU指令来说，其核心就是用“变量定义 + 顺序执行 + 分支判断 + 循环”来表达逻辑过程。上层的应用，则是通过层层封装，来表现现实世界中的过程。越接近底层的表达，就越“指令式";越接近现实世界的表达，就越“声明式”。

一般来说，C/C++，Java，JavaScript，Python等等被认为是指令式语言。SQL，HTML/CSS等等被认为是声明式语言。指令式语言通常需要更多的表达，声明式语言通常在效率上有所损失。
<br/>

#### 编译型语言和解释型语言

编译型和解释型语言的差别在于，生成目标CPU指令的时机不同。编译型是语言是源代码通过编译器，直接生成特定CPU体系的可执行文件。解释型语言通过源代码生成一种**平台无关**的中间代码，在运行过程中再将中间代码解释成目标平台的CPU指令。

一般认为C/C++等等是编译型语言，JavaScript、Python等等是解释型语言。相对来说，编译型语言效率更高，解释型语言更为灵活。但是，当前编程语言的发展，编译型语言和解释型语言的界限并不是特别清晰，考虑以下几个情况：

+ Java代码首先会被编译成虚拟机指令，然后，由虚拟机执行的时候，翻译成目标架构CPU指令。在一些教科书上，Java被成为半编译型或者混合型语言。

+ Python既可以直接解释源代码执行，也可以编译成虚拟机指令后，运行。

+ C#的源代码会首先被编译成一种中间文件，然后，借助.Net Framework虚拟机，通过中间代码，直接生成目标CPU架构的可执行文件。接着，直接执行该可执行文件。

+ 通过V8引擎，JavaScript源码可以直接生成目标CPU架构指令。这种应用在解释器上的技术，被称为JIT(即时编译, Just-In-Time)。对于解释型语言来说，通过JIT，再将生成的目标文件缓存起来，与编译型语言直接生成可执行文件，其实是没有太大区别的。

如上文所说，编程语言本质是为了弥补硬件和真实世界之间的抽象差距。所谓编译型/解释型，只是最终生成目标CPU指令的时机不同。两者之间的界限是非常模糊的，在一下情况下，甚至是可以相互转化的。
<br/>

#### 面向数据编程

面向数据编程，即围绕着一种数据结构以及与数据结构相关的操作进行编程。这种编程范式在编程语言发展早期非常流行，这种编程语言主要用于科学计算和研究中，从数学的角度，而不是从工程的角度来实现语言。

支持该种设计的语言包括：

+ Lisp: Lisp的基本数据结构是linked list，当前，Lisp主要活跃在人工智能领域。
+ APL : APL的基本数据结构是vectors和matrics, APL是从数学形式体系中发展出来的。
+ Snobol, Icon :Snobol和Icon的基本数据结构是string，主要用于文本处理。
+ SETL: SETL的基本数据结构是set，用于数学计算。

这种类型的语言，当前已经不再那么流行，主要由于以下两个原因：

1. 面向对象语言，拥有类似的能力。
2. 函数式编程和逻辑式编程概念的出现。

<br/>

#### 面向对象编程(OOP)

面向对象编程(Object-oriented programming, OOP)，即将对象作为基本单元的编程方式。对象，是对真实世界中物体概念的抽象，对象包括数据以及对相应数据的操作。

最早出现的OOP语言是Simula，于20世纪60年代由K.Nygaard和O.-J.Dahl开发，用于系统仿真。

早期OOP中发展出的最重要的概念为 -- 动态(dynamic, run-time)内存分配，动态运行调度，动态类型检查。区别于静态(static, compiler-time)，动态会带来额外的时间和内存花销。

C++既支持静态内存分配和静态类型检查的，也支持OOP的动态内存分配和动态类型检查。这表明，动态和静态的设计并不冲突，动态可以在需要的时候使用。就OOP来说，Java要比C++的设计更为“纯粹”。
<br/>

### 编程语言标准化

编程语言的标准化，对编程语言的发展至关重要。但是，标准化常常是滞后于编程语言发展的。以C语言为例，gcc实现的很多特性，并不是标准C语言支持的，这些特性有些被广泛接受，成为后续标准的一部分，有些没有被接受。如果这些非标准的特性被使用，一定要特别谨慎，因为这会导致程序的兼容性变差。
<br/>

### 编程语言存在的理论基础(可计算性)

在20世界30年代，早于电子计算机发明之前，逻辑学家已经开始研究计算的抽象概念。Alan Turing和Alonzo Church分别提出一种经典，简单的计算模型，分别叫做图灵机和λ演算。随后，Church-Turing 猜想被提出：

> 任何在算法上可计算的问题同样可由图灵机计算。

尽管该猜想未能被证明，但是，到目前为止，几乎是被全面接受的。

图灵机的基本思想使用机器来模拟人们用纸笔来进行数学运算的过程，图灵机将这种过程分成四步：
1. 一条无限长的纸带TAPE。纸带被划分为一个接一个的小格子，每个格子上包含一个来自有限字母表的符号，字母表中有一个特殊的符号□表示空白。纸带上的格子从左到右依次被编号为0, 1, 2, ...，纸带的右端可以无限伸展。
2. 一个读写头HEAD。该读写头可以在纸带上左右移动，它能读出当前所指的格子上的符号，并能改变当前格子上的符号。
3. 一套控制规则TABLE。它根据当前机器所处的状态以及当前读写头所指的格子上的符号来确定读写头下一步的动作，并改变状态寄存器的值，令机器进入一个新的状态，按照以下顺序告知图灵机命令：
    1. 写入（替换）或擦除当前符号；
    2. 移动 HEAD， 'L'向左， 'R'向右或者'N'不移动；
    3. 保持当前状态或者转到另一状态
4. 一个状态寄存器。它用来保存图灵机当前所处的状态。图灵机的所有可能状态的数目是有限的，并且有一个特殊的状态，称为停机状态。参见停机问题。

图灵机的模型是如此简单，任何编程语言都可以实现对图形机的模拟。因此，如果图灵机可以解决一个问题，那么编程语言同样可以。
<br/>

### 编程语言的构成元素
<br/>

#### 句法(Syntax)

句法，是定义编程语言中有效符号序列的规则集合。

句法，通过形式记号(formal notation)来描述。句法中最广泛使用的形式记号是扩充巴科斯范式(Extended Backus-Naur Form，EBNF)。

句法相关的常见错误包括：

+ 标识符的长度限制
+ 大小写是否敏感
+ 注释的不同写法
+ 写法接近但含义完全不同的符号(= vs ==)
+ 分割符

<br/>

#### 语义(Semantics)

语义，是编程语言中表达式的含义，即描述程序如何在不同状态之间进行转换。

形式化编程语言语义(a formalization of the semantics of programming languages)的好处在于，程序的正确性很容易得到证明。如果程序的输入数据满足要求，那么相应的输出也将符合预期。
<br/>

#### 数据(Data)

编程语言中，都会有对数据的抽象。即使是最底层的汇编语言，也是基于对寄存器、内存单元之类的物理实体的操作。因此，编程语言可以有如下定义：

type(类型): 值，以及对这些值的操作的集合
value(值): 一个未定义的基本概念
Literal: 程序中文字声明的特定值
Representation: 值在计算机中的二进制表示
Variable: 存储值的内存单元名称
Constant: 不变的值
Object: variable or Constant

对于一个Variable来说，一定是某个特定的类型。因为，只有知道了类型，编译器才能分配相应的内存。
<br/>

#### 赋值语句

编程语言的赋值过程分为3步：

1. 计算右值
2. 计算左值地址
3. 将右值存储于左值地址

<br/>

#### 类型检查

类型检查用于检查赋值过程中右值结果与左值类型是否兼容。

赋值包括函数调用过程中，将实参赋给形参，可能的结果有3种：
1. 类型一致
2. 隐式转换
3. 无法转换，报错

类型转换是可靠性和便捷性之间的一种权衡。
<br/>

#### 控制语句

控制结构有2种：
1. 选择语句
2. 循环语句

<br/>

#### 子程序和模块

对于大型的工程来说，不同的程序语言，提供了不同的组织方式。比如，C语言的.c，.h文件，Java的包管理器等等。
<br/>

### 编程环境

使用编程语言的过程中，需要一系列的工具，包括：

+ 编辑器
+ 编译器/解释器
+ 链接器
+ 装载器
+ 库管理工具
+ 调试器
+ 分析器
+ 测试工具
+ 配置工具

<br/>

## 编程语言的基本概念

<br/>

### 基本数据类型


待填坑.....

<br/>

## 参考


1. [声明式编程和命令式编程有什么区别？](https://www.zhihu.com/question/22285830)
2. [解释型语言和编译型语言的区别](https://blog.csdn.net/zhu_xun/article/details/16921413)
3. [程序的编译与解释有什么区别？](https://www.zhihu.com/question/21486706)
4. [JavaScript、Node.js与V8的关系](https://segmentfault.com/a/1190000014722508)
5. [编程范型](https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%9E%8B)
6. [邱奇－图灵论题](https://zh.wikipedia.org/wiki/%E9%82%B1%E5%A5%87%EF%BC%8D%E5%9B%BE%E7%81%B5%E8%AE%BA%E9%A2%98)
7. [图灵机](https://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E6%9C%BA)
8. [扩充巴科斯范式](https://zh.wikipedia.org/wiki/%E6%89%A9%E5%85%85%E5%B7%B4%E7%A7%91%E6%96%AF%E8%8C%83%E5%BC%8F)