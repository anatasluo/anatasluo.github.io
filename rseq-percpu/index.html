<!DOCTYPE html>
<html lang="zh" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="author" content="anatasluo" />
  <!-- Open Graph Description 简短摘要-->
  
  <!-- 用于搜索引擎的文章摘要 -->
  
  
  
  <title>
    
      Per-CPU及RSEQ机制分析 
      
      
      |
    
     anatasluo
  </title>

  
    <link rel="apple-touch-icon" href="/images/favicon.ico">
    <link rel="icon" href="/images/favicon.ico">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  <link rel="stylesheet" href="/css/main.css" />
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css" />
  <!-- 代码块风格 -->
  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  

  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 7.3.0"></head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="/images/huahua.jpg" alt="">
      
    </a>
    <div class="nickname"><a href="/">anatasluo</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/tags/">
          <a href="/tags/">Tags</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">About</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="/plugins/mathjax/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.10/dist/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">Per-CPU及RSEQ机制分析</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
          2025-05-12 14:45:59
        </span>
        
              <span class="post-tags">
                <i class="iconfont icon-tags mr-10" title="Tags"></i>
                
                <span class="span--tag mr-8">
                  <a href="/tags/Per-CPU/" title="Per-CPU">
                    #Per-CPU
                  </a>
                </span>
                
                <span class="span--tag mr-8">
                  <a href="/tags/RSEQ/" title="RSEQ">
                    #RSEQ
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <h2 id="Per-CPU"><a href="#Per-CPU" class="headerlink" title="Per-CPU"></a>Per-CPU</h2><h3 id="设计的出发点和优点"><a href="#设计的出发点和优点" class="headerlink" title="设计的出发点和优点"></a>设计的出发点和优点</h3><p>现代的cpu都有cache hierarchy的设计，这一设计会极大的加快cpu访问内存的速度。但是cache的引入会带来内存访问一致性的问题。比如一个变量对多个核是可见的，对值的修改将导致所有其他核中缓存的该值失效，需要重新load最新的值，这将带来极大的效率损失。</p>
<p>考虑一种场景，服务器需要统计对磁盘的访问速度，正常的设计会使用一个全局的统计值，通过原子变量或者其他同步机制去修改该统计值。但是，通过per-cpu机制，每个cpu在调度运行时，只需要修改自己的值就可以了。这样一来，在这个值上面，cpu之间将不存在竞争。如果需要获得全局的统计值，依次相加即可。</p>
<p>当然，per-cpu带来性能提升带前提是，程序修改值的时间要远远大于读取统计值的时间。这一前提大多数情况下是成立的。</p>
<h3 id="设计的要点和存在问题"><a href="#设计的要点和存在问题" class="headerlink" title="设计的要点和存在问题"></a>设计的要点和存在问题</h3><p>per-cpu会带来内存的浪费，核数越多，这种内存浪费越明显。因此，per-cpu不应该用NR_CPUS作为规格来分配内存，而是系统初始化时，按照实际内核的数量来分配，以减少内存浪费。</p>
<p>同时，由于per-cpu的出发点，是加速cpu的访问，避免cpu-cache的不一致问题，因此设计应该尽量符合cpu cache的特点。采取指针数组的形式，主要有以下几个问题需要考虑[^2]：</p>
<ol>
<li>指针数组如果包含在一个数据结构里面，可能会导致其前后的数据成员在内存中的位置过于<br>分散，导致cpu加载该结构时，占据更多的cache lines。</li>
<li>每个cpu只需要一个指针，访问其对应的区域即可。如果采用指针数组，一个cpu可能需要load多个指针的地址，带来不必要的浪费。</li>
<li>获取cpu对应的指针需要两步，获取数组地址，然后获取对应cpu的指针。</li>
</ol>
<p>因此，Christoph采取了一个简单的办法解决以上问题，把指针数组变成一个大数组。即所有per-cpu区域在内存上是连续的，只需要一个指针，通过计算cpu相应的偏移，就可以访问到对应区域。</p>
<h3 id="源码分析-Linux-5-10"><a href="#源码分析-Linux-5-10" class="headerlink" title="源码分析(Linux 5.10)"></a>源码分析(Linux 5.10)</h3><p>如上文所述，per-cpu设计的要点在于：</p>
<ol>
<li>如何减少内存的浪费</li>
<li>如何合理设计数据结构，保证亲和性的同时，减少cache lines的占用</li>
<li>如何管理per-cpu的内存区域</li>
</ol>
<h4 id="per-cpu如何分配和管理内存？"><a href="#per-cpu如何分配和管理内存？" class="headerlink" title="per-cpu如何分配和管理内存？"></a>per-cpu如何分配和管理内存？</h4><p>per-cpu的内存布局如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c0                           c1                         c2</span><br><span class="line">-------------------          -------------------        ------------</span><br><span class="line">| u0 | u1 | u2 | u3 |        | u0 | u1 | u2 | u3 |      | u0 | u1 | u</span><br><span class="line">-------------------  ......  -------------------  ....  ------------</span><br></pre></td></tr></table></figure>

<p>在同一个NUMA节点中，各个core的per-cpu区域是连续的。但是在NUMA节点之间，内存并不是连续的。也就是说，对于多NUMA节点的机器，需要根据cpu获取到对应的基址和偏移。</p>
<p>根据用途的不同，各个cpu的per-cpu的内存区域分为三部分，如下所示:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Static | [Reserved] | Dynamic&gt;</span><br></pre></td></tr></table></figure>
<p>static用于内核编译阶段所能识别出的per-cpu变量。<br>reserved用于内核模块使用到的static per-cpu变量。<br>dynamic用于运行过程中的per-cpu变量的申请和释放。</p>
<p>其中，static区域比较特殊，因为内核的运行就需要使用到该区域，必须尽可能早的进行初始化。</p>
<p>在start_kernel阶段，通过调用setup_per_cpu_areas()初始化per-cpu使用到的内存。</p>
<p>arm64下的实现比较简单，setup_per_cpu_areas的实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void __init setup_per_cpu_areas(void)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long delta;</span><br><span class="line">	unsigned int cpu;</span><br><span class="line">	int rc;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Always reserve area for module percpu variables.  That&#x27;s</span><br><span class="line">	 * what the legacy allocator did.</span><br><span class="line">	 */</span><br><span class="line">	rc = pcpu_embed_first_chunk(PERCPU_MODULE_RESERVE,</span><br><span class="line">				    PERCPU_DYNAMIC_RESERVE, PAGE_SIZE,</span><br><span class="line">				    pcpu_cpu_distance,</span><br><span class="line">				    pcpu_fc_alloc, pcpu_fc_free);</span><br><span class="line">	if (rc &lt; 0)</span><br><span class="line">		panic(&quot;Failed to initialize percpu areas.&quot;);</span><br><span class="line"></span><br><span class="line">	delta = (unsigned long)pcpu_base_addr - (unsigned long)__per_cpu_start;</span><br><span class="line">	for_each_possible_cpu(cpu)</span><br><span class="line">		__per_cpu_offset[cpu] = delta + pcpu_unit_offsets[cpu];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，在pcpu_embed_first_chunk调用完成per-cpu内存初始化之前，任何代码都无法使用per-cpu特性。</p>
<p>这一过程中，最重要的是数据结构是struct  pcpu_alloc_info，相关的内存布局信息都存储在该数据结构中。这里面的内存管理实现细节较多(为了做到严格的内存对齐，而实现加速访问)，这里不做过多赘述，重点关注下几个值的计算过程。</p>
<ol>
<li><p>pcpu_base_addr<br>pcpu_base_addr 是多个NUMA节点中最小的那个基址<br>计算过程为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ptr = alloc_fn(cpu, gi-&gt;nr_units * ai-&gt;unit_size, atom_size);</span><br><span class="line">...</span><br><span class="line">base = min(ptr, base);</span><br><span class="line">...</span><br><span class="line">pcpu_setup_first_chunk(ai, base);</span><br><span class="line">...</span><br><span class="line">pcpu_base_addr = base_addr;</span><br></pre></td></tr></table></figure>
</li>
<li><p>__per_cpu_start<br>__per_cpu_start 是链接脚本中指明的per-cpu section的起始位置，在System.map中值为0。通过__per_cpu_end - __per_cpu_start可以计算static size的大小。</p>
</li>
<li><p>__per_cpu_load<br>__per_cpu_load对PERCPU_INPUT所定义的section进行了进一步封装。在System.map中，其值是per-cpu section的内存起始地址。</p>
</li>
<li><p>pcpu_unit_offsets<br>pcpu_unit_offsets是一个数组，记录了各个CPU static区域对应pcpu_base_addr的偏移。</p>
</li>
<li><p>__per_cpu_offset<br>__per_cpu_offset是一个数组，其计算方式为：__per_cpu_offset[cpu] &#x3D; (unsigned  long)pcpu_base_addr - (unsigned  long)__per_cpu_start + pcpu_unit_offsets[cpu];<br>其结果表示，各个CPU static区域对应__per_cpu_start 的偏移。这一结果非常重要，将后续用于per_cpu变量地址的计算。</p>
</li>
</ol>
<p>这一函数调用结束后，vmlinux中per cpu相关的section会被拷贝到每个CPU对应的static区域。对应代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">for (group = 0; group &lt; ai-&gt;nr_groups; group++) &#123;</span><br><span class="line">	struct pcpu_group_info *gi = &amp;ai-&gt;groups[group];</span><br><span class="line">	void *ptr = areas[group];</span><br><span class="line"></span><br><span class="line">	for (i = 0; i &lt; gi-&gt;nr_units; i++, ptr += ai-&gt;unit_size) &#123;</span><br><span class="line">		if (gi-&gt;cpu_map[i] == NR_CPUS) &#123;</span><br><span class="line">			/* unused unit, free whole */</span><br><span class="line">			free_fn(ptr, ai-&gt;unit_size);</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		/* copy and return the unused part */</span><br><span class="line">		memcpy(ptr, __per_cpu_load, ai-&gt;static_size);</span><br><span class="line">		free_fn(ptr + size_sum, ai-&gt;unit_size - size_sum);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="如何根据不同的cpu，计算出相应的偏移？-ARM64"><a href="#如何根据不同的cpu，计算出相应的偏移？-ARM64" class="headerlink" title="如何根据不同的cpu，计算出相应的偏移？(ARM64)"></a>如何根据不同的cpu，计算出相应的偏移？(ARM64)</h4><p>在boot cpu完成per cpu内存的初始化后，在后续初始化过程中，boot cpu将调用smp_prepare_boot_cpu函数，通过set_my_cpu_offset(per_cpu_offset(smp_processor_id()))完成最终设置。</p>
<p>对于noboot cpu，初始化过程中将调用cpu_init函数，通过set_my_cpu_offset(per_cpu_offset(cpu))完成最终设置。</p>
<p>per_cpu_offset(x)获取的就是之前所说的__per_cpu_offset[x]的值，即cpu x static区域相对于__per_cpu_start的偏移。 </p>
<p>set_my_cpu_offset的实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static inline void set_my_cpu_offset(unsigned long off)</span><br><span class="line">&#123;</span><br><span class="line">	asm volatile(ALTERNATIVE(&quot;msr tpidr_el1, %0&quot;,</span><br><span class="line">				 &quot;msr tpidr_el2, %0&quot;,</span><br><span class="line">				 ARM64_HAS_VIRT_HOST_EXTN)</span><br><span class="line">			:: &quot;r&quot; (off) : &quot;memory&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作用是把之前的偏移值直接写入tpidr_el1或者tpidr_el2寄存器。</p>
<blockquote>
<p>关于smp_processor_id的处理，smp_processor_id使用到了per cpu特性，其最早是在start_kernel–&gt;boot_cpu_init被调用，要早于setup_per_cpu_areas对per cpu的内存进行初始化。这里的调用不会引起问题吗？答案是不会，在更早的start_kernel–&gt;smp_setup_processor_id中，kernel调用了set_my_cpu_offset(0)。即把当前的per cpu偏移设置为0，后面通过per cpu机制访问到的，直接就是vmlinux中的变量。而此时的cpu_number是0，也就是boot cpu的编号。</p>
</blockquote>
<blockquote>
<p>一个查看kernel macro的办法，修改对应make file，加入ccflags-y :&#x3D; -save-temps&#x3D;obj</p>
</blockquote>
<h5 id="定义一个per-cpu变量"><a href="#定义一个per-cpu变量" class="headerlink" title="定义一个per-cpu变量"></a>定义一个per-cpu变量</h5><blockquote>
<p>DEFINE_PER_CPU(int, per_cpu_n)</p>
</blockquote>
<p>这个宏完全展开后，便是</p>
<blockquote>
<p><strong>attribute</strong>((section(“.data..percpu”))) int per_cpu_n</p>
</blockquote>
<p>在定义上，per cpu变量是section固定的变量。</p>
<h5 id="读取一个per-cpu变量"><a href="#读取一个per-cpu变量" class="headerlink" title="读取一个per-cpu变量"></a>读取一个per-cpu变量</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#define SHIFT_PERCPU_PTR(__p, __offset)					\</span><br><span class="line">	RELOC_HIDE((typeof(*(__p)) __kernel __force *)(__p), (__offset))</span><br><span class="line">...</span><br><span class="line">#define this_cpu_ptr(ptr)						\</span><br><span class="line">(&#123;									\</span><br><span class="line">	__verify_pcpu_ptr(ptr);						\</span><br><span class="line">	SHIFT_PERCPU_PTR(ptr, my_cpu_offset);				\</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>__verify_pcpu_ptr通过检查地址，确保该指针指向per cpu变量。SHIFT_PERCPU_PTR通过读取寄存器的值，对变量做一个偏移，从而获取到对应cpu的local变量。</p>
<p>为了防止调度导致上下文在不同的cpu上运行，get_cpu_var将关闭调度，put_cpu_var则重新开启调度。</p>
<h4 id="动态分配的per-cpu变量-chunk区域"><a href="#动态分配的per-cpu变量-chunk区域" class="headerlink" title="动态分配的per cpu变量(chunk区域)"></a>动态分配的per cpu变量(chunk区域)</h4><p>per cpu变量的管理上可以分为三类，分别为static，reserved，dynamic。其中static是编译内核时就可以确认的per cpu变量。其余两类则是运行时，动态进行管理的。其中，reserved区域用于管理模块的static per cpu变量。(模块编译时确定的per cpu变量，但是模块编译和运行，有可能在内核运行过程中，因此这类变量无法用static的方式处理。)</p>
<p>在模块编译时，per cpu变量便被放置在了特定命名的区域(.data..percpu)。</p>
<p>其内存分配过程为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">info-&gt;index.pcpu = find_pcpusec(info);</span><br><span class="line">--&gt; find_sec(info, &quot;.data..percpu&quot;);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">err = percpu_modalloc(mod, info);</span><br><span class="line"> --&gt; mod-&gt;percpu = __alloc_reserved_percpu(pcpusec-&gt;sh_size, align);</span><br><span class="line">  --&gt; pcpu_alloc(size, align, true, GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">err = post_relocation(mod, info);</span><br><span class="line"> --&gt; percpu_modcopy(mod, (void *)info-&gt;sechdrs[info-&gt;index.pcpu].sh_addr,</span><br><span class="line">                     info-&gt;sechdrs[info-&gt;index.pcpu].sh_size);</span><br><span class="line">--&gt; for_each_possible_cpu(cpu)</span><br><span class="line">                      memcpy(per_cpu_ptr(mod-&gt;percpu, cpu), from, size);</span><br></pre></td></tr></table></figure>

<p>chunk内存的管理逻辑本文将不涉及。</p>
<p>对于dynamic区域的per cpu变量，其区别在于如果该区域的内存耗尽了，是可以继续申请的。这也是first_chunk含义的由来，内核在初始化时，设置的dynamic区域被称为first chunk。其余用法与reserved一致。</p>
<h3 id="RSEQ-restartable-sequences-机制"><a href="#RSEQ-restartable-sequences-机制" class="headerlink" title="RSEQ(restartable-sequences)机制"></a>RSEQ(restartable-sequences)机制</h3><h4 id="诞生背景"><a href="#诞生背景" class="headerlink" title="诞生背景"></a>诞生背景</h4><p>并发控制策略可以粗略的分为两种：乐观并发控制(Optimistic Concurrency Control)和悲观并发控制(Pessimistic Concurrency Control)。</p>
<p>悲观并发控制，认为该数据的竞争较为激烈，总是先进行获取锁的动作，再去处理数据，典型的设计就是kernel中的mutx。</p>
<p>乐观并发控制，认为该数据的竞争情况较少。乐观并发控制的一般过程如下：</p>
<ol>
<li>读取数据，记录时间戳。</li>
<li>处理数据，处理结束后。在修改生效前，将相关数据的时间戳与记录数据戳进行比较，如果不一致，则进行回滚操作。</li>
<li>如果一致，则执行修改操作。<br>这种思路最直观的实现，就是CAS(compare and swap)锁。</li>
</ol>
<p>CAS锁的问题在于，其实现需要借助原子变量。体系结构的原子变量实现，通常需要锁总线，这一操作会带来较大的开销。</p>
<p>RSEQ机制源于一种观察，以链表插入为例，通常实现为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. node = head-&gt;next;</span><br><span class="line">2. head-&gt;next = node;</span><br></pre></td></tr></table></figure>
<p>将第一步称为准备区，用于产生最终需要提交的数据。第二步称为提交区，将修改完成的数据提交生效。在第二步执行之前，第一步的重复执行，是不会影响最终的程序结果的。如果线程在准备区开始到提交生效最终之前的执行过程被打断(调度或者信号…)，那么线程只需要从准备区开始位置重新执行即可。rseq机制可以避免原子操作带来的锁总线开销，但是，代价是被打断后重新执行的开销。在临界区(准备区+提交区)比较小或者竞争不激烈的情况下，刚好在这一区域被打断的概率是很低的，已有的数据表明(来自tcmalloc)，rseq的效率是高于CAS的。</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ol>
<li><a target="_blank" rel="noopener" href="https://programmer.ink/think/kernel-kernel-per-cpu-variable-module-writing.html">Per-CPU variable module writing</a></li>
<li><a target="_blank" rel="noopener" href="https://lwn.net/Articles/258238/">Better per-CPU variables</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/260986194">PERCPU变量实现</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/still-smile/p/11655239.html">smp_processor_id()获取当前执行cpu_id</a></li>
<li><a target="_blank" rel="noopener" href="https://www.efficios.com/blog/2019/02/08/linux-restartable-sequences/">The 5-year journey to bring restartable sequences to Linux</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/google/tcmalloc/blob/master/docs/design.md">google&#x2F;tcmalloc</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/facebookarchive/Rseq/blob/master/Rseq.md">facebookarchive&#x2F;Rseq</a></li>
</ol>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/c-cons-destr/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>Prev</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
              2025-05-12 14:45:59
            </span>
            
                  <span class="post-tags">
                    <i class="iconfont icon-tags mr-10" title="Tags"></i>
                    
                    <span class="span--tag mr-8">
                      <a href="/tags/Per-CPU/" title="Per-CPU">
                        #Per-CPU
                      </a>
                    </span>
                    
                    <span class="span--tag mr-8">
                      <a href="/tags/RSEQ/" title="RSEQ">
                        #RSEQ
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
              <a href="/http3-quic/" target="_self">
                <span>Next</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">Contents</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Per-CPU"><span class="toc-text">Per-CPU</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%87%BA%E5%8F%91%E7%82%B9%E5%92%8C%E4%BC%98%E7%82%B9"><span class="toc-text">设计的出发点和优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E7%9A%84%E8%A6%81%E7%82%B9%E5%92%8C%E5%AD%98%E5%9C%A8%E9%97%AE%E9%A2%98"><span class="toc-text">设计的要点和存在问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Linux-5-10"><span class="toc-text">源码分析(Linux 5.10)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#per-cpu%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D%E5%92%8C%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98%EF%BC%9F"><span class="toc-text">per-cpu如何分配和管理内存？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE%E4%B8%8D%E5%90%8C%E7%9A%84cpu%EF%BC%8C%E8%AE%A1%E7%AE%97%E5%87%BA%E7%9B%B8%E5%BA%94%E7%9A%84%E5%81%8F%E7%A7%BB%EF%BC%9F-ARM64"><span class="toc-text">如何根据不同的cpu，计算出相应的偏移？(ARM64)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AAper-cpu%E5%8F%98%E9%87%8F"><span class="toc-text">定义一个per-cpu变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E4%B8%80%E4%B8%AAper-cpu%E5%8F%98%E9%87%8F"><span class="toc-text">读取一个per-cpu变量</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E7%9A%84per-cpu%E5%8F%98%E9%87%8F-chunk%E5%8C%BA%E5%9F%9F"><span class="toc-text">动态分配的per cpu变量(chunk区域)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RSEQ-restartable-sequences-%E6%9C%BA%E5%88%B6"><span class="toc-text">RSEQ(restartable-sequences)机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%9E%E7%94%9F%E8%83%8C%E6%99%AF"><span class="toc-text">诞生背景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-text">参考</span></a></li></ol></li></ol></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
      <div class="comments-container">
        







      </div>
    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          
              <a title="github" target="_blank" rel="noopener" href="https://github.com/anatasluo">
                <i class="iconfont icon-github"></i>
              </a>
              
        </li>
        
        <li>
          
            <a title="email" href="mailto:luolongjuna@gmail.com">
              <i class="iconfont icon-envelope"></i>
            </a>
            
        </li>
        
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/anatasluo">Copyright</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/anatasluo">© 2025 anatasluo</a>
        
    </div>
  
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="Search...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>First search, index file loading, please wait...<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>No result<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The search.xml file was not found, please refer to：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The request failed, Try to refresh the page or try again later.<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        
  
    <div class="share-icon tools-bar-item">
      <a href="javascript: void(0)" id="share-icon">
        <i class="iconfont iconshare"></i>
      </a>
      <div class="share-content hidden">
        
          <a class="share-item" href="https://twitter.com/intent/tweet?text=' + Per-CPU%E5%8F%8ARSEQ%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90 + '&url=' + https%3A%2F%2Fanatasluo.github.io%2Frseq-percpu%2F + '" target="_blank" title="Twitter">
            <i class="iconfont icon-twitter"></i>
          </a>
        
        
          <a class="share-item" href="https://www.facebook.com/sharer.php?u=https://anatasluo.github.io/rseq-percpu/" target="_blank" title="Facebook">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        
      </div>
    </div>
  
  
<script src="/js/shares.js"></script>



      </div>
    </div>
  </body>
</html>
